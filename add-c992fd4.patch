From c992fd4d165970986dab39197d7e90bf7001c4f5 Mon Sep 17 00:00:00 2001
From: Vfrc <wtfwithworld@gmail.com>
Date: Fri, 2 Nov 2018 02:23:28 +0200
Subject: [PATCH] add

---
 add_test_project-59532bd.patch | 12876 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 12876 insertions(+)
 create mode 100644 add_test_project-59532bd.patch

diff --git a/add_test_project-59532bd.patch b/add_test_project-59532bd.patch
new file mode 100644
index 0000000..6fd070a
--- /dev/null
+++ b/add_test_project-59532bd.patch
@@ -0,0 +1,12876 @@
+From 59532bd4441f2e22779f37a0263d2e9728eae570 Mon Sep 17 00:00:00 2001
+From: vaskravchuk <vasiliykravchuk@Vasiliys-iMac.local>
+Date: Mon, 23 Nov 2015 00:10:58 +0200
+Subject: [PATCH] add test project
+
+---
+ BGModesTest.xcodeproj/project.pbxproj                                                                           |  506 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ BGModesTest.xcodeproj/project.xcworkspace/contents.xcworkspacedata                                              |    7 +++++++
+ BGModesTest.xcodeproj/project.xcworkspace/xcuserdata/vasiliykravchuk.xcuserdatad/UserInterfaceState.xcuserstate | Bin 0 -> 17075 bytes
+ BGModesTest.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/BGModesTest.xcscheme                     |   91 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ BGModesTest.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/xcschememanagement.plist                 |   22 ++++++++++++++++++++++
+ BGModesTest.xcworkspace/contents.xcworkspacedata                                                                |   10 ++++++++++
+ BGModesTest.xcworkspace/xcuserdata/vasiliykravchuk.xcuserdatad/UserInterfaceState.xcuserstate                   | Bin 0 -> 19201 bytes
+ BGModesTest.xcworkspace/xcuserdata/vasiliykravchuk.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist             |   23 +++++++++++++++++++++++
+ BGModesTest/AppDelegate.h                                                                                       |   17 +++++++++++++++++
+ BGModesTest/AppDelegate.m                                                                                       |   97 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ BGModesTest/Assets.xcassets/AppIcon.appiconset/Contents.json                                                    |   68 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ BGModesTest/Base.lproj/LaunchScreen.storyboard                                                                  |   27 +++++++++++++++++++++++++++
+ BGModesTest/Base.lproj/Main.storyboard                                                                          |   95 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ BGModesTest/Info.plist                                                                                          |   54 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ BGModesTest/Managers/BackgroundTaskManager/BackgroundTaskManager.h                                              |   17 +++++++++++++++++
+ BGModesTest/Managers/BackgroundTaskManager/BackgroundTaskManager.m                                              |  104 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ BGModesTest/Managers/LocalNotificationsManager/LocalNotificationsManager.h                                      |   20 ++++++++++++++++++++
+ BGModesTest/Managers/LocalNotificationsManager/LocalNotificationsManager.m                                      |  112 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ BGModesTest/Managers/LocationManager/LocationManager.h                                                          |   29 +++++++++++++++++++++++++++++
+ BGModesTest/Managers/LocationManager/LocationManager.m                                                          |  245 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ BGModesTest/Managers/LoggerManager/CustomLoggerFormatter/CustomLoggerFormatter.h                                |   14 ++++++++++++++
+ BGModesTest/Managers/LoggerManager/CustomLoggerFormatter/CustomLoggerFormatter.m                                |   33 +++++++++++++++++++++++++++++++++
+ BGModesTest/Managers/LoggerManager/LoggerManager.h                                                              |   22 ++++++++++++++++++++++
+ BGModesTest/Managers/LoggerManager/LoggerManager.m                                                              |  147 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.h                                      |   20 ++++++++++++++++++++
+ BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.m                                      |   65 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.xib                                    |   50 ++++++++++++++++++++++++++++++++++++++++++++++++++
+ BGModesTest/Managers/ServerManager/ServerManager.h                                                              |   20 ++++++++++++++++++++
+ BGModesTest/Managers/ServerManager/ServerManager.m                                                              |  114 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ BGModesTest/ViewController.h                                                                                    |   15 +++++++++++++++
+ BGModesTest/ViewController.m                                                                                    |   50 ++++++++++++++++++++++++++++++++++++++++++++++++++
+ BGModesTest/main.m                                                                                              |   16 ++++++++++++++++
+ Podfile                                                                                                         |    8 ++++++++
+ Podfile.lock                                                                                                    |   17 +++++++++++++++++
+ Pods/CocoaLumberjack/Classes/CocoaLumberjack.h                                                                  |   81 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/CocoaLumberjack.swift                                                              |   91 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDASLLogCapture.h                                                                  |   48 ++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDASLLogCapture.m                                                                  |  230 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDASLLogger.h                                                                      |   58 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDASLLogger.m                                                                      |  121 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDAbstractDatabaseLogger.h                                                         |  123 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDAbstractDatabaseLogger.m                                                         |  660 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDAssertMacros.h                                                                   |   26 ++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDFileLogger.h                                                                     |  487 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDFileLogger.m                                                                     | 1484 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDLegacyMacros.h                                                                   |   75 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDLog+LOGV.h                                                                       |   83 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDLog.h                                                                            |  743 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDLog.m                                                                            | 1167 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDLogMacros.h                                                                      |   82 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDTTYLogger.h                                                                      |  178 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/DDTTYLogger.m                                                                      | 1481 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/Extensions/DDContextFilterLogFormatter.h                                           |  117 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/Extensions/DDContextFilterLogFormatter.m                                           |  191 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/Extensions/DDDispatchQueueLogFormatter.h                                           |  178 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/Extensions/DDDispatchQueueLogFormatter.m                                           |  277 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/Extensions/DDMultiFormatter.h                                                      |   56 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Classes/Extensions/DDMultiFormatter.m                                                      |  144 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/Framework/Lumberjack/CocoaLumberjack.modulemap                                             |   36 ++++++++++++++++++++++++++++++++++++
+ Pods/CocoaLumberjack/LICENSE.txt                                                                                |   18 ++++++++++++++++++
+ Pods/CocoaLumberjack/README.md                                                                                  |  197 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/Headers/Private/CocoaLumberjack/CocoaLumberjack.h                                                          |    1 +
+ Pods/Headers/Private/CocoaLumberjack/DDASLLogCapture.h                                                          |    1 +
+ Pods/Headers/Private/CocoaLumberjack/DDASLLogger.h                                                              |    1 +
+ Pods/Headers/Private/CocoaLumberjack/DDAbstractDatabaseLogger.h                                                 |    1 +
+ Pods/Headers/Private/CocoaLumberjack/DDAssertMacros.h                                                           |    1 +
+ Pods/Headers/Private/CocoaLumberjack/DDContextFilterLogFormatter.h                                              |    1 +
+ Pods/Headers/Private/CocoaLumberjack/DDDispatchQueueLogFormatter.h                                              |    1 +
+ Pods/Headers/Private/CocoaLumberjack/DDFileLogger.h                                                             |    1 +
+ Pods/Headers/Private/CocoaLumberjack/DDLegacyMacros.h                                                           |    1 +
+ Pods/Headers/Private/CocoaLumberjack/DDLog+LOGV.h                                                               |    1 +
+ Pods/Headers/Private/CocoaLumberjack/DDLog.h                                                                    |    1 +
+ Pods/Headers/Private/CocoaLumberjack/DDLogMacros.h                                                              |    1 +
+ Pods/Headers/Private/CocoaLumberjack/DDMultiFormatter.h                                                         |    1 +
+ Pods/Headers/Private/CocoaLumberjack/DDTTYLogger.h                                                              |    1 +
+ Pods/Headers/Public/CocoaLumberjack/CocoaLumberjack.h                                                           |    1 +
+ Pods/Headers/Public/CocoaLumberjack/DDASLLogCapture.h                                                           |    1 +
+ Pods/Headers/Public/CocoaLumberjack/DDASLLogger.h                                                               |    1 +
+ Pods/Headers/Public/CocoaLumberjack/DDAbstractDatabaseLogger.h                                                  |    1 +
+ Pods/Headers/Public/CocoaLumberjack/DDAssertMacros.h                                                            |    1 +
+ Pods/Headers/Public/CocoaLumberjack/DDContextFilterLogFormatter.h                                               |    1 +
+ Pods/Headers/Public/CocoaLumberjack/DDDispatchQueueLogFormatter.h                                               |    1 +
+ Pods/Headers/Public/CocoaLumberjack/DDFileLogger.h                                                              |    1 +
+ Pods/Headers/Public/CocoaLumberjack/DDLegacyMacros.h                                                            |    1 +
+ Pods/Headers/Public/CocoaLumberjack/DDLog+LOGV.h                                                                |    1 +
+ Pods/Headers/Public/CocoaLumberjack/DDLog.h                                                                     |    1 +
+ Pods/Headers/Public/CocoaLumberjack/DDLogMacros.h                                                               |    1 +
+ Pods/Headers/Public/CocoaLumberjack/DDMultiFormatter.h                                                          |    1 +
+ Pods/Headers/Public/CocoaLumberjack/DDTTYLogger.h                                                               |    1 +
+ Pods/Manifest.lock                                                                                              |   17 +++++++++++++++++
+ Pods/Pods.xcodeproj/project.pbxproj                                                                             |  544 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/CocoaLumberjack.xcscheme                   |   60 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/Pods.xcscheme                              |   60 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/xcschememanagement.plist                   |   32 ++++++++++++++++++++++++++++++++
+ Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack-dummy.m                                               |    5 +++++
+ Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack-prefix.pch                                            |    4 ++++
+ Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack.xcconfig                                              |    4 ++++
+ Pods/Target Support Files/Pods/Pods-acknowledgements.markdown                                                   |   24 ++++++++++++++++++++++++
+ Pods/Target Support Files/Pods/Pods-acknowledgements.plist                                                      |   54 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/Target Support Files/Pods/Pods-dummy.m                                                                     |    5 +++++
+ Pods/Target Support Files/Pods/Pods-frameworks.sh                                                               |   84 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/Target Support Files/Pods/Pods-resources.sh                                                                |   95 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Pods/Target Support Files/Pods/Pods.debug.xcconfig                                                              |    5 +++++
+ Pods/Target Support Files/Pods/Pods.release.xcconfig                                                            |    5 +++++
+ README.md                                                                                                       |    6 ++++++
+ 105 files changed, 11599 insertions(+)
+ create mode 100644 BGModesTest.xcodeproj/project.pbxproj
+ create mode 100644 BGModesTest.xcodeproj/project.xcworkspace/contents.xcworkspacedata
+ create mode 100644 BGModesTest.xcodeproj/project.xcworkspace/xcuserdata/vasiliykravchuk.xcuserdatad/UserInterfaceState.xcuserstate
+ create mode 100644 BGModesTest.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/BGModesTest.xcscheme
+ create mode 100644 BGModesTest.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/xcschememanagement.plist
+ create mode 100644 BGModesTest.xcworkspace/contents.xcworkspacedata
+ create mode 100644 BGModesTest.xcworkspace/xcuserdata/vasiliykravchuk.xcuserdatad/UserInterfaceState.xcuserstate
+ create mode 100644 BGModesTest.xcworkspace/xcuserdata/vasiliykravchuk.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist
+ create mode 100644 BGModesTest/AppDelegate.h
+ create mode 100644 BGModesTest/AppDelegate.m
+ create mode 100644 BGModesTest/Assets.xcassets/AppIcon.appiconset/Contents.json
+ create mode 100644 BGModesTest/Base.lproj/LaunchScreen.storyboard
+ create mode 100644 BGModesTest/Base.lproj/Main.storyboard
+ create mode 100644 BGModesTest/Info.plist
+ create mode 100755 BGModesTest/Managers/BackgroundTaskManager/BackgroundTaskManager.h
+ create mode 100755 BGModesTest/Managers/BackgroundTaskManager/BackgroundTaskManager.m
+ create mode 100644 BGModesTest/Managers/LocalNotificationsManager/LocalNotificationsManager.h
+ create mode 100644 BGModesTest/Managers/LocalNotificationsManager/LocalNotificationsManager.m
+ create mode 100644 BGModesTest/Managers/LocationManager/LocationManager.h
+ create mode 100644 BGModesTest/Managers/LocationManager/LocationManager.m
+ create mode 100644 BGModesTest/Managers/LoggerManager/CustomLoggerFormatter/CustomLoggerFormatter.h
+ create mode 100644 BGModesTest/Managers/LoggerManager/CustomLoggerFormatter/CustomLoggerFormatter.m
+ create mode 100644 BGModesTest/Managers/LoggerManager/LoggerManager.h
+ create mode 100644 BGModesTest/Managers/LoggerManager/LoggerManager.m
+ create mode 100644 BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.h
+ create mode 100644 BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.m
+ create mode 100644 BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.xib
+ create mode 100644 BGModesTest/Managers/ServerManager/ServerManager.h
+ create mode 100644 BGModesTest/Managers/ServerManager/ServerManager.m
+ create mode 100644 BGModesTest/ViewController.h
+ create mode 100644 BGModesTest/ViewController.m
+ create mode 100644 BGModesTest/main.m
+ create mode 100644 Podfile
+ create mode 100644 Podfile.lock
+ create mode 100644 Pods/CocoaLumberjack/Classes/CocoaLumberjack.h
+ create mode 100644 Pods/CocoaLumberjack/Classes/CocoaLumberjack.swift
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDASLLogCapture.h
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDASLLogCapture.m
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDASLLogger.h
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDASLLogger.m
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDAbstractDatabaseLogger.h
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDAbstractDatabaseLogger.m
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDAssertMacros.h
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDFileLogger.h
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDFileLogger.m
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDLegacyMacros.h
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDLog+LOGV.h
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDLog.h
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDLog.m
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDLogMacros.h
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDTTYLogger.h
+ create mode 100644 Pods/CocoaLumberjack/Classes/DDTTYLogger.m
+ create mode 100644 Pods/CocoaLumberjack/Classes/Extensions/DDContextFilterLogFormatter.h
+ create mode 100644 Pods/CocoaLumberjack/Classes/Extensions/DDContextFilterLogFormatter.m
+ create mode 100644 Pods/CocoaLumberjack/Classes/Extensions/DDDispatchQueueLogFormatter.h
+ create mode 100644 Pods/CocoaLumberjack/Classes/Extensions/DDDispatchQueueLogFormatter.m
+ create mode 100644 Pods/CocoaLumberjack/Classes/Extensions/DDMultiFormatter.h
+ create mode 100644 Pods/CocoaLumberjack/Classes/Extensions/DDMultiFormatter.m
+ create mode 100644 Pods/CocoaLumberjack/Framework/Lumberjack/CocoaLumberjack.modulemap
+ create mode 100644 Pods/CocoaLumberjack/LICENSE.txt
+ create mode 100644 Pods/CocoaLumberjack/README.md
+ create mode 120000 Pods/Headers/Private/CocoaLumberjack/CocoaLumberjack.h
+ create mode 120000 Pods/Headers/Private/CocoaLumberjack/DDASLLogCapture.h
+ create mode 120000 Pods/Headers/Private/CocoaLumberjack/DDASLLogger.h
+ create mode 120000 Pods/Headers/Private/CocoaLumberjack/DDAbstractDatabaseLogger.h
+ create mode 120000 Pods/Headers/Private/CocoaLumberjack/DDAssertMacros.h
+ create mode 120000 Pods/Headers/Private/CocoaLumberjack/DDContextFilterLogFormatter.h
+ create mode 120000 Pods/Headers/Private/CocoaLumberjack/DDDispatchQueueLogFormatter.h
+ create mode 120000 Pods/Headers/Private/CocoaLumberjack/DDFileLogger.h
+ create mode 120000 Pods/Headers/Private/CocoaLumberjack/DDLegacyMacros.h
+ create mode 120000 Pods/Headers/Private/CocoaLumberjack/DDLog+LOGV.h
+ create mode 120000 Pods/Headers/Private/CocoaLumberjack/DDLog.h
+ create mode 120000 Pods/Headers/Private/CocoaLumberjack/DDLogMacros.h
+ create mode 120000 Pods/Headers/Private/CocoaLumberjack/DDMultiFormatter.h
+ create mode 120000 Pods/Headers/Private/CocoaLumberjack/DDTTYLogger.h
+ create mode 120000 Pods/Headers/Public/CocoaLumberjack/CocoaLumberjack.h
+ create mode 120000 Pods/Headers/Public/CocoaLumberjack/DDASLLogCapture.h
+ create mode 120000 Pods/Headers/Public/CocoaLumberjack/DDASLLogger.h
+ create mode 120000 Pods/Headers/Public/CocoaLumberjack/DDAbstractDatabaseLogger.h
+ create mode 120000 Pods/Headers/Public/CocoaLumberjack/DDAssertMacros.h
+ create mode 120000 Pods/Headers/Public/CocoaLumberjack/DDContextFilterLogFormatter.h
+ create mode 120000 Pods/Headers/Public/CocoaLumberjack/DDDispatchQueueLogFormatter.h
+ create mode 120000 Pods/Headers/Public/CocoaLumberjack/DDFileLogger.h
+ create mode 120000 Pods/Headers/Public/CocoaLumberjack/DDLegacyMacros.h
+ create mode 120000 Pods/Headers/Public/CocoaLumberjack/DDLog+LOGV.h
+ create mode 120000 Pods/Headers/Public/CocoaLumberjack/DDLog.h
+ create mode 120000 Pods/Headers/Public/CocoaLumberjack/DDLogMacros.h
+ create mode 120000 Pods/Headers/Public/CocoaLumberjack/DDMultiFormatter.h
+ create mode 120000 Pods/Headers/Public/CocoaLumberjack/DDTTYLogger.h
+ create mode 100644 Pods/Manifest.lock
+ create mode 100644 Pods/Pods.xcodeproj/project.pbxproj
+ create mode 100644 Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/CocoaLumberjack.xcscheme
+ create mode 100644 Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/Pods.xcscheme
+ create mode 100644 Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/xcschememanagement.plist
+ create mode 100644 Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack-dummy.m
+ create mode 100644 Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack-prefix.pch
+ create mode 100644 Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack.xcconfig
+ create mode 100644 Pods/Target Support Files/Pods/Pods-acknowledgements.markdown
+ create mode 100644 Pods/Target Support Files/Pods/Pods-acknowledgements.plist
+ create mode 100644 Pods/Target Support Files/Pods/Pods-dummy.m
+ create mode 100755 Pods/Target Support Files/Pods/Pods-frameworks.sh
+ create mode 100755 Pods/Target Support Files/Pods/Pods-resources.sh
+ create mode 100644 Pods/Target Support Files/Pods/Pods.debug.xcconfig
+ create mode 100644 Pods/Target Support Files/Pods/Pods.release.xcconfig
+ create mode 100644 README.md
+
+diff --git a/BGModesTest.xcodeproj/project.pbxproj b/BGModesTest.xcodeproj/project.pbxproj
+new file mode 100644
+index 0000000..37e7165
+--- /dev/null
++++ b/BGModesTest.xcodeproj/project.pbxproj
+@@ -0,0 +1,506 @@
++// !$*UTF8*$!
++{
++	archiveVersion = 1;
++	classes = {
++	};
++	objectVersion = 46;
++	objects = {
++
++/* Begin PBXBuildFile section */
++		314F2C541C02048100DB2840 /* main.m in Sources */ = {isa = PBXBuildFile; fileRef = 314F2C531C02048100DB2840 /* main.m */; };
++		314F2C571C02048100DB2840 /* AppDelegate.m in Sources */ = {isa = PBXBuildFile; fileRef = 314F2C561C02048100DB2840 /* AppDelegate.m */; };
++		314F2C5A1C02048100DB2840 /* ViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 314F2C591C02048100DB2840 /* ViewController.m */; };
++		314F2C5D1C02048100DB2840 /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 314F2C5B1C02048100DB2840 /* Main.storyboard */; };
++		314F2C5F1C02048100DB2840 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 314F2C5E1C02048100DB2840 /* Assets.xcassets */; };
++		314F2C621C02048100DB2840 /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 314F2C601C02048100DB2840 /* LaunchScreen.storyboard */; };
++		314F2C851C022EF000DB2840 /* BackgroundTaskManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 314F2C701C022EF000DB2840 /* BackgroundTaskManager.m */; };
++		314F2C861C022EF000DB2840 /* LocalNotificationsManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 314F2C731C022EF000DB2840 /* LocalNotificationsManager.m */; };
++		314F2C871C022EF000DB2840 /* LocationManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 314F2C761C022EF000DB2840 /* LocationManager.m */; };
++		314F2C881C022EF000DB2840 /* CustomLoggerFormatter.m in Sources */ = {isa = PBXBuildFile; fileRef = 314F2C7A1C022EF000DB2840 /* CustomLoggerFormatter.m */; };
++		314F2C891C022EF000DB2840 /* LoggerManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 314F2C7C1C022EF000DB2840 /* LoggerManager.m */; };
++		314F2C8A1C022EF000DB2840 /* LogsViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 314F2C7F1C022EF000DB2840 /* LogsViewController.m */; };
++		314F2C8B1C022EF000DB2840 /* LogsViewController.xib in Resources */ = {isa = PBXBuildFile; fileRef = 314F2C801C022EF000DB2840 /* LogsViewController.xib */; };
++		314F2C8F1C0236A600DB2840 /* ServerManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 314F2C8E1C0236A600DB2840 /* ServerManager.m */; };
++		314F2C911C023B1F00DB2840 /* MessageUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 314F2C901C023B1F00DB2840 /* MessageUI.framework */; };
++		459ED92971EE09FEEF7E60B0 /* libPods.a in Frameworks */ = {isa = PBXBuildFile; fileRef = 9D8B5F577B0865D892F2E56A /* libPods.a */; };
++/* End PBXBuildFile section */
++
++/* Begin PBXFileReference section */
++		314F2C4F1C02048100DB2840 /* BGModesTest.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = BGModesTest.app; sourceTree = BUILT_PRODUCTS_DIR; };
++		314F2C531C02048100DB2840 /* main.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = main.m; sourceTree = "<group>"; };
++		314F2C551C02048100DB2840 /* AppDelegate.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = AppDelegate.h; sourceTree = "<group>"; };
++		314F2C561C02048100DB2840 /* AppDelegate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = AppDelegate.m; sourceTree = "<group>"; };
++		314F2C581C02048100DB2840 /* ViewController.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = ViewController.h; sourceTree = "<group>"; };
++		314F2C591C02048100DB2840 /* ViewController.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = ViewController.m; sourceTree = "<group>"; };
++		314F2C5C1C02048100DB2840 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
++		314F2C5E1C02048100DB2840 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
++		314F2C611C02048100DB2840 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
++		314F2C631C02048100DB2840 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
++		314F2C6F1C022EF000DB2840 /* BackgroundTaskManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = BackgroundTaskManager.h; sourceTree = "<group>"; };
++		314F2C701C022EF000DB2840 /* BackgroundTaskManager.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = BackgroundTaskManager.m; sourceTree = "<group>"; };
++		314F2C721C022EF000DB2840 /* LocalNotificationsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LocalNotificationsManager.h; sourceTree = "<group>"; };
++		314F2C731C022EF000DB2840 /* LocalNotificationsManager.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = LocalNotificationsManager.m; sourceTree = "<group>"; };
++		314F2C751C022EF000DB2840 /* LocationManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LocationManager.h; sourceTree = "<group>"; };
++		314F2C761C022EF000DB2840 /* LocationManager.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = LocationManager.m; sourceTree = "<group>"; };
++		314F2C791C022EF000DB2840 /* CustomLoggerFormatter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CustomLoggerFormatter.h; sourceTree = "<group>"; };
++		314F2C7A1C022EF000DB2840 /* CustomLoggerFormatter.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = CustomLoggerFormatter.m; sourceTree = "<group>"; };
++		314F2C7B1C022EF000DB2840 /* LoggerManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LoggerManager.h; sourceTree = "<group>"; };
++		314F2C7C1C022EF000DB2840 /* LoggerManager.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = LoggerManager.m; sourceTree = "<group>"; };
++		314F2C7E1C022EF000DB2840 /* LogsViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LogsViewController.h; sourceTree = "<group>"; };
++		314F2C7F1C022EF000DB2840 /* LogsViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = LogsViewController.m; sourceTree = "<group>"; };
++		314F2C801C022EF000DB2840 /* LogsViewController.xib */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.xib; path = LogsViewController.xib; sourceTree = "<group>"; };
++		314F2C8D1C0236A600DB2840 /* ServerManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ServerManager.h; sourceTree = "<group>"; };
++		314F2C8E1C0236A600DB2840 /* ServerManager.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ServerManager.m; sourceTree = "<group>"; };
++		314F2C901C023B1F00DB2840 /* MessageUI.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = MessageUI.framework; path = System/Library/Frameworks/MessageUI.framework; sourceTree = SDKROOT; };
++		8F8F89E545512B11B3E1D327 /* Pods.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = Pods.release.xcconfig; path = "Pods/Target Support Files/Pods/Pods.release.xcconfig"; sourceTree = "<group>"; };
++		9D8B5F577B0865D892F2E56A /* libPods.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libPods.a; sourceTree = BUILT_PRODUCTS_DIR; };
++		ED609D0D8A46154B31822AD0 /* Pods.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = Pods.debug.xcconfig; path = "Pods/Target Support Files/Pods/Pods.debug.xcconfig"; sourceTree = "<group>"; };
++/* End PBXFileReference section */
++
++/* Begin PBXFrameworksBuildPhase section */
++		314F2C4C1C02048100DB2840 /* Frameworks */ = {
++			isa = PBXFrameworksBuildPhase;
++			buildActionMask = 2147483647;
++			files = (
++				314F2C911C023B1F00DB2840 /* MessageUI.framework in Frameworks */,
++				459ED92971EE09FEEF7E60B0 /* libPods.a in Frameworks */,
++			);
++			runOnlyForDeploymentPostprocessing = 0;
++		};
++/* End PBXFrameworksBuildPhase section */
++
++/* Begin PBXGroup section */
++		314F2C461C02048100DB2840 = {
++			isa = PBXGroup;
++			children = (
++				314F2C511C02048100DB2840 /* BGModesTest */,
++				314F2C501C02048100DB2840 /* Products */,
++				8A96B51F070C9541EEE4D12E /* Pods */,
++				D3B22BD9D89817FE6D5B2DB6 /* Frameworks */,
++			);
++			sourceTree = "<group>";
++		};
++		314F2C501C02048100DB2840 /* Products */ = {
++			isa = PBXGroup;
++			children = (
++				314F2C4F1C02048100DB2840 /* BGModesTest.app */,
++			);
++			name = Products;
++			sourceTree = "<group>";
++		};
++		314F2C511C02048100DB2840 /* BGModesTest */ = {
++			isa = PBXGroup;
++			children = (
++				314F2C6D1C022EF000DB2840 /* Managers */,
++				314F2C551C02048100DB2840 /* AppDelegate.h */,
++				314F2C561C02048100DB2840 /* AppDelegate.m */,
++				314F2C581C02048100DB2840 /* ViewController.h */,
++				314F2C591C02048100DB2840 /* ViewController.m */,
++				314F2C5B1C02048100DB2840 /* Main.storyboard */,
++				314F2C5E1C02048100DB2840 /* Assets.xcassets */,
++				314F2C601C02048100DB2840 /* LaunchScreen.storyboard */,
++				314F2C631C02048100DB2840 /* Info.plist */,
++				314F2C521C02048100DB2840 /* Supporting Files */,
++			);
++			path = BGModesTest;
++			sourceTree = "<group>";
++		};
++		314F2C521C02048100DB2840 /* Supporting Files */ = {
++			isa = PBXGroup;
++			children = (
++				314F2C531C02048100DB2840 /* main.m */,
++			);
++			name = "Supporting Files";
++			sourceTree = "<group>";
++		};
++		314F2C6D1C022EF000DB2840 /* Managers */ = {
++			isa = PBXGroup;
++			children = (
++				314F2C6E1C022EF000DB2840 /* BackgroundTaskManager */,
++				314F2C711C022EF000DB2840 /* LocalNotificationsManager */,
++				314F2C741C022EF000DB2840 /* LocationManager */,
++				314F2C771C022EF000DB2840 /* LoggerManager */,
++				314F2C811C022EF000DB2840 /* ServerManager */,
++			);
++			path = Managers;
++			sourceTree = "<group>";
++		};
++		314F2C6E1C022EF000DB2840 /* BackgroundTaskManager */ = {
++			isa = PBXGroup;
++			children = (
++				314F2C6F1C022EF000DB2840 /* BackgroundTaskManager.h */,
++				314F2C701C022EF000DB2840 /* BackgroundTaskManager.m */,
++			);
++			path = BackgroundTaskManager;
++			sourceTree = "<group>";
++		};
++		314F2C711C022EF000DB2840 /* LocalNotificationsManager */ = {
++			isa = PBXGroup;
++			children = (
++				314F2C721C022EF000DB2840 /* LocalNotificationsManager.h */,
++				314F2C731C022EF000DB2840 /* LocalNotificationsManager.m */,
++			);
++			path = LocalNotificationsManager;
++			sourceTree = "<group>";
++		};
++		314F2C741C022EF000DB2840 /* LocationManager */ = {
++			isa = PBXGroup;
++			children = (
++				314F2C751C022EF000DB2840 /* LocationManager.h */,
++				314F2C761C022EF000DB2840 /* LocationManager.m */,
++			);
++			path = LocationManager;
++			sourceTree = "<group>";
++		};
++		314F2C771C022EF000DB2840 /* LoggerManager */ = {
++			isa = PBXGroup;
++			children = (
++				314F2C781C022EF000DB2840 /* CustomLoggerFormatter */,
++				314F2C7B1C022EF000DB2840 /* LoggerManager.h */,
++				314F2C7C1C022EF000DB2840 /* LoggerManager.m */,
++				314F2C7D1C022EF000DB2840 /* LogsViewController */,
++			);
++			path = LoggerManager;
++			sourceTree = "<group>";
++		};
++		314F2C781C022EF000DB2840 /* CustomLoggerFormatter */ = {
++			isa = PBXGroup;
++			children = (
++				314F2C791C022EF000DB2840 /* CustomLoggerFormatter.h */,
++				314F2C7A1C022EF000DB2840 /* CustomLoggerFormatter.m */,
++			);
++			path = CustomLoggerFormatter;
++			sourceTree = "<group>";
++		};
++		314F2C7D1C022EF000DB2840 /* LogsViewController */ = {
++			isa = PBXGroup;
++			children = (
++				314F2C7E1C022EF000DB2840 /* LogsViewController.h */,
++				314F2C7F1C022EF000DB2840 /* LogsViewController.m */,
++				314F2C801C022EF000DB2840 /* LogsViewController.xib */,
++			);
++			path = LogsViewController;
++			sourceTree = "<group>";
++		};
++		314F2C811C022EF000DB2840 /* ServerManager */ = {
++			isa = PBXGroup;
++			children = (
++				314F2C8D1C0236A600DB2840 /* ServerManager.h */,
++				314F2C8E1C0236A600DB2840 /* ServerManager.m */,
++			);
++			path = ServerManager;
++			sourceTree = "<group>";
++		};
++		8A96B51F070C9541EEE4D12E /* Pods */ = {
++			isa = PBXGroup;
++			children = (
++				ED609D0D8A46154B31822AD0 /* Pods.debug.xcconfig */,
++				8F8F89E545512B11B3E1D327 /* Pods.release.xcconfig */,
++			);
++			name = Pods;
++			sourceTree = "<group>";
++		};
++		D3B22BD9D89817FE6D5B2DB6 /* Frameworks */ = {
++			isa = PBXGroup;
++			children = (
++				314F2C901C023B1F00DB2840 /* MessageUI.framework */,
++				9D8B5F577B0865D892F2E56A /* libPods.a */,
++			);
++			name = Frameworks;
++			sourceTree = "<group>";
++		};
++/* End PBXGroup section */
++
++/* Begin PBXNativeTarget section */
++		314F2C4E1C02048100DB2840 /* BGModesTest */ = {
++			isa = PBXNativeTarget;
++			buildConfigurationList = 314F2C661C02048100DB2840 /* Build configuration list for PBXNativeTarget "BGModesTest" */;
++			buildPhases = (
++				DF598E10337BE878C0004822 /* Check Pods Manifest.lock */,
++				314F2C4B1C02048100DB2840 /* Sources */,
++				314F2C4C1C02048100DB2840 /* Frameworks */,
++				314F2C4D1C02048100DB2840 /* Resources */,
++				60E342173E286C50A23D1DC7 /* Embed Pods Frameworks */,
++				3555EAC69BE4B3E9793E4A06 /* Copy Pods Resources */,
++			);
++			buildRules = (
++			);
++			dependencies = (
++			);
++			name = BGModesTest;
++			productName = BGModesTest;
++			productReference = 314F2C4F1C02048100DB2840 /* BGModesTest.app */;
++			productType = "com.apple.product-type.application";
++		};
++/* End PBXNativeTarget section */
++
++/* Begin PBXProject section */
++		314F2C471C02048100DB2840 /* Project object */ = {
++			isa = PBXProject;
++			attributes = {
++				LastUpgradeCheck = 0710;
++				ORGANIZATIONNAME = LWS;
++				TargetAttributes = {
++					314F2C4E1C02048100DB2840 = {
++						CreatedOnToolsVersion = 7.1.1;
++						SystemCapabilities = {
++							com.apple.BackgroundModes = {
++								enabled = 1;
++							};
++						};
++					};
++				};
++			};
++			buildConfigurationList = 314F2C4A1C02048100DB2840 /* Build configuration list for PBXProject "BGModesTest" */;
++			compatibilityVersion = "Xcode 3.2";
++			developmentRegion = English;
++			hasScannedForEncodings = 0;
++			knownRegions = (
++				en,
++				Base,
++			);
++			mainGroup = 314F2C461C02048100DB2840;
++			productRefGroup = 314F2C501C02048100DB2840 /* Products */;
++			projectDirPath = "";
++			projectRoot = "";
++			targets = (
++				314F2C4E1C02048100DB2840 /* BGModesTest */,
++			);
++		};
++/* End PBXProject section */
++
++/* Begin PBXResourcesBuildPhase section */
++		314F2C4D1C02048100DB2840 /* Resources */ = {
++			isa = PBXResourcesBuildPhase;
++			buildActionMask = 2147483647;
++			files = (
++				314F2C621C02048100DB2840 /* LaunchScreen.storyboard in Resources */,
++				314F2C5F1C02048100DB2840 /* Assets.xcassets in Resources */,
++				314F2C5D1C02048100DB2840 /* Main.storyboard in Resources */,
++				314F2C8B1C022EF000DB2840 /* LogsViewController.xib in Resources */,
++			);
++			runOnlyForDeploymentPostprocessing = 0;
++		};
++/* End PBXResourcesBuildPhase section */
++
++/* Begin PBXShellScriptBuildPhase section */
++		3555EAC69BE4B3E9793E4A06 /* Copy Pods Resources */ = {
++			isa = PBXShellScriptBuildPhase;
++			buildActionMask = 2147483647;
++			files = (
++			);
++			inputPaths = (
++			);
++			name = "Copy Pods Resources";
++			outputPaths = (
++			);
++			runOnlyForDeploymentPostprocessing = 0;
++			shellPath = /bin/sh;
++			shellScript = "\"${SRCROOT}/Pods/Target Support Files/Pods/Pods-resources.sh\"\n";
++			showEnvVarsInLog = 0;
++		};
++		60E342173E286C50A23D1DC7 /* Embed Pods Frameworks */ = {
++			isa = PBXShellScriptBuildPhase;
++			buildActionMask = 2147483647;
++			files = (
++			);
++			inputPaths = (
++			);
++			name = "Embed Pods Frameworks";
++			outputPaths = (
++			);
++			runOnlyForDeploymentPostprocessing = 0;
++			shellPath = /bin/sh;
++			shellScript = "\"${SRCROOT}/Pods/Target Support Files/Pods/Pods-frameworks.sh\"\n";
++			showEnvVarsInLog = 0;
++		};
++		DF598E10337BE878C0004822 /* Check Pods Manifest.lock */ = {
++			isa = PBXShellScriptBuildPhase;
++			buildActionMask = 2147483647;
++			files = (
++			);
++			inputPaths = (
++			);
++			name = "Check Pods Manifest.lock";
++			outputPaths = (
++			);
++			runOnlyForDeploymentPostprocessing = 0;
++			shellPath = /bin/sh;
++			shellScript = "diff \"${PODS_ROOT}/../Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [[ $? != 0 ]] ; then\n    cat << EOM\nerror: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\nEOM\n    exit 1\nfi\n";
++			showEnvVarsInLog = 0;
++		};
++/* End PBXShellScriptBuildPhase section */
++
++/* Begin PBXSourcesBuildPhase section */
++		314F2C4B1C02048100DB2840 /* Sources */ = {
++			isa = PBXSourcesBuildPhase;
++			buildActionMask = 2147483647;
++			files = (
++				314F2C871C022EF000DB2840 /* LocationManager.m in Sources */,
++				314F2C851C022EF000DB2840 /* BackgroundTaskManager.m in Sources */,
++				314F2C8F1C0236A600DB2840 /* ServerManager.m in Sources */,
++				314F2C5A1C02048100DB2840 /* ViewController.m in Sources */,
++				314F2C571C02048100DB2840 /* AppDelegate.m in Sources */,
++				314F2C541C02048100DB2840 /* main.m in Sources */,
++				314F2C891C022EF000DB2840 /* LoggerManager.m in Sources */,
++				314F2C861C022EF000DB2840 /* LocalNotificationsManager.m in Sources */,
++				314F2C881C022EF000DB2840 /* CustomLoggerFormatter.m in Sources */,
++				314F2C8A1C022EF000DB2840 /* LogsViewController.m in Sources */,
++			);
++			runOnlyForDeploymentPostprocessing = 0;
++		};
++/* End PBXSourcesBuildPhase section */
++
++/* Begin PBXVariantGroup section */
++		314F2C5B1C02048100DB2840 /* Main.storyboard */ = {
++			isa = PBXVariantGroup;
++			children = (
++				314F2C5C1C02048100DB2840 /* Base */,
++			);
++			name = Main.storyboard;
++			sourceTree = "<group>";
++		};
++		314F2C601C02048100DB2840 /* LaunchScreen.storyboard */ = {
++			isa = PBXVariantGroup;
++			children = (
++				314F2C611C02048100DB2840 /* Base */,
++			);
++			name = LaunchScreen.storyboard;
++			sourceTree = "<group>";
++		};
++/* End PBXVariantGroup section */
++
++/* Begin XCBuildConfiguration section */
++		314F2C641C02048100DB2840 /* Debug */ = {
++			isa = XCBuildConfiguration;
++			buildSettings = {
++				ALWAYS_SEARCH_USER_PATHS = NO;
++				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
++				CLANG_CXX_LIBRARY = "libc++";
++				CLANG_ENABLE_MODULES = YES;
++				CLANG_ENABLE_OBJC_ARC = YES;
++				CLANG_WARN_BOOL_CONVERSION = YES;
++				CLANG_WARN_CONSTANT_CONVERSION = YES;
++				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
++				CLANG_WARN_EMPTY_BODY = YES;
++				CLANG_WARN_ENUM_CONVERSION = YES;
++				CLANG_WARN_INT_CONVERSION = YES;
++				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
++				CLANG_WARN_UNREACHABLE_CODE = YES;
++				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
++				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
++				COPY_PHASE_STRIP = NO;
++				DEBUG_INFORMATION_FORMAT = dwarf;
++				ENABLE_STRICT_OBJC_MSGSEND = YES;
++				ENABLE_TESTABILITY = YES;
++				GCC_C_LANGUAGE_STANDARD = gnu99;
++				GCC_DYNAMIC_NO_PIC = NO;
++				GCC_NO_COMMON_BLOCKS = YES;
++				GCC_OPTIMIZATION_LEVEL = 0;
++				GCC_PREPROCESSOR_DEFINITIONS = (
++					"DEBUG=1",
++					"$(inherited)",
++				);
++				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
++				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
++				GCC_WARN_UNDECLARED_SELECTOR = YES;
++				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
++				GCC_WARN_UNUSED_FUNCTION = YES;
++				GCC_WARN_UNUSED_VARIABLE = YES;
++				IPHONEOS_DEPLOYMENT_TARGET = 9.1;
++				MTL_ENABLE_DEBUG_INFO = YES;
++				ONLY_ACTIVE_ARCH = YES;
++				SDKROOT = iphoneos;
++				TARGETED_DEVICE_FAMILY = "1,2";
++			};
++			name = Debug;
++		};
++		314F2C651C02048100DB2840 /* Release */ = {
++			isa = XCBuildConfiguration;
++			buildSettings = {
++				ALWAYS_SEARCH_USER_PATHS = NO;
++				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
++				CLANG_CXX_LIBRARY = "libc++";
++				CLANG_ENABLE_MODULES = YES;
++				CLANG_ENABLE_OBJC_ARC = YES;
++				CLANG_WARN_BOOL_CONVERSION = YES;
++				CLANG_WARN_CONSTANT_CONVERSION = YES;
++				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
++				CLANG_WARN_EMPTY_BODY = YES;
++				CLANG_WARN_ENUM_CONVERSION = YES;
++				CLANG_WARN_INT_CONVERSION = YES;
++				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
++				CLANG_WARN_UNREACHABLE_CODE = YES;
++				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
++				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
++				COPY_PHASE_STRIP = NO;
++				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
++				ENABLE_NS_ASSERTIONS = NO;
++				ENABLE_STRICT_OBJC_MSGSEND = YES;
++				GCC_C_LANGUAGE_STANDARD = gnu99;
++				GCC_NO_COMMON_BLOCKS = YES;
++				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
++				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
++				GCC_WARN_UNDECLARED_SELECTOR = YES;
++				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
++				GCC_WARN_UNUSED_FUNCTION = YES;
++				GCC_WARN_UNUSED_VARIABLE = YES;
++				IPHONEOS_DEPLOYMENT_TARGET = 9.1;
++				MTL_ENABLE_DEBUG_INFO = NO;
++				SDKROOT = iphoneos;
++				TARGETED_DEVICE_FAMILY = "1,2";
++				VALIDATE_PRODUCT = YES;
++			};
++			name = Release;
++		};
++		314F2C671C02048100DB2840 /* Debug */ = {
++			isa = XCBuildConfiguration;
++			baseConfigurationReference = ED609D0D8A46154B31822AD0 /* Pods.debug.xcconfig */;
++			buildSettings = {
++				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
++				INFOPLIST_FILE = BGModesTest/Info.plist;
++				IPHONEOS_DEPLOYMENT_TARGET = 7.0;
++				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks";
++				PRODUCT_BUNDLE_IDENTIFIER = com.test.BGModesTest;
++				PRODUCT_NAME = "$(TARGET_NAME)";
++			};
++			name = Debug;
++		};
++		314F2C681C02048100DB2840 /* Release */ = {
++			isa = XCBuildConfiguration;
++			baseConfigurationReference = 8F8F89E545512B11B3E1D327 /* Pods.release.xcconfig */;
++			buildSettings = {
++				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
++				INFOPLIST_FILE = BGModesTest/Info.plist;
++				IPHONEOS_DEPLOYMENT_TARGET = 7.0;
++				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks";
++				PRODUCT_BUNDLE_IDENTIFIER = com.test.BGModesTest;
++				PRODUCT_NAME = "$(TARGET_NAME)";
++			};
++			name = Release;
++		};
++/* End XCBuildConfiguration section */
++
++/* Begin XCConfigurationList section */
++		314F2C4A1C02048100DB2840 /* Build configuration list for PBXProject "BGModesTest" */ = {
++			isa = XCConfigurationList;
++			buildConfigurations = (
++				314F2C641C02048100DB2840 /* Debug */,
++				314F2C651C02048100DB2840 /* Release */,
++			);
++			defaultConfigurationIsVisible = 0;
++			defaultConfigurationName = Release;
++		};
++		314F2C661C02048100DB2840 /* Build configuration list for PBXNativeTarget "BGModesTest" */ = {
++			isa = XCConfigurationList;
++			buildConfigurations = (
++				314F2C671C02048100DB2840 /* Debug */,
++				314F2C681C02048100DB2840 /* Release */,
++			);
++			defaultConfigurationIsVisible = 0;
++			defaultConfigurationName = Release;
++		};
++/* End XCConfigurationList section */
++	};
++	rootObject = 314F2C471C02048100DB2840 /* Project object */;
++}
+diff --git a/BGModesTest.xcodeproj/project.xcworkspace/contents.xcworkspacedata b/BGModesTest.xcodeproj/project.xcworkspace/contents.xcworkspacedata
+new file mode 100644
+index 0000000..5295470
+--- /dev/null
++++ b/BGModesTest.xcodeproj/project.xcworkspace/contents.xcworkspacedata
+@@ -0,0 +1,7 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<Workspace
++   version = "1.0">
++   <FileRef
++      location = "self:BGModesTest.xcodeproj">
++   </FileRef>
++</Workspace>
+diff --git a/BGModesTest.xcodeproj/project.xcworkspace/xcuserdata/vasiliykravchuk.xcuserdatad/UserInterfaceState.xcuserstate b/BGModesTest.xcodeproj/project.xcworkspace/xcuserdata/vasiliykravchuk.xcuserdatad/UserInterfaceState.xcuserstate
+new file mode 100644
+index 0000000000000000000000000000000000000000..c8df4afbcfe8c59bd56e4c04193759567ec48ff1
+GIT binary patch
+literal 17075
+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
+
+literal 0
+Hc$@<O00001
+
+diff --git a/BGModesTest.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/BGModesTest.xcscheme b/BGModesTest.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/BGModesTest.xcscheme
+new file mode 100644
+index 0000000..dd4a35f
+--- /dev/null
++++ b/BGModesTest.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/BGModesTest.xcscheme
+@@ -0,0 +1,91 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<Scheme
++   LastUpgradeVersion = "0710"
++   version = "1.3">
++   <BuildAction
++      parallelizeBuildables = "YES"
++      buildImplicitDependencies = "YES">
++      <BuildActionEntries>
++         <BuildActionEntry
++            buildForTesting = "YES"
++            buildForRunning = "YES"
++            buildForProfiling = "YES"
++            buildForArchiving = "YES"
++            buildForAnalyzing = "YES">
++            <BuildableReference
++               BuildableIdentifier = "primary"
++               BlueprintIdentifier = "314F2C4E1C02048100DB2840"
++               BuildableName = "BGModesTest.app"
++               BlueprintName = "BGModesTest"
++               ReferencedContainer = "container:BGModesTest.xcodeproj">
++            </BuildableReference>
++         </BuildActionEntry>
++      </BuildActionEntries>
++   </BuildAction>
++   <TestAction
++      buildConfiguration = "Debug"
++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
++      shouldUseLaunchSchemeArgsEnv = "YES">
++      <Testables>
++      </Testables>
++      <MacroExpansion>
++         <BuildableReference
++            BuildableIdentifier = "primary"
++            BlueprintIdentifier = "314F2C4E1C02048100DB2840"
++            BuildableName = "BGModesTest.app"
++            BlueprintName = "BGModesTest"
++            ReferencedContainer = "container:BGModesTest.xcodeproj">
++         </BuildableReference>
++      </MacroExpansion>
++      <AdditionalOptions>
++      </AdditionalOptions>
++   </TestAction>
++   <LaunchAction
++      buildConfiguration = "Debug"
++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
++      launchStyle = "0"
++      useCustomWorkingDirectory = "NO"
++      ignoresPersistentStateOnLaunch = "NO"
++      debugDocumentVersioning = "YES"
++      debugServiceExtension = "internal"
++      allowLocationSimulation = "YES">
++      <BuildableProductRunnable
++         runnableDebuggingMode = "0">
++         <BuildableReference
++            BuildableIdentifier = "primary"
++            BlueprintIdentifier = "314F2C4E1C02048100DB2840"
++            BuildableName = "BGModesTest.app"
++            BlueprintName = "BGModesTest"
++            ReferencedContainer = "container:BGModesTest.xcodeproj">
++         </BuildableReference>
++      </BuildableProductRunnable>
++      <AdditionalOptions>
++      </AdditionalOptions>
++   </LaunchAction>
++   <ProfileAction
++      buildConfiguration = "Release"
++      shouldUseLaunchSchemeArgsEnv = "YES"
++      savedToolIdentifier = ""
++      useCustomWorkingDirectory = "NO"
++      debugDocumentVersioning = "YES">
++      <BuildableProductRunnable
++         runnableDebuggingMode = "0">
++         <BuildableReference
++            BuildableIdentifier = "primary"
++            BlueprintIdentifier = "314F2C4E1C02048100DB2840"
++            BuildableName = "BGModesTest.app"
++            BlueprintName = "BGModesTest"
++            ReferencedContainer = "container:BGModesTest.xcodeproj">
++         </BuildableReference>
++      </BuildableProductRunnable>
++   </ProfileAction>
++   <AnalyzeAction
++      buildConfiguration = "Debug">
++   </AnalyzeAction>
++   <ArchiveAction
++      buildConfiguration = "Release"
++      revealArchiveInOrganizer = "YES">
++   </ArchiveAction>
++</Scheme>
+diff --git a/BGModesTest.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/xcschememanagement.plist b/BGModesTest.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/xcschememanagement.plist
+new file mode 100644
+index 0000000..7aa57b6
+--- /dev/null
++++ b/BGModesTest.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/xcschememanagement.plist
+@@ -0,0 +1,22 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
++<plist version="1.0">
++<dict>
++	<key>SchemeUserState</key>
++	<dict>
++		<key>BGModesTest.xcscheme</key>
++		<dict>
++			<key>orderHint</key>
++			<integer>0</integer>
++		</dict>
++	</dict>
++	<key>SuppressBuildableAutocreation</key>
++	<dict>
++		<key>314F2C4E1C02048100DB2840</key>
++		<dict>
++			<key>primary</key>
++			<true/>
++		</dict>
++	</dict>
++</dict>
++</plist>
+diff --git a/BGModesTest.xcworkspace/contents.xcworkspacedata b/BGModesTest.xcworkspace/contents.xcworkspacedata
+new file mode 100644
+index 0000000..a305086
+--- /dev/null
++++ b/BGModesTest.xcworkspace/contents.xcworkspacedata
+@@ -0,0 +1,10 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<Workspace
++   version = "1.0">
++   <FileRef
++      location = "group:BGModesTest.xcodeproj">
++   </FileRef>
++   <FileRef
++      location = "group:Pods/Pods.xcodeproj">
++   </FileRef>
++</Workspace>
+diff --git a/BGModesTest.xcworkspace/xcuserdata/vasiliykravchuk.xcuserdatad/UserInterfaceState.xcuserstate b/BGModesTest.xcworkspace/xcuserdata/vasiliykravchuk.xcuserdatad/UserInterfaceState.xcuserstate
+new file mode 100644
+index 0000000000000000000000000000000000000000..62c96ed543323b10525af9d952a699875ccfc080
+GIT binary patch
+literal 19201
+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
+Vwccmj_frV&ua}SKeoF82{|6hSJxBlm
+
+literal 0
+Hc$@<O00001
+
+diff --git a/BGModesTest.xcworkspace/xcuserdata/vasiliykravchuk.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist b/BGModesTest.xcworkspace/xcuserdata/vasiliykravchuk.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist
+new file mode 100644
+index 0000000..7f4fca4
+--- /dev/null
++++ b/BGModesTest.xcworkspace/xcuserdata/vasiliykravchuk.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist
+@@ -0,0 +1,23 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<Bucket
++   type = "0"
++   version = "2.0">
++   <Breakpoints>
++      <BreakpointProxy
++         BreakpointExtensionID = "Xcode.Breakpoint.FileBreakpoint">
++         <BreakpointContent
++            shouldBeEnabled = "Yes"
++            ignoreCount = "0"
++            continueAfterRunningActions = "No"
++            filePath = "BGModesTest/Managers/LocationManager/LocationManager.m"
++            timestampString = "469919495.632737"
++            startingColumnNumber = "9223372036854775807"
++            endingColumnNumber = "9223372036854775807"
++            startingLineNumber = "185"
++            endingLineNumber = "185"
++            landmarkName = "-stopUpdateLocation"
++            landmarkType = "5">
++         </BreakpointContent>
++      </BreakpointProxy>
++   </Breakpoints>
++</Bucket>
+diff --git a/BGModesTest/AppDelegate.h b/BGModesTest/AppDelegate.h
+new file mode 100644
+index 0000000..fd48d4e
+--- /dev/null
++++ b/BGModesTest/AppDelegate.h
+@@ -0,0 +1,17 @@
++//
++//  AppDelegate.h
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 22.11.15.
++//  Copyright © 2015 LWS. All rights reserved.
++//
++
++#import <UIKit/UIKit.h>
++
++@interface AppDelegate : UIResponder <UIApplicationDelegate>
++
++@property (strong, nonatomic) UIWindow *window;
++
++
++@end
++
+diff --git a/BGModesTest/AppDelegate.m b/BGModesTest/AppDelegate.m
+new file mode 100644
+index 0000000..98860b5
+--- /dev/null
++++ b/BGModesTest/AppDelegate.m
+@@ -0,0 +1,97 @@
++//
++//  AppDelegate.m
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 22.11.15.
++//  Copyright © 2015 LWS. All rights reserved.
++//
++
++#import "AppDelegate.h"
++#import "LocationManager.h"
++#import "ServerManager.h"
++#import "LoggerManager.h"
++#import "LocalNotificationsManager.h"
++
++@interface AppDelegate ()
++
++@end
++
++@implementation AppDelegate
++
++
++- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
++    [LoggerManagerInstance addMessage:[NSString stringWithFormat:@"AppDelegate application didFinishLaunchingWithOptions %@",launchOptions.description]];
++    //remove icon badge number
++    [[UIApplication sharedApplication] setApplicationIconBadgeNumber:0];
++    
++    [ServerManagerInstance updateState];
++    
++    if([launchOptions valueForKey:@"UIApplicationLaunchOptionsLocationKey"]){
++        //useSignificantLocationChangesChanged or region monitoring
++        [LoggerManagerInstance addMessage:@"AppDelegate application didFinishLaunchingWithOptions launchOptions has key 'UIApplicationLaunchOptionsLocationKey'"];
++        if(ServerManagerInstance.isAvailable) {
++            [LocationManagerInstance startUpdateLocation];
++            [LocationManagerInstance setBackground:YES];
++            LocationManagerInstance.startFromSagnificantLocation = YES;
++            [LocalNotificationsManagerInstance startUpdate];
++        }
++    }
++    else {
++    }
++    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(updateAvailibility) name:kServerAvailabilityChanged object:nil];
++    return YES;
++}
++-(void)dealloc {
++    [[NSNotificationCenter defaultCenter] removeObserver:self];
++}
++-(void)updateAvailibility {
++    if (!ServerManagerInstance.isAvailable) {
++        [LocationManagerInstance stopUpdateLocation];
++        [LocalNotificationsManagerInstance stopUpdate];
++    }
++    else {
++        [self tryStartUpdateLocation];
++    }
++}
++-(void)tryStartUpdateLocation {
++    [LoggerManagerInstance addMessage:[NSString stringWithFormat:@"AppDelegate tryStartUpdateLocation %d",ServerManagerInstance.isAvailable]];
++    if(ServerManagerInstance.isAvailable) {
++        [LocationManagerInstance startUpdateLocation];
++        [LocationManagerInstance setBackground:([[UIApplication sharedApplication] applicationState] == UIApplicationStateBackground)];
++        [LocalNotificationsManagerInstance startUpdate];
++    }
++}
++- (void)applicationWillResignActive:(UIApplication *)application {
++    [LoggerManagerInstance addMessage:@"AppDelegate applicationWillResignActive"];
++}
++
++- (void)applicationDidEnterBackground:(UIApplication *)application {
++    [LoggerManagerInstance addMessage:@"AppDelegate applicationDidEnterBackground"];
++    [LocationManagerInstance setBackground:YES];
++    
++    [[UIApplication sharedApplication] setKeepAliveTimeout:600 handler:^(){
++        [LoggerManagerInstance addMessage:@"AppDelegate setKeepAliveTimeout"];
++    }];
++}
++
++- (void)applicationWillEnterForeground:(UIApplication *)application {
++    [LoggerManagerInstance addMessage:@"AppDelegate applicationWillEnterForeground"];
++    [[UIApplication sharedApplication] clearKeepAliveTimeout];
++    [[UIApplication sharedApplication] setApplicationIconBadgeNumber:0];
++    [self tryStartUpdateLocation];
++}
++
++- (void)applicationDidBecomeActive:(UIApplication *)application {
++    [LoggerManagerInstance addMessage:@"AppDelegate applicationDidBecomeActive"];
++    [self tryStartUpdateLocation];
++}
++
++- (void)applicationWillTerminate:(UIApplication *)application {
++    [LoggerManagerInstance addMessage:@"AppDelegate applicationWillTerminate"];
++    
++    if(ServerManagerInstance.isAvailable) {
++        [LocationManagerInstance appTerminated];
++    }
++}
++
++@end
+diff --git a/BGModesTest/Assets.xcassets/AppIcon.appiconset/Contents.json b/BGModesTest/Assets.xcassets/AppIcon.appiconset/Contents.json
+new file mode 100644
+index 0000000..36d2c80
+--- /dev/null
++++ b/BGModesTest/Assets.xcassets/AppIcon.appiconset/Contents.json
+@@ -0,0 +1,68 @@
++{
++  "images" : [
++    {
++      "idiom" : "iphone",
++      "size" : "29x29",
++      "scale" : "2x"
++    },
++    {
++      "idiom" : "iphone",
++      "size" : "29x29",
++      "scale" : "3x"
++    },
++    {
++      "idiom" : "iphone",
++      "size" : "40x40",
++      "scale" : "2x"
++    },
++    {
++      "idiom" : "iphone",
++      "size" : "40x40",
++      "scale" : "3x"
++    },
++    {
++      "idiom" : "iphone",
++      "size" : "60x60",
++      "scale" : "2x"
++    },
++    {
++      "idiom" : "iphone",
++      "size" : "60x60",
++      "scale" : "3x"
++    },
++    {
++      "idiom" : "ipad",
++      "size" : "29x29",
++      "scale" : "1x"
++    },
++    {
++      "idiom" : "ipad",
++      "size" : "29x29",
++      "scale" : "2x"
++    },
++    {
++      "idiom" : "ipad",
++      "size" : "40x40",
++      "scale" : "1x"
++    },
++    {
++      "idiom" : "ipad",
++      "size" : "40x40",
++      "scale" : "2x"
++    },
++    {
++      "idiom" : "ipad",
++      "size" : "76x76",
++      "scale" : "1x"
++    },
++    {
++      "idiom" : "ipad",
++      "size" : "76x76",
++      "scale" : "2x"
++    }
++  ],
++  "info" : {
++    "version" : 1,
++    "author" : "xcode"
++  }
++}
+\ No newline at end of file
+diff --git a/BGModesTest/Base.lproj/LaunchScreen.storyboard b/BGModesTest/Base.lproj/LaunchScreen.storyboard
+new file mode 100644
+index 0000000..2e721e1
+--- /dev/null
++++ b/BGModesTest/Base.lproj/LaunchScreen.storyboard
+@@ -0,0 +1,27 @@
++<?xml version="1.0" encoding="UTF-8" standalone="no"?>
++<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="8150" systemVersion="15A204g" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" initialViewController="01J-lp-oVM">
++    <dependencies>
++        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="8122"/>
++    </dependencies>
++    <scenes>
++        <!--View Controller-->
++        <scene sceneID="EHf-IW-A2E">
++            <objects>
++                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
++                    <layoutGuides>
++                        <viewControllerLayoutGuide type="top" id="Llm-lL-Icb"/>
++                        <viewControllerLayoutGuide type="bottom" id="xb3-aO-Qok"/>
++                    </layoutGuides>
++                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
++                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
++                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
++                        <animations/>
++                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
++                    </view>
++                </viewController>
++                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
++            </objects>
++            <point key="canvasLocation" x="53" y="375"/>
++        </scene>
++    </scenes>
++</document>
+diff --git a/BGModesTest/Base.lproj/Main.storyboard b/BGModesTest/Base.lproj/Main.storyboard
+new file mode 100644
+index 0000000..28acba1
+--- /dev/null
++++ b/BGModesTest/Base.lproj/Main.storyboard
+@@ -0,0 +1,95 @@
++<?xml version="1.0" encoding="UTF-8" standalone="no"?>
++<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="9060" systemVersion="15B42" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" initialViewController="BYZ-38-t0r">
++    <dependencies>
++        <deployment identifier="iOS"/>
++        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="9051"/>
++    </dependencies>
++    <scenes>
++        <!--View Controller-->
++        <scene sceneID="tne-QT-ifu">
++            <objects>
++                <viewController id="BYZ-38-t0r" customClass="ViewController" sceneMemberID="viewController">
++                    <layoutGuides>
++                        <viewControllerLayoutGuide type="top" id="y3c-jy-aDJ"/>
++                        <viewControllerLayoutGuide type="bottom" id="wfy-db-euE"/>
++                    </layoutGuides>
++                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
++                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
++                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
++                        <subviews>
++                            <view contentMode="scaleToFill" translatesAutoresizingMaskIntoConstraints="NO" id="97h-Yv-rYz">
++                                <rect key="frame" x="180" y="236" width="240" height="128"/>
++                                <subviews>
++                                    <button opaque="NO" contentMode="scaleToFill" contentHorizontalAlignment="center" contentVerticalAlignment="center" buttonType="roundedRect" lineBreakMode="middleTruncation" translatesAutoresizingMaskIntoConstraints="NO" id="vet-TH-GoM">
++                                        <rect key="frame" x="85" y="48" width="71" height="30"/>
++                                        <animations/>
++                                        <constraints>
++                                            <constraint firstAttribute="height" constant="30" id="FwB-lJ-Rox"/>
++                                            <constraint firstAttribute="width" constant="71" id="Srs-uy-hpw"/>
++                                        </constraints>
++                                        <state key="normal" title="Show logs"/>
++                                        <connections>
++                                            <action selector="showLogsButtonClicked:" destination="BYZ-38-t0r" eventType="touchUpInside" id="EYd-dI-H1U"/>
++                                        </connections>
++                                    </button>
++                                    <button opaque="NO" contentMode="scaleToFill" contentHorizontalAlignment="center" contentVerticalAlignment="center" buttonType="roundedRect" lineBreakMode="middleTruncation" translatesAutoresizingMaskIntoConstraints="NO" id="p1m-aI-jaX">
++                                        <rect key="frame" x="87" y="86" width="68" height="30"/>
++                                        <animations/>
++                                        <constraints>
++                                            <constraint firstAttribute="width" constant="68" id="MVy-dj-WOG"/>
++                                            <constraint firstAttribute="height" constant="30" id="eHh-mk-qCK"/>
++                                        </constraints>
++                                        <state key="normal" title="Send logs"/>
++                                        <connections>
++                                            <action selector="sendLogsButtonClicked:" destination="BYZ-38-t0r" eventType="touchUpInside" id="c7i-Hg-XNb"/>
++                                        </connections>
++                                    </button>
++                                    <segmentedControl opaque="NO" contentMode="scaleToFill" contentHorizontalAlignment="left" contentVerticalAlignment="top" segmentControlStyle="plain" selectedSegmentIndex="0" translatesAutoresizingMaskIntoConstraints="NO" id="5A0-a3-e4b">
++                                        <rect key="frame" x="52" y="12" width="137" height="29"/>
++                                        <animations/>
++                                        <constraints>
++                                            <constraint firstAttribute="height" constant="28" id="MRR-Et-61W"/>
++                                            <constraint firstAttribute="width" constant="137" id="mcb-bY-ksR"/>
++                                        </constraints>
++                                        <segments>
++                                            <segment title="Available"/>
++                                            <segment title="NA"/>
++                                        </segments>
++                                        <connections>
++                                            <action selector="availabilitySegmanetControlValueChanged:" destination="BYZ-38-t0r" eventType="valueChanged" id="dS2-HJ-GQX"/>
++                                        </connections>
++                                    </segmentedControl>
++                                </subviews>
++                                <animations/>
++                                <color key="backgroundColor" white="1" alpha="1" colorSpace="calibratedWhite"/>
++                                <constraints>
++                                    <constraint firstAttribute="height" constant="128" id="6H1-IC-72E"/>
++                                    <constraint firstAttribute="width" constant="240" id="6WK-tG-bLw"/>
++                                    <constraint firstItem="p1m-aI-jaX" firstAttribute="leading" secondItem="97h-Yv-rYz" secondAttribute="leading" constant="87" id="6eo-tr-oxe"/>
++                                    <constraint firstAttribute="trailing" secondItem="5A0-a3-e4b" secondAttribute="trailing" constant="51" id="8SZ-AQ-apY"/>
++                                    <constraint firstItem="vet-TH-GoM" firstAttribute="top" secondItem="5A0-a3-e4b" secondAttribute="bottom" constant="8" id="KWH-sn-TFJ"/>
++                                    <constraint firstItem="5A0-a3-e4b" firstAttribute="top" secondItem="97h-Yv-rYz" secondAttribute="top" constant="12" id="Z4g-4S-nVz"/>
++                                    <constraint firstItem="vet-TH-GoM" firstAttribute="leading" secondItem="97h-Yv-rYz" secondAttribute="leading" constant="85" id="a4n-lm-74K"/>
++                                    <constraint firstAttribute="trailing" secondItem="p1m-aI-jaX" secondAttribute="trailing" constant="85" id="c5J-cF-EEM"/>
++                                    <constraint firstItem="p1m-aI-jaX" firstAttribute="top" secondItem="vet-TH-GoM" secondAttribute="bottom" constant="8" id="hG7-gt-l3P"/>
++                                    <constraint firstAttribute="trailing" secondItem="vet-TH-GoM" secondAttribute="trailing" constant="84" id="sgY-LS-FfE"/>
++                                    <constraint firstItem="5A0-a3-e4b" firstAttribute="leading" secondItem="97h-Yv-rYz" secondAttribute="leading" constant="52" id="t41-W4-dqZ"/>
++                                </constraints>
++                            </view>
++                        </subviews>
++                        <animations/>
++                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
++                        <constraints>
++                            <constraint firstItem="97h-Yv-rYz" firstAttribute="centerX" secondItem="8bC-Xf-vdC" secondAttribute="centerX" id="BOj-UW-hHx"/>
++                            <constraint firstItem="97h-Yv-rYz" firstAttribute="centerY" secondItem="8bC-Xf-vdC" secondAttribute="centerY" id="YGj-1Y-0X6"/>
++                        </constraints>
++                    </view>
++                    <connections>
++                        <outlet property="availabilitySegmentControl" destination="5A0-a3-e4b" id="CLG-ow-Dg0"/>
++                    </connections>
++                </viewController>
++                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
++            </objects>
++        </scene>
++    </scenes>
++</document>
+diff --git a/BGModesTest/Info.plist b/BGModesTest/Info.plist
+new file mode 100644
+index 0000000..ffb464b
+--- /dev/null
++++ b/BGModesTest/Info.plist
+@@ -0,0 +1,54 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
++<plist version="1.0">
++<dict>
++	<key>CFBundleDevelopmentRegion</key>
++	<string>en</string>
++	<key>CFBundleExecutable</key>
++	<string>$(EXECUTABLE_NAME)</string>
++	<key>CFBundleIdentifier</key>
++	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
++	<key>CFBundleInfoDictionaryVersion</key>
++	<string>6.0</string>
++	<key>CFBundleName</key>
++	<string>$(PRODUCT_NAME)</string>
++	<key>CFBundlePackageType</key>
++	<string>APPL</string>
++	<key>CFBundleShortVersionString</key>
++	<string>1.0.0</string>
++	<key>CFBundleSignature</key>
++	<string>????</string>
++	<key>CFBundleVersion</key>
++	<string>1.0.0.1</string>
++	<key>LSRequiresIPhoneOS</key>
++	<true/>
++	<key>NSLocationAlwaysUsageDescription</key>
++	<string></string>
++	<key>UIBackgroundModes</key>
++	<array>
++		<string>location</string>
++		<string>voip</string>
++	</array>
++	<key>UILaunchStoryboardName</key>
++	<string>LaunchScreen</string>
++	<key>UIMainStoryboardFile</key>
++	<string>Main</string>
++	<key>UIRequiredDeviceCapabilities</key>
++	<array>
++		<string>armv7</string>
++	</array>
++	<key>UISupportedInterfaceOrientations</key>
++	<array>
++		<string>UIInterfaceOrientationPortrait</string>
++		<string>UIInterfaceOrientationLandscapeLeft</string>
++		<string>UIInterfaceOrientationLandscapeRight</string>
++	</array>
++	<key>UISupportedInterfaceOrientations~ipad</key>
++	<array>
++		<string>UIInterfaceOrientationPortrait</string>
++		<string>UIInterfaceOrientationPortraitUpsideDown</string>
++		<string>UIInterfaceOrientationLandscapeLeft</string>
++		<string>UIInterfaceOrientationLandscapeRight</string>
++	</array>
++</dict>
++</plist>
+diff --git a/BGModesTest/Managers/BackgroundTaskManager/BackgroundTaskManager.h b/BGModesTest/Managers/BackgroundTaskManager/BackgroundTaskManager.h
+new file mode 100755
+index 0000000..fa1b5ee
+--- /dev/null
++++ b/BGModesTest/Managers/BackgroundTaskManager/BackgroundTaskManager.h
+@@ -0,0 +1,17 @@
++//
++//  BackgroundTaskManager.h
++//
++//  Created by Puru Shukla on 20/02/13.
++//  Copyright (c) 2013 Puru Shukla. All rights reserved.
++//
++
++#import <UIKit/UIKit.h>
++
++@interface BackgroundTaskManager : NSObject
++
+++(instancetype)sharedBackgroundTaskManager;
++
++-(UIBackgroundTaskIdentifier)beginNewBackgroundTask;
++-(void)endAllBackgroundTasks;
++
++@end
+diff --git a/BGModesTest/Managers/BackgroundTaskManager/BackgroundTaskManager.m b/BGModesTest/Managers/BackgroundTaskManager/BackgroundTaskManager.m
+new file mode 100755
+index 0000000..e95086a
+--- /dev/null
++++ b/BGModesTest/Managers/BackgroundTaskManager/BackgroundTaskManager.m
+@@ -0,0 +1,104 @@
++//
++//  BackgroundTaskManager.m
++//
++//  Created by Puru Shukla on 20/02/13.
++//  Copyright (c) 2013 Puru Shukla. All rights reserved.
++//
++
++#import "BackgroundTaskManager.h"
++
++@interface BackgroundTaskManager()
++@property (nonatomic, strong)NSMutableArray* bgTaskIdList;
++@property (assign) UIBackgroundTaskIdentifier masterTaskId;
++@end
++
++@implementation BackgroundTaskManager
++
+++(instancetype)sharedBackgroundTaskManager{
++    static BackgroundTaskManager* sharedBGTaskManager;
++    static dispatch_once_t onceToken;
++    dispatch_once(&onceToken, ^{
++        sharedBGTaskManager = [[BackgroundTaskManager alloc] init];
++    });
++    
++    return sharedBGTaskManager;
++}
++
++-(id)init{
++    self = [super init];
++    if(self){
++        _bgTaskIdList = [NSMutableArray array];
++        _masterTaskId = UIBackgroundTaskInvalid;
++    }
++    
++    return self;
++}
++
++-(UIBackgroundTaskIdentifier)beginNewBackgroundTask
++{
++    UIApplication* application = [UIApplication sharedApplication];
++    
++    UIBackgroundTaskIdentifier bgTaskId = UIBackgroundTaskInvalid;
++    if([application respondsToSelector:@selector(beginBackgroundTaskWithExpirationHandler:)]){
++        bgTaskId = [application beginBackgroundTaskWithExpirationHandler:^{
++           // NSLog(@"background task %lu expired", (unsigned long)bgTaskId);
++        }];
++        if ( self.masterTaskId == UIBackgroundTaskInvalid )
++        {
++            self.masterTaskId = bgTaskId;
++           // NSLog(@"started master task %lu", (unsigned long)self.masterTaskId);
++        }
++        else
++        {
++            //add this id to our list
++            //NSLog(@"started background task %lu", (unsigned long)bgTaskId);
++            [self.bgTaskIdList addObject:@(bgTaskId)];
++            [self endBackgroundTasks];
++        }
++    }
++    
++    return bgTaskId;
++}
++
++-(void)endBackgroundTasks
++{
++    [self drainBGTaskList:NO];
++}
++
++-(void)endAllBackgroundTasks
++{
++    [self drainBGTaskList:YES];
++}
++
++-(void)drainBGTaskList:(BOOL)all
++{
++    //mark end of each of our background task
++    UIApplication* application = [UIApplication sharedApplication];
++    if([application respondsToSelector:@selector(endBackgroundTask:)]){
++        NSUInteger count=self.bgTaskIdList.count;
++        for ( NSUInteger i=(all?0:1); i<count; i++ )
++        {
++            UIBackgroundTaskIdentifier bgTaskId = [[self.bgTaskIdList objectAtIndex:0] integerValue];
++            //NSLog(@"ending background task with id -%lu", (unsigned long)bgTaskId);
++            [application endBackgroundTask:bgTaskId];
++            [self.bgTaskIdList removeObjectAtIndex:0];
++        }
++        if ( self.bgTaskIdList.count > 0 )
++        {
++            //NSLog(@"kept background task id %@", [self.bgTaskIdList objectAtIndex:0]);
++        }
++        if ( all )
++        {
++            //NSLog(@"no more background tasks running");
++            [application endBackgroundTask:self.masterTaskId];
++            self.masterTaskId = UIBackgroundTaskInvalid;
++        }
++        else
++        {
++            //NSLog(@"kept master background task id %lu", (unsigned long)self.masterTaskId);
++        }
++    }
++}
++
++
++@end
+diff --git a/BGModesTest/Managers/LocalNotificationsManager/LocalNotificationsManager.h b/BGModesTest/Managers/LocalNotificationsManager/LocalNotificationsManager.h
+new file mode 100644
+index 0000000..6d8da51
+--- /dev/null
++++ b/BGModesTest/Managers/LocalNotificationsManager/LocalNotificationsManager.h
+@@ -0,0 +1,20 @@
++//
++//  LocalNotificationsManager.h
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 19.11.15.
++//  Copyright © 2015 Lifewaresolutions. All rights reserved.
++//
++
++#import <UIKit/UIKit.h>
++
++#define LocalNotificationsManagerInstance [LocalNotificationsManager instance]
++@interface LocalNotificationsManager : NSObject
++-(void)startUpdate;
++-(void)stopUpdate;
++
++#pragma mark - init
++
+++(instancetype)instance;
++
++@end
+diff --git a/BGModesTest/Managers/LocalNotificationsManager/LocalNotificationsManager.m b/BGModesTest/Managers/LocalNotificationsManager/LocalNotificationsManager.m
+new file mode 100644
+index 0000000..2880bba
+--- /dev/null
++++ b/BGModesTest/Managers/LocalNotificationsManager/LocalNotificationsManager.m
+@@ -0,0 +1,112 @@
++//
++//  LocalNotificationsManager.m
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 19.11.15.
++//  Copyright © 2015 Lifewaresolutions. All rights reserved.
++//
++
++#import "LocalNotificationsManager.h"
++#import "BackgroundTaskManager.h"
++#import "LoggerManager.h"
++
++//#define TIMER_LocalNotificationsManager_INTERVAL 5.0
++//#define LOCALNOTIFICATION_FIRE_DELAY 20.0
++//#define LOCALNOTIFICATION_FIRE_OFFSET 11.0
++#define TIMER_LocalNotificationsManager_INTERVAL 180.0
++#define LOCALNOTIFICATION_FIRE_DELAY 600.0
++#define LOCALNOTIFICATION_FIRE_OFFSET 242.0
++
++@interface LocalNotificationsManager () {
++    NSTimer* timer;
++}
++@property (nonatomic) BackgroundTaskManager * bgTask;
++
++@end
++@implementation LocalNotificationsManager
++-(void)startUpdate {
++    [LoggerManagerInstance addMessage:@"LocalNotificationsManager startUpdate"];
++    [self setTimer];
++}
++-(void)stopUpdate {
++    [LoggerManagerInstance addMessage:@"LocalNotificationsManager stopUpdate"];
++    [self removeTimer];
++}
++
++
++-(void)timerFired {
++    [LoggerManagerInstance addMessage:@"LocalNotificationsManager timerFired"];
++    
++    UILocalNotification* existLocalNotification = self.getExistLocalNotification;
++    [LoggerManagerInstance addMessage:[NSString stringWithFormat:@"LocalNotificationsManager timerFired existLocalNotification:%@",existLocalNotification]];
++    if (!existLocalNotification) {
++        [[UIApplication sharedApplication] scheduleLocalNotification:self.getNewLocalNotification];
++    }
++    else if ([existLocalNotification.fireDate timeIntervalSinceNow] <= LOCALNOTIFICATION_FIRE_OFFSET) {
++        [[UIApplication sharedApplication] cancelLocalNotification:existLocalNotification];
++        [[UIApplication sharedApplication] scheduleLocalNotification:self.getNewLocalNotification];
++    }
++}
++-(void)setTimer {
++    if (!timer) {
++        [LoggerManagerInstance addMessage:[NSString stringWithFormat:@"LocalNotificationsManager setTimer timerInterval-%f",TIMER_LocalNotificationsManager_INTERVAL]];
++        
++        self.bgTask = [BackgroundTaskManager sharedBackgroundTaskManager];
++        [self.bgTask beginNewBackgroundTask];
++        timer = [NSTimer timerWithTimeInterval:TIMER_LocalNotificationsManager_INTERVAL target:self selector:@selector(timerFired) userInfo:nil repeats:YES];
++        [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
++        [timer fire];
++    }
++}
++-(void)removeTimer {
++    if (timer) {
++        [self.bgTask endAllBackgroundTasks];
++        [timer invalidate];
++        timer = nil;
++        [[UIApplication sharedApplication] cancelAllLocalNotifications];
++    }
++}
++
++#pragma mark - init
++
+++(instancetype)instance{
++    static LocalNotificationsManager *instance;
++    
++    @synchronized(self) {
++        if(!instance) {
++            instance = [[LocalNotificationsManager alloc] init];
++        }
++    }
++    
++    return instance;
++}
++
++-(UILocalNotification*)getExistLocalNotification {
++    NSArray<UILocalNotification *> *scheduledLocalNotifications = [[UIApplication sharedApplication] scheduledLocalNotifications];
++    for (UILocalNotification* item in scheduledLocalNotifications) {
++        if (item.userInfo) {
++            NSString* identifier = [item.userInfo objectForKey:@"identifier"];
++            if (identifier && [identifier isKindOfClass:[NSString class]]) {
++                if ([identifier isEqualToString:@"LocalNotificationsManager"]) {
++                    return item;
++                }
++            }
++        }
++    }
++    return nil;
++}
++-(UILocalNotification*)getNewLocalNotification {
++    [LoggerManagerInstance addMessage:@"LocalNotificationsManager createNotification"];
++    UILocalNotification *myNotification = [[UILocalNotification alloc] init];
++    myNotification.alertBody = @"Maestro should remain running. Please open app.";
++    myNotification.alertAction = @"Open";
++    myNotification.soundName = UILocalNotificationDefaultSoundName;
++    myNotification.applicationIconBadgeNumber = 1;
++    myNotification.timeZone = [NSTimeZone defaultTimeZone];
++    myNotification.repeatInterval = NSMinuteCalendarUnit;
++    myNotification.fireDate = [[NSDate date] dateByAddingTimeInterval:LOCALNOTIFICATION_FIRE_DELAY];
++    myNotification.userInfo = @{@"identifier":@"LocalNotificationsManager"};
++    return myNotification;
++    
++}
++@end
+diff --git a/BGModesTest/Managers/LocationManager/LocationManager.h b/BGModesTest/Managers/LocationManager/LocationManager.h
+new file mode 100644
+index 0000000..66bfc5d
+--- /dev/null
++++ b/BGModesTest/Managers/LocationManager/LocationManager.h
+@@ -0,0 +1,29 @@
++//
++//  RecordingTrack.h
++//  Track Kit - Augmented Reality, Measurements and GPS Tracking
++//
++//  Created by Artem Drozd on 03.09.13.
++//  Copyright (c) 2013 Lifewaresolutions. All rights reserved.
++//
++
++#import <UIKit/UIKit.h>
++#import <CoreLocation/CoreLocation.h>
++#define LocationManagerInstance [LocationManager instance]
++#define kLocationManagerLocationChanged @"kLocationManagerLocationChanged"
++@interface LocationManager : NSObject
++@property (nonatomic,assign)BOOL background;
++@property (nonatomic,assign)BOOL startFromSagnificantLocation;
++
++-(void)restartLocationUpdates;
++-(void)startUpdateLocation;
++-(void)stopUpdateLocation;
++
++- (void)appTerminated;
++
++-(CLLocation*)userLocaton;
++
++#pragma mark - init
++
+++(instancetype)instance;
++
++@end
+\ No newline at end of file
+diff --git a/BGModesTest/Managers/LocationManager/LocationManager.m b/BGModesTest/Managers/LocationManager/LocationManager.m
+new file mode 100644
+index 0000000..1def0ca
+--- /dev/null
++++ b/BGModesTest/Managers/LocationManager/LocationManager.m
+@@ -0,0 +1,245 @@
++//
++//  RecordingTrack.m
++//  Track Kit - Augmented Reality, Measurements and GPS Tracking
++//
++//  Created by Artem Drozd on 03.09.13.
++//  Copyright (c) 2013 Lifewaresolutions. All rights reserved.
++//
++
++#import "LocationManager.h"
++#import "LoggerManager.h"
++#import "BackgroundTaskManager.h"
++
++@interface LocationManager()<CLLocationManagerDelegate>{
++    CLLocationManager*locationManager;
++    
++    UIAlertView *alertView;
++    
++    CLLocation* userLocaton;
++}
++@property (nonatomic) BackgroundTaskManager * bgTask;
++
++@end
++
++@implementation LocationManager
++
++#pragma mark - init
++
+++(instancetype)instance{
++    static LocationManager *instance;
++    
++    @synchronized(self) {
++        if(!instance) {
++            instance = [[LocationManager alloc] init];
++        }
++    }
++    
++    return instance;
++}
++-(void)dealloc {
++    [NSObject cancelPreviousPerformRequestsWithTarget:self];
++}
++-(id)init{
++    self=[super init];
++    if(self){
++    }
++    return self;
++}
++
++#pragma mark -
++
++-(CLLocation*)userLocaton {
++    return userLocaton;
++}
++- (void)requestAlwaysAuthorization
++{
++    CLAuthorizationStatus status = [CLLocationManager authorizationStatus];
++    
++    if ([locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) {
++        // If the status is denied or only granted for when in use, display an alert
++        if (status == kCLAuthorizationStatusAuthorizedWhenInUse || status == kCLAuthorizationStatusDenied) {
++            if (!alertView) {
++                NSString *title;
++                title = (status == kCLAuthorizationStatusDenied) ? NSLocalizedString(@"Location services are off",nil) : NSLocalizedString(@"Background location is not enabled",nil);
++                NSString *message = NSLocalizedString(@"To use background location you must turn on 'Always' in the Location Services Settings",nil);
++                
++                alertView = [[UIAlertView alloc] initWithTitle:title
++                                                       message:message
++                                                      delegate:self
++                                             cancelButtonTitle:NSLocalizedString(@"Cancel",nil)
++                                             otherButtonTitles:NSLocalizedString(@"Options",nil), nil];
++                [alertView show];
++            }
++        }
++        // The user has not enabled any location services. Request background authorization.
++        else if (status == kCLAuthorizationStatusNotDetermined) {
++            [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(performRequestAlwaysAuthorization) object:nil];
++            [self performSelector:@selector(performRequestAlwaysAuthorization) withObject:nil afterDelay:1];
++        }
++    }
++    else {
++        // If the status is denied or only granted for when in use, display an alert
++        if (status == kCLAuthorizationStatusDenied) {
++            if (!alertView) {
++                NSString *title;
++                title = NSLocalizedString(@"Location services are off",nil);
++                
++                NSString *message = NSLocalizedString(@"Please turn on Location services for 'Maestro' in the Location Services Settings",nil);
++                
++                alertView = [[UIAlertView alloc] initWithTitle:title
++                                                       message:message
++                                                      delegate:nil
++                                             cancelButtonTitle:@"OK"
++                                             otherButtonTitles:nil];
++                [alertView show];
++            }
++        }
++        // The user has not enabled any location services. Request background authorization.
++        else if (status == kCLAuthorizationStatusNotDetermined) {
++        }
++    }
++}
++-(void)performRequestAlwaysAuthorization {
++    [locationManager requestAlwaysAuthorization];
++}
++
++- (void)alertView:(UIAlertView *)alertViewArg clickedButtonAtIndex:(NSInteger)buttonIndex
++{
++    if (buttonIndex == 1) {
++        // Send the user to the Settings for this app
++        if (&UIApplicationOpenSettingsURLString != NULL) {
++            NSURL *settingsURL = [NSURL URLWithString:UIApplicationOpenSettingsURLString];
++            [[UIApplication sharedApplication] openURL:settingsURL];
++        }
++    }
++    alertView = nil;
++}
++-(void)startPausesLocationUpdatesAutomatically {
++    if ([locationManager respondsToSelector:@selector(pausesLocationUpdatesAutomatically)]) {
++        locationManager.pausesLocationUpdatesAutomatically = YES;
++    }
++}
++-(void)stopPausesLocationUpdatesAutomatically {
++    if ([locationManager respondsToSelector:@selector(pausesLocationUpdatesAutomatically)]) {
++        //if not disable iOS can terminate app in bg
++        locationManager.pausesLocationUpdatesAutomatically = NO;
++    }
++}
++-(void)setBackground:(BOOL)background {
++    self.startFromSagnificantLocation = NO;
++    _background = background;
++    [self checkPausesLocation];
++    [self checkMonitoringSignificantLocation];
++}
++-(void)checkPausesLocation {
++    if (self.background) {
++        [self stopPausesLocationUpdatesAutomatically];
++    }
++    else {
++        [self startPausesLocationUpdatesAutomatically];
++    }
++}
++-(void)checkMonitoringSignificantLocation {
++    if (self.background) {
++        self.bgTask = [BackgroundTaskManager sharedBackgroundTaskManager];
++        [self.bgTask beginNewBackgroundTask];
++    }
++    else {
++        [self.bgTask endAllBackgroundTasks];
++    }
++}
++-(void)startUpdateLocation{
++    @try {
++        if (!locationManager) {
++            [LoggerManagerInstance addMessage:@"LocationManager startUpdateLocation"];
++            locationManager=[CLLocationManager new];
++            locationManager.desiredAccuracy=kCLLocationAccuracyBestForNavigation;
++            locationManager.delegate=self;
++            [self checkPausesLocation];
++            
++            [self requestAlwaysAuthorization];
++            if ([locationManager respondsToSelector:@selector(setAllowsBackgroundLocationUpdates:)]) {
++                [locationManager setAllowsBackgroundLocationUpdates:YES];
++            }
++            
++            [locationManager startUpdatingLocation];
++            [locationManager startMonitoringSignificantLocationChanges];
++            
++            [self removeMonitors];
++        }
++    }
++    @catch (NSException *exception) {
++    }
++}
++-(void)removeMonitors{
++    
++    for(CLRegion *geofence in locationManager.monitoredRegions){
++        [locationManager stopMonitoringForRegion:geofence];
++    }
++}
++-(void)stopUpdateLocation{
++    @try {
++        if (locationManager) {
++            [LoggerManagerInstance addMessage:@"LocationManager stopUpdateLocation"];
++            [self removeMonitors];
++            locationManager.delegate=nil;
++            [locationManager stopUpdatingLocation];
++            [locationManager stopMonitoringSignificantLocationChanges];
++            locationManager = nil;
++        }
++    }
++    @catch (NSException *exception) {
++    }
++}
++
++- (void)restartLocationUpdates{
++    [LoggerManagerInstance addMessage:@"LocationManager restartLocationUpdates"];
++    if (locationManager) {
++        [self stopUpdateLocation];
++    }
++    
++    [self startUpdateLocation];
++}
++
++- (void)appTerminated {
++    [LoggerManagerInstance addMessage:@"LocationManager appTerminated"];
++
++    if (userLocaton) {
++        CLCircularRegion* region = [[CLCircularRegion alloc] initWithCenter:userLocaton.coordinate radius:5 identifier:@"wakeupinbg"];
++        region.notifyOnEntry = YES;
++        region.notifyOnExit = YES;
++        [locationManager startMonitoringForRegion:region];
++    }
++}
++- (void)locationManager:(CLLocationManager *)manager
++         didEnterRegion:(CLRegion *)region  {
++    [LoggerManagerInstance addMessage:[NSString stringWithFormat:@"locationManager didEnterRegion: %@",region]];
++}
++
++- (void)locationManager:(CLLocationManager *)manager
++          didExitRegion:(CLRegion *)region {
++    [LoggerManagerInstance addMessage:[NSString stringWithFormat:@"locationManager didExitRegion: %@",region]];
++}
++
++-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations{
++    @try {
++        CLLocation* oldLocation = userLocaton;
++        userLocaton=[locations lastObject];
++        if (!oldLocation || fabs([oldLocation distanceFromLocation:userLocaton]) > 70) {
++            [LoggerManagerInstance addMessage:[NSString stringWithFormat:@"locationManager didUpdateLocations: %@",userLocaton]];
++        }
++        [[NSNotificationCenter defaultCenter] postNotificationName:kLocationManagerLocationChanged object:nil];
++    }
++    @catch (NSException *exception) {
++    }
++}
++
++-(void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error{
++    @try {
++        [LoggerManagerInstance addMessage:[NSString stringWithFormat:@"locationManager didFailWithError: %@",error]];
++    }
++    @catch (NSException *exception) {
++    }
++}
++
++@end
+\ No newline at end of file
+diff --git a/BGModesTest/Managers/LoggerManager/CustomLoggerFormatter/CustomLoggerFormatter.h b/BGModesTest/Managers/LoggerManager/CustomLoggerFormatter/CustomLoggerFormatter.h
+new file mode 100644
+index 0000000..200e61f
+--- /dev/null
++++ b/BGModesTest/Managers/LoggerManager/CustomLoggerFormatter/CustomLoggerFormatter.h
+@@ -0,0 +1,14 @@
++//
++//  CustomLoggerFormatter.h
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 9/24/15.
++//  Copyright © 2015 Lifewaresolutions. All rights reserved.
++//
++
++#import <Foundation/Foundation.h>
++#import <CocoaLumberjack/CocoaLumberjack.h>
++
++@interface CustomLoggerFormatter : NSObject <DDLogFormatter>
++
++@end
+diff --git a/BGModesTest/Managers/LoggerManager/CustomLoggerFormatter/CustomLoggerFormatter.m b/BGModesTest/Managers/LoggerManager/CustomLoggerFormatter/CustomLoggerFormatter.m
+new file mode 100644
+index 0000000..f869f6e
+--- /dev/null
++++ b/BGModesTest/Managers/LoggerManager/CustomLoggerFormatter/CustomLoggerFormatter.m
+@@ -0,0 +1,33 @@
++//
++//  CustomLoggerFormatter.m
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 9/24/15.
++//  Copyright © 2015 Lifewaresolutions. All rights reserved.
++//
++
++#import "CustomLoggerFormatter.h"
++
++@interface CustomLoggerFormatter () {
++    NSDateFormatter *dateFormatter;
++}
++
++@end
++@implementation CustomLoggerFormatter
++- (id)init {
++    if((self = [super init])) {
++        dateFormatter = [[NSDateFormatter alloc] init];
++        [dateFormatter setTimeZone:[NSTimeZone timeZoneWithAbbreviation:@"UTC"]];
++        [dateFormatter setLocale:[NSLocale localeWithLocaleIdentifier:@"en_US"]];
++        [dateFormatter setDateFormat:@"yyyy/MM/dd HH:mm:ss:SSS Z"];
++    }
++    return self;
++}
++
++- (NSString *)formatLogMessage:(DDLogMessage *)logMessage {
++    NSString *dateAndTime = [dateFormatter stringFromDate:(logMessage->_timestamp)];
++    NSString *logMsg = logMessage->_message;
++    
++    return [NSString stringWithFormat:@"%@ | %@\n", dateAndTime, logMsg];
++}
++@end
+diff --git a/BGModesTest/Managers/LoggerManager/LoggerManager.h b/BGModesTest/Managers/LoggerManager/LoggerManager.h
+new file mode 100644
+index 0000000..e97187f
+--- /dev/null
++++ b/BGModesTest/Managers/LoggerManager/LoggerManager.h
+@@ -0,0 +1,22 @@
++//
++//  LoggerManager.h
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 9/24/15.
++//  Copyright © 2015 Lifewaresolutions. All rights reserved.
++//
++
++#import <Foundation/Foundation.h>
++
++#define LoggerManagerInstance [LoggerManager instance]
++
++@interface LoggerManager : NSObject
++
+++(instancetype)instance;
++
++-(void)sendLogByMail;
++-(void)showLogs;
++
++-(void)addMessage:(NSString*)messageArg;
++
++@end
+diff --git a/BGModesTest/Managers/LoggerManager/LoggerManager.m b/BGModesTest/Managers/LoggerManager/LoggerManager.m
+new file mode 100644
+index 0000000..31c815a
+--- /dev/null
++++ b/BGModesTest/Managers/LoggerManager/LoggerManager.m
+@@ -0,0 +1,147 @@
++//
++//  LoggerManager.m
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 9/24/15.
++//  Copyright © 2015 Lifewaresolutions. All rights reserved.
++//
++
++#import "LoggerManager.h"
++#import <CocoaLumberjack/CocoaLumberjack.h>
++#import <MessageUI/MFMailComposeViewController.h>
++#import "CustomLoggerFormatter.h"
++#import "LogsViewController.h"
++#import <sys/utsname.h>
++
++
++static const DDLogLevel ddLogLevel = DDLogLevelVerbose;
++
++@interface LoggerManager () <MFMailComposeViewControllerDelegate,LogsViewControllerDelegate> {
++    DDFileLogger *fileLogger;
++    LogsViewController* logsViewController;
++}
++
++@end
++@implementation LoggerManager
++
++#pragma mark - LogsViewController
++-(void)logsViewControllerDone {
++    logsViewController = nil;
++}
++-(void)showLogs {
++    if (!logsViewController) {
++        logsViewController = [[LogsViewController alloc] initWithNibName:@"LogsViewController" bundle:[NSBundle mainBundle]];
++        logsViewController.delegate = self;
++        UIWindow *window = [[UIApplication sharedApplication] windows][0];
++        UIViewController*viewController=window.rootViewController;
++        [viewController presentViewController:logsViewController animated:YES completion:^{}];
++        
++        NSMutableData *errorLogData = [NSMutableData data];
++        for (NSData *errorLogFileData in [self errorLogData]) {
++            [errorLogData appendData:errorLogFileData];
++        }
++        NSString* errorLogString = [[NSString alloc] initWithData:errorLogData encoding:NSUTF8StringEncoding];
++        [logsViewController addNewString:errorLogString];
++    }
++}
++
++#pragma mark - email
++- (NSMutableArray *)errorLogData
++{
++    NSUInteger maximumLogFilesToReturn = MIN(fileLogger.logFileManager.maximumNumberOfLogFiles, 10);
++    NSMutableArray *errorLogFiles = [NSMutableArray arrayWithCapacity:maximumLogFilesToReturn];
++    NSArray *sortedLogFileInfos = [fileLogger.logFileManager sortedLogFileInfos];
++    for (int i = 0; i < MIN(sortedLogFileInfos.count, maximumLogFilesToReturn); i++) {
++        DDLogFileInfo *logFileInfo = [sortedLogFileInfos objectAtIndex:i];
++        NSData *fileData = [NSData dataWithContentsOfFile:logFileInfo.filePath];
++        [errorLogFiles addObject:fileData];
++    }
++    return errorLogFiles;
++}
++
++- (void)composeEmailWithDebugAttachment
++{
++    if ([MFMailComposeViewController canSendMail]) {
++        
++        MFMailComposeViewController *mailViewController = [[MFMailComposeViewController alloc] init];
++        mailViewController.mailComposeDelegate = self;
++        NSMutableData *errorLogData = [NSMutableData data];
++        for (NSData *errorLogFileData in [self errorLogData]) {
++            [errorLogData appendData:errorLogFileData];
++        }
++        [mailViewController addAttachmentData:errorLogData mimeType:@"text/plain" fileName:[NSString stringWithFormat:@"log%ld.txt",(long)[[NSDate date] timeIntervalSince1970]]];
++        [mailViewController setSubject:NSLocalizedString(@"logs", @"")];
++        
++        UIWindow *window = [[UIApplication sharedApplication] windows][0];
++        UIViewController*viewController=window.rootViewController;
++        [viewController presentViewController:mailViewController animated:YES completion:^{}];
++    }
++    
++    else {
++        NSString *message = NSLocalizedString(@"Sorry, your issue can't be reported right now. This is most likely because no mail accounts are set up on your mobile device.", @"");
++        [[[UIAlertView alloc] initWithTitle:nil message:message delegate:nil cancelButtonTitle:NSLocalizedString(@"OK", @"") otherButtonTitles: nil] show];
++    }
++}
++
++- (void)mailComposeController:(MFMailComposeViewController*)controller didFinishWithResult:(MFMailComposeResult)result error:(NSError*)error
++{
++    [controller dismissViewControllerAnimated:YES completion:nil];
++}
++#pragma mark - interaction
++-(void)sendLogByMail {
++    [self composeEmailWithDebugAttachment];
++}
++
++-(void)addMessage:(NSString*)messageArg {
++    DDLogVerbose(@"%@", messageArg);
++    if (logsViewController) {
++        [logsViewController addNewString:[@"\n" stringByAppendingString:messageArg]];
++    }
++}
++
++-(void)initLogger {
++    [DDLog addLogger:[DDASLLogger sharedInstance]];
++    [DDLog addLogger:[DDTTYLogger sharedInstance]];
++    
++    fileLogger = [[DDFileLogger alloc] init];
++    fileLogger.logFormatter = [[CustomLoggerFormatter alloc] init];
++    fileLogger.rollingFrequency = 0;
++    fileLogger.maximumFileSize = (1024 * 1024 * 15);
++    fileLogger.logFileManager.maximumNumberOfLogFiles = 1;
++    [DDLog addLogger:fileLogger];
++    
++    struct utsname systemInfo;
++    uname(&systemInfo);
++    [self addMessage:[NSString stringWithFormat:@"initLogger %@ %@%@(%@)",
++                      [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding],
++                      [[[NSBundle mainBundle] localizedInfoDictionary] objectForKey:@"CFBundleDisplayName"],
++                      [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"],
++                      [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleVersion"]]];
++}
++#pragma mark - init
++
+++(instancetype)instance{
++    static LoggerManager *instance;
++    
++    @synchronized(self) {
++        if(!instance) {
++            instance = [[LoggerManager alloc] init];
++        }
++    }
++    
++    return instance;
++}
++-(void)dealloc {
++    [NSObject cancelPreviousPerformRequestsWithTarget:self];
++    [[NSNotificationCenter defaultCenter] removeObserver:self];
++}
++
++-(id)init{
++    self=[super init];
++    if(self){
++        [self initLogger];
++    }
++    return self;
++}
++
++@end
+diff --git a/BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.h b/BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.h
+new file mode 100644
+index 0000000..a94c2ed
+--- /dev/null
++++ b/BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.h
+@@ -0,0 +1,20 @@
++//
++//  LogsViewController.h
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 9/28/15.
++//  Copyright © 2015 Lifewaresolutions. All rights reserved.
++//
++
++#import <UIKit/UIKit.h> 
++
++@protocol LogsViewControllerDelegate <NSObject>
++
++-(void)logsViewControllerDone;
++
++@end
++
++@interface LogsViewController : UIViewController
++@property (nonatomic,weak)id<LogsViewControllerDelegate> delegate;
++-(void)addNewString:(NSString*)str;
++@end
+diff --git a/BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.m b/BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.m
+new file mode 100644
+index 0000000..88545d8
+--- /dev/null
++++ b/BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.m
+@@ -0,0 +1,65 @@
++//
++//  LogsViewController.m
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 9/28/15.
++//  Copyright © 2015 Lifewaresolutions. All rights reserved.
++//
++
++#import "LogsViewController.h"
++
++@interface LogsViewController ()
++@property (weak, nonatomic) IBOutlet UITextView *textView;
++
++@end
++
++@implementation LogsViewController
++
++- (void)viewDidLoad {
++    [super viewDidLoad];
++    
++    [self scrollTextViewToBottom];
++}
++
++- (void)didReceiveMemoryWarning {
++    [super didReceiveMemoryWarning];
++    // Dispose of any resources that can be recreated.
++}
++
++-(IBAction)doneClicked:(id)sender {
++    [self dismissViewControllerAnimated:YES completion:^{}];
++    if ([self.delegate respondsToSelector:@selector(logsViewControllerDone)]) {
++        [self.delegate logsViewControllerDone];
++    }
++}
++
++-(void)scrollTextViewToBottom {
++    if (self.textView.text.length > 5) {
++    NSRange range = NSMakeRange(self.textView.text.length - 5, 5);
++    [self.textView scrollRangeToVisible:range];
++    }
++}
++- (BOOL)isAtBottom {
++    float bottomEdge = self.textView.contentOffset.y + self.textView.frame.size.height;
++    return bottomEdge >= self.textView.contentSize.height-10;
++}
++-(void)addNewString:(NSString*)str {
++    if (self.view){}
++    BOOL isBottom = self.isAtBottom;
++    self.textView.text = [self.textView.text stringByAppendingString:str];
++    
++    if (isBottom) {
++        [self performSelector:@selector(scrollTextViewToBottom) withObject:nil afterDelay:0.01];
++    }
++}
++/*
++#pragma mark - Navigation
++
++// In a storyboard-based application, you will often want to do a little preparation before navigation
++- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
++    // Get the new view controller using [segue destinationViewController].
++    // Pass the selected object to the new view controller.
++}
++*/
++
++@end
+diff --git a/BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.xib b/BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.xib
+new file mode 100644
+index 0000000..50b039d
+--- /dev/null
++++ b/BGModesTest/Managers/LoggerManager/LogsViewController/LogsViewController.xib
+@@ -0,0 +1,50 @@
++<?xml version="1.0" encoding="UTF-8" standalone="no"?>
++<document type="com.apple.InterfaceBuilder3.CocoaTouch.XIB" version="3.0" toolsVersion="8191" systemVersion="14F27" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES">
++    <dependencies>
++        <deployment identifier="iOS"/>
++        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="8154"/>
++    </dependencies>
++    <objects>
++        <placeholder placeholderIdentifier="IBFilesOwner" id="-1" userLabel="File's Owner" customClass="LogsViewController">
++            <connections>
++                <outlet property="textView" destination="iIS-LS-6bf" id="NbH-u0-Vcj"/>
++                <outlet property="view" destination="i5M-Pr-FkT" id="sfx-zR-JGt"/>
++            </connections>
++        </placeholder>
++        <placeholder placeholderIdentifier="IBFirstResponder" id="-2" customClass="UIResponder"/>
++        <view clearsContextBeforeDrawing="NO" contentMode="scaleToFill" id="i5M-Pr-FkT">
++            <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
++            <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
++            <subviews>
++                <navigationBar contentMode="scaleToFill" translatesAutoresizingMaskIntoConstraints="NO" id="ZrU-42-4gR">
++                    <rect key="frame" x="0.0" y="20" width="600" height="44"/>
++                    <color key="barTintColor" white="1" alpha="1" colorSpace="calibratedWhite"/>
++                    <items>
++                        <navigationItem title="Logs" id="kG0-Ll-u2U">
++                            <barButtonItem key="leftBarButtonItem" systemItem="done" id="00c-EY-hkZ">
++                                <connections>
++                                    <action selector="doneClicked:" destination="-1" id="zei-6S-K2V"/>
++                                </connections>
++                            </barButtonItem>
++                        </navigationItem>
++                    </items>
++                </navigationBar>
++                <textView clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="scaleToFill" textAlignment="natural" translatesAutoresizingMaskIntoConstraints="NO" id="iIS-LS-6bf">
++                    <rect key="frame" x="0.0" y="64" width="600" height="536"/>
++                    <fontDescription key="fontDescription" type="system" pointSize="14"/>
++                    <textInputTraits key="textInputTraits" autocapitalizationType="sentences"/>
++                </textView>
++            </subviews>
++            <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
++            <constraints>
++                <constraint firstItem="iIS-LS-6bf" firstAttribute="top" secondItem="ZrU-42-4gR" secondAttribute="bottom" id="0XU-1F-68o"/>
++                <constraint firstAttribute="trailing" secondItem="iIS-LS-6bf" secondAttribute="trailing" id="2Kd-Ld-FyX"/>
++                <constraint firstAttribute="bottom" secondItem="iIS-LS-6bf" secondAttribute="bottom" id="7HZ-Z3-Sq4"/>
++                <constraint firstAttribute="trailing" secondItem="ZrU-42-4gR" secondAttribute="trailing" id="Auc-ks-y2d"/>
++                <constraint firstItem="ZrU-42-4gR" firstAttribute="top" secondItem="i5M-Pr-FkT" secondAttribute="top" constant="20" id="C8G-6J-q5N"/>
++                <constraint firstItem="ZrU-42-4gR" firstAttribute="leading" secondItem="i5M-Pr-FkT" secondAttribute="leading" id="EAY-QU-Q2c"/>
++                <constraint firstItem="iIS-LS-6bf" firstAttribute="leading" secondItem="i5M-Pr-FkT" secondAttribute="leading" id="leP-T6-xSl"/>
++            </constraints>
++        </view>
++    </objects>
++</document>
+diff --git a/BGModesTest/Managers/ServerManager/ServerManager.h b/BGModesTest/Managers/ServerManager/ServerManager.h
+new file mode 100644
+index 0000000..dc7d963
+--- /dev/null
++++ b/BGModesTest/Managers/ServerManager/ServerManager.h
+@@ -0,0 +1,20 @@
++//
++//  ServerManager.h
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 22.11.15.
++//  Copyright © 2015 LWS. All rights reserved.
++//
++
++#import <Foundation/Foundation.h>
++#define kServerAvailabilityChanged @"kServerAvailabilityChanged"
++#define ServerManagerInstance [ServerManager instance]
++
++@interface ServerManager : NSObject
++@property BOOL isAvailable;
++-(void)updateState;
++
++#pragma mark - init
++
+++(instancetype)instance;
++@end
+diff --git a/BGModesTest/Managers/ServerManager/ServerManager.m b/BGModesTest/Managers/ServerManager/ServerManager.m
+new file mode 100644
+index 0000000..dda5da2
+--- /dev/null
++++ b/BGModesTest/Managers/ServerManager/ServerManager.m
+@@ -0,0 +1,114 @@
++//
++//  ServerManager.m
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 22.11.15.
++//  Copyright © 2015 LWS. All rights reserved.
++//
++
++#import "ServerManager.h"
++#import <CoreLocation/CoreLocation.h>
++#import "LoggerManager.h"
++#import "BackgroundTaskManager.h"
++#import "LocationManager.h"
++
++#define kIsAvailableState @"kIsAvailableState"
++#define kSendingTimeInterval 30.0
++
++@interface ServerManager () {
++    NSTimer* timer;
++    CLLocation* lastSendedLocation;
++    NSDate* lastSendingCoordinateDate;
++}
++@property (nonatomic) BackgroundTaskManager * bgTask;
++
++@end
++
++@implementation ServerManager
++
++#pragma mark - properties
++
++-(BOOL)isAvailable {
++    return [[NSUserDefaults standardUserDefaults] boolForKey:kIsAvailableState];
++}
++
++-(void)setIsAvailable:(BOOL)isAvailable {
++    [[NSUserDefaults standardUserDefaults] setBool:isAvailable forKey:kIsAvailableState];
++    [[NSUserDefaults standardUserDefaults] synchronize];
++    
++    [[NSNotificationCenter defaultCenter] postNotificationName:kServerAvailabilityChanged object:nil];
++    [self updateState];
++}
++
++#pragma mark - logic
++
++-(void)sendCoordinateMessage {
++    if (LocationManagerInstance.userLocaton) {
++        [LoggerManagerInstance addMessage:[NSString stringWithFormat:@"ServerManager sendCoordinateMessage LocationManagerInstance.userLocaton %@",LocationManagerInstance.userLocaton]];
++    }
++    else {
++        [LoggerManagerInstance addMessage:@"ServerManager sendCoordinateMessage LocationManagerInstance.userLocaton is null"];
++    }
++}
++-(void)locationChanged {
++    if (LocationManagerInstance.userLocaton) {
++        double locationInterval = 0;
++        if (lastSendingCoordinateDate) {
++            locationInterval = [[NSDate date] timeIntervalSinceDate:lastSendingCoordinateDate];
++        }
++        if (!lastSendedLocation || !lastSendingCoordinateDate || fabs(locationInterval) > kSendingTimeInterval) {
++            if (timer) {
++                [LoggerManagerInstance addMessage:[NSString stringWithFormat:@"ServerManager locationChanged and [timer fire] locationInterval: %f",locationInterval]];
++                [self resetTimer];
++            }
++        }
++    }
++}
++-(void)setTimer {
++    if (!timer) {
++        [LoggerManagerInstance addMessage:[NSString stringWithFormat:@"ServerManager setTimer timerInterval-%f",kSendingTimeInterval]];
++        
++        self.bgTask = [BackgroundTaskManager sharedBackgroundTaskManager];
++        [self.bgTask beginNewBackgroundTask];
++        timer = [NSTimer timerWithTimeInterval:kSendingTimeInterval target:self selector:@selector(sendCoordinateMessage) userInfo:nil repeats:YES];
++        [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
++        [timer fire];
++        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(locationChanged) name:kLocationManagerLocationChanged object:nil];
++    }
++}
++-(void)removeTimer {
++    if (timer) {
++        [LoggerManagerInstance addMessage:[NSString stringWithFormat:@"ServerManager removeTimer timerInterval-%f",kSendingTimeInterval]];
++        lastSendedLocation = nil;
++        [self.bgTask endAllBackgroundTasks];
++        [timer invalidate];
++        timer = nil;
++        [[NSNotificationCenter defaultCenter] removeObserver:self name:kLocationManagerLocationChanged object:nil];
++    }
++}
++-(void)resetTimer {
++    [LoggerManagerInstance addMessage:@"ServerManager resetTimer"];
++    [self removeTimer];
++    if (self.isAvailable) {
++        [self setTimer];
++    }
++}
++-(void)updateState {
++    [self resetTimer];
++}
++
++#pragma mark - init
++
+++(instancetype)instance{
++    static ServerManager *instance;
++    
++    @synchronized(self) {
++        if(!instance) {
++            instance = [[ServerManager alloc] init];
++        }
++    }
++    
++    return instance;
++}
++
++@end
+diff --git a/BGModesTest/ViewController.h b/BGModesTest/ViewController.h
+new file mode 100644
+index 0000000..65099f7
+--- /dev/null
++++ b/BGModesTest/ViewController.h
+@@ -0,0 +1,15 @@
++//
++//  ViewController.h
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 22.11.15.
++//  Copyright © 2015 LWS. All rights reserved.
++//
++
++#import <UIKit/UIKit.h>
++
++@interface ViewController : UIViewController
++
++
++@end
++
+diff --git a/BGModesTest/ViewController.m b/BGModesTest/ViewController.m
+new file mode 100644
+index 0000000..96138b4
+--- /dev/null
++++ b/BGModesTest/ViewController.m
+@@ -0,0 +1,50 @@
++//
++//  ViewController.m
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 22.11.15.
++//  Copyright © 2015 LWS. All rights reserved.
++//
++
++#import "ViewController.h"
++#import "ServerManager.h"
++#import "LoggerManager.h"
++
++@interface ViewController ()
++@property (weak, nonatomic) IBOutlet UISegmentedControl *availabilitySegmentControl;
++
++@end
++
++@implementation ViewController
++-(void)updateAvailabilitySegmentController {
++    if (ServerManagerInstance.isAvailable) {
++        self.availabilitySegmentControl.tintColor = [UIColor greenColor];
++    }
++    else {
++        self.availabilitySegmentControl.tintColor = [UIColor redColor];
++    }
++}
++- (IBAction)availabilitySegmanetControlValueChanged:(id)sender {
++    ServerManagerInstance.isAvailable = self.availabilitySegmentControl.selectedSegmentIndex == 0;
++    [self updateAvailabilitySegmentController];
++}
++- (IBAction)showLogsButtonClicked:(id)sender {
++    [LoggerManagerInstance showLogs];
++}
++- (IBAction)sendLogsButtonClicked:(id)sender {
++    [LoggerManagerInstance sendLogByMail];
++}
++
++- (void)viewDidLoad {
++    [super viewDidLoad];
++    
++    self.availabilitySegmentControl.selectedSegmentIndex = ServerManagerInstance.isAvailable ? 0 : 1;
++    [self updateAvailabilitySegmentController];
++}
++
++- (void)didReceiveMemoryWarning {
++    [super didReceiveMemoryWarning];
++    // Dispose of any resources that can be recreated.
++}
++
++@end
+diff --git a/BGModesTest/main.m b/BGModesTest/main.m
+new file mode 100644
+index 0000000..ba74422
+--- /dev/null
++++ b/BGModesTest/main.m
+@@ -0,0 +1,16 @@
++//
++//  main.m
++//  BGModesTest
++//
++//  Created by Vasiliy Kravchuk on 22.11.15.
++//  Copyright © 2015 LWS. All rights reserved.
++//
++
++#import <UIKit/UIKit.h>
++#import "AppDelegate.h"
++
++int main(int argc, char * argv[]) {
++    @autoreleasepool {
++        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
++    }
++}
+diff --git a/Podfile b/Podfile
+new file mode 100644
+index 0000000..40a4c07
+--- /dev/null
++++ b/Podfile
+@@ -0,0 +1,8 @@
++# Uncomment this line to define a global platform for your project
++# platform :ios, '8.0'
++# Uncomment this line if you're using Swift
++# use_frameworks!
++
++platform :ios, '7.0'
++pod 'CocoaLumberjack'
++
+diff --git a/Podfile.lock b/Podfile.lock
+new file mode 100644
+index 0000000..b8c2f04
+--- /dev/null
++++ b/Podfile.lock
+@@ -0,0 +1,17 @@
++PODS:
++  - CocoaLumberjack (2.2.0):
++    - CocoaLumberjack/Default (= 2.2.0)
++    - CocoaLumberjack/Extensions (= 2.2.0)
++  - CocoaLumberjack/Core (2.2.0)
++  - CocoaLumberjack/Default (2.2.0):
++    - CocoaLumberjack/Core
++  - CocoaLumberjack/Extensions (2.2.0):
++    - CocoaLumberjack/Default
++
++DEPENDENCIES:
++  - CocoaLumberjack
++
++SPEC CHECKSUMS:
++  CocoaLumberjack: 17fe8581f84914d5d7e6360f7c70022b173c3ae0
++
++COCOAPODS: 0.39.0
+diff --git a/Pods/CocoaLumberjack/Classes/CocoaLumberjack.h b/Pods/CocoaLumberjack/Classes/CocoaLumberjack.h
+new file mode 100644
+index 0000000..0b568fb
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/CocoaLumberjack.h
+@@ -0,0 +1,81 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++/**
++ * Welcome to CocoaLumberjack!
++ *
++ * The project page has a wealth of documentation if you have any questions.
++ * https://github.com/CocoaLumberjack/CocoaLumberjack
++ *
++ * If you're new to the project you may wish to read "Getting Started" at:
++ * Documentation/GettingStarted.md
++ *
++ * Otherwise, here is a quick refresher.
++ * There are three steps to using the macros:
++ *
++ * Step 1:
++ * Import the header in your implementation or prefix file:
++ *
++ * #import <CocoaLumberjack/CocoaLumberjack.h>
++ *
++ * Step 2:
++ * Define your logging level in your implementation file:
++ *
++ * // Log levels: off, error, warn, info, verbose
++ * static const DDLogLevel ddLogLevel = DDLogLevelVerbose;
++ *
++ * Step 2 [3rd party frameworks]:
++ *
++ * Define your LOG_LEVEL_DEF to a different variable/function than ddLogLevel:
++ *
++ * // #undef LOG_LEVEL_DEF // Undefine first only if needed
++ * #define LOG_LEVEL_DEF myLibLogLevel
++ *
++ * Define your logging level in your implementation file:
++ *
++ * // Log levels: off, error, warn, info, verbose
++ * static const DDLogLevel myLibLogLevel = DDLogLevelVerbose;
++ *
++ * Step 3:
++ * Replace your NSLog statements with DDLog statements according to the severity of the message.
++ *
++ * NSLog(@"Fatal error, no dohickey found!"); -> DDLogError(@"Fatal error, no dohickey found!");
++ *
++ * DDLog works exactly the same as NSLog.
++ * This means you can pass it multiple variables just like NSLog.
++ **/
++
++#import <Foundation/Foundation.h>
++
++// Disable legacy macros
++#ifndef DD_LEGACY_MACROS
++    #define DD_LEGACY_MACROS 0
++#endif
++
++// Core
++#import "DDLog.h"
++
++// Main macros
++#import "DDLogMacros.h"
++#import "DDAssertMacros.h"
++
++// Capture ASL
++#import "DDASLLogCapture.h"
++
++// Loggers
++#import "DDTTYLogger.h"
++#import "DDASLLogger.h"
++#import "DDFileLogger.h"
++
+diff --git a/Pods/CocoaLumberjack/Classes/CocoaLumberjack.swift b/Pods/CocoaLumberjack/Classes/CocoaLumberjack.swift
+new file mode 100644
+index 0000000..5f022ce
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/CocoaLumberjack.swift
+@@ -0,0 +1,91 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2014-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++import Foundation
++
++extension DDLogFlag {
++    public static func fromLogLevel(logLevel: DDLogLevel) -> DDLogFlag {
++        return DDLogFlag(rawValue: logLevel.rawValue)
++    }
++	
++	public init(_ logLevel: DDLogLevel) {
++        self = DDLogFlag(rawValue: logLevel.rawValue)
++	}
++    
++    ///returns the log level, or the lowest equivalant.
++    public func toLogLevel() -> DDLogLevel {
++        if let ourValid = DDLogLevel(rawValue: self.rawValue) {
++            return ourValid
++        } else {
++            let logFlag:DDLogFlag = self
++            
++            if logFlag.contains(.Verbose) {
++                return .Verbose
++            } else if logFlag.contains(.Debug) {
++                return .Debug
++            } else if logFlag.contains(.Info) {
++                return .Info
++            } else if logFlag.contains(.Warning) {
++                return .Warning
++            } else if logFlag.contains(.Error) {
++                return .Error
++            } else {
++                return .Off
++            }
++        }
++    }
++}
++
++public var defaultDebugLevel = DDLogLevel.Verbose
++
++public func resetDefaultDebugLevel() {
++    defaultDebugLevel = DDLogLevel.Verbose
++}
++
++public func SwiftLogMacro(isAsynchronous: Bool, level: DDLogLevel, flag flg: DDLogFlag, context: Int = 0, file: StaticString = __FILE__, function: StaticString = __FUNCTION__, line: UInt = __LINE__, tag: AnyObject? = nil, @autoclosure string: () -> String) {
++    if level.rawValue & flg.rawValue != 0 {
++        // Tell the DDLogMessage constructor to copy the C strings that get passed to it.
++        // Using string interpolation to prevent integer overflow warning when using StaticString.stringValue
++        let logMessage = DDLogMessage(message: string(), level: level, flag: flg, context: context, file: "\(file)", function: "\(function)", line: line, tag: tag, options: [.CopyFile, .CopyFunction], timestamp: nil)
++        DDLog.log(isAsynchronous, message: logMessage)
++    }
++}
++
++public func DDLogDebug(@autoclosure logText: () -> String, level: DDLogLevel = defaultDebugLevel, context: Int = 0, file: StaticString = __FILE__, function: StaticString = __FUNCTION__, line: UInt = __LINE__, tag: AnyObject? = nil, asynchronous async: Bool = true) {
++    SwiftLogMacro(async, level: level, flag: .Debug, context: context, file: file, function: function, line: line, tag: tag, string: logText)
++}
++
++public func DDLogInfo(@autoclosure logText: () -> String, level: DDLogLevel = defaultDebugLevel, context: Int = 0, file: StaticString = __FILE__, function: StaticString = __FUNCTION__, line: UInt = __LINE__, tag: AnyObject? = nil, asynchronous async: Bool = true) {
++    SwiftLogMacro(async, level: level, flag: .Info, context: context, file: file, function: function, line: line, tag: tag, string: logText)
++}
++
++public func DDLogWarn(@autoclosure logText: () -> String, level: DDLogLevel = defaultDebugLevel, context: Int = 0, file: StaticString = __FILE__, function: StaticString = __FUNCTION__, line: UInt = __LINE__, tag: AnyObject? = nil, asynchronous async: Bool = true) {
++    SwiftLogMacro(async, level: level, flag: .Warning, context: context, file: file, function: function, line: line, tag: tag, string: logText)
++}
++
++public func DDLogVerbose(@autoclosure logText: () -> String, level: DDLogLevel = defaultDebugLevel, context: Int = 0, file: StaticString = __FILE__, function: StaticString = __FUNCTION__, line: UInt = __LINE__, tag: AnyObject? = nil, asynchronous async: Bool = true) {
++    SwiftLogMacro(async, level: level, flag: .Verbose, context: context, file: file, function: function, line: line, tag: tag, string: logText)
++}
++
++public func DDLogError(@autoclosure logText: () -> String, level: DDLogLevel = defaultDebugLevel, context: Int = 0, file: StaticString = __FILE__, function: StaticString = __FUNCTION__, line: UInt = __LINE__, tag: AnyObject? = nil, asynchronous async: Bool = false) {
++    SwiftLogMacro(async, level: level, flag: .Error, context: context, file: file, function: function, line: line, tag: tag, string: logText)
++}
++
++/// Analogous to the C preprocessor macro `THIS_FILE`.
++public func CurrentFileName(fileName: StaticString = __FILE__) -> String {
++    // Using string interpolation to prevent integer overflow warning when using StaticString.stringValue
++    // This double-casting to NSString is necessary as changes to how Swift handles NSPathUtilities requres the string to be an NSString
++    return (("\(fileName)" as NSString).lastPathComponent as NSString).stringByDeletingPathExtension
++}
+diff --git a/Pods/CocoaLumberjack/Classes/DDASLLogCapture.h b/Pods/CocoaLumberjack/Classes/DDASLLogCapture.h
+new file mode 100644
+index 0000000..f7fa79f
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDASLLogCapture.h
+@@ -0,0 +1,48 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++#import "DDASLLogger.h"
++
++@protocol DDLogger;
++
++/**
++ *  This class provides the ability to capture the ASL (Apple System Logs)
++ */
++@interface DDASLLogCapture : NSObject
++
++/**
++ *  Start capturing logs
++ */
+++ (void)start;
++
++/**
++ *  Stop capturing logs
++ */
+++ (void)stop;
++
++/**
++ *  Returns the current capture level.
++ *  @note Default log level: DDLogLevelVerbose (i.e. capture all ASL messages).
++ */
+++ (DDLogLevel)captureLevel;
++
++/**
++ *  Set the capture level
++ *
++ *  @param level new level
++ */
+++ (void)setCaptureLevel:(DDLogLevel)level;
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/DDASLLogCapture.m b/Pods/CocoaLumberjack/Classes/DDASLLogCapture.m
+new file mode 100644
+index 0000000..98d5342
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDASLLogCapture.m
+@@ -0,0 +1,230 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++#import "DDASLLogCapture.h"
++
++// Disable legacy macros
++#ifndef DD_LEGACY_MACROS
++    #define DD_LEGACY_MACROS 0
++#endif
++
++#import "DDLog.h"
++
++#include <asl.h>
++#include <notify.h>
++#include <notify_keys.h>
++#include <sys/time.h>
++
++static BOOL _cancel = YES;
++static DDLogLevel _captureLevel = DDLogLevelVerbose;
++
++#ifdef __IPHONE_8_0
++    #define DDASL_IOS_PIVOT_VERSION __IPHONE_8_0
++#endif
++#ifdef __MAC_10_10
++    #define DDASL_OSX_PIVOT_VERSION __MAC_10_10
++#endif
++
++@implementation DDASLLogCapture
++
++static aslmsg (*dd_asl_next)(aslresponse obj);
++static void (*dd_asl_release)(aslresponse obj);
++
+++ (void)initialize
++{
++    #if (defined(DDASL_IOS_PIVOT_VERSION) && __IPHONE_OS_VERSION_MAX_ALLOWED >= DDASL_IOS_PIVOT_VERSION) || (defined(DDASL_OSX_PIVOT_VERSION) && __MAC_OS_X_VERSION_MAX_ALLOWED >= DDASL_OSX_PIVOT_VERSION)
++        #if __IPHONE_OS_VERSION_MIN_REQUIRED < DDASL_IOS_PIVOT_VERSION || __MAC_OS_X_VERSION_MIN_REQUIRED < DDASL_OSX_PIVOT_VERSION
++            #pragma GCC diagnostic push
++            #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
++                // Building on falsely advertised SDK, targeting deprecated API
++                dd_asl_next    = &aslresponse_next;
++                dd_asl_release = &aslresponse_free;
++            #pragma GCC diagnostic pop
++        #else
++            // Building on lastest, correct SDK, targeting latest API
++            dd_asl_next    = &asl_next;
++            dd_asl_release = &asl_release;
++        #endif
++    #else
++        // Building on old SDKs, targeting deprecated API
++        dd_asl_next    = &aslresponse_next;
++        dd_asl_release = &aslresponse_free;
++    #endif
++}
++
+++ (void)start {
++    // Ignore subsequent calls
++    if (!_cancel) {
++        return;
++    }
++    
++    _cancel = NO;
++    
++    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(void) {
++        [self captureAslLogs];
++    });
++}
++
+++ (void)stop {
++    _cancel = YES;
++}
++
+++ (DDLogLevel)captureLevel {
++    return _captureLevel;
++}
++
+++ (void)setCaptureLevel:(DDLogLevel)level {
++    _captureLevel = level;
++}
++
++#pragma mark - Private methods
++
+++ (void)configureAslQuery:(aslmsg)query {
++    const char param[] = "7";  // ASL_LEVEL_DEBUG, which is everything. We'll rely on regular DDlog log level to filter
++    
++    asl_set_query(query, ASL_KEY_LEVEL, param, ASL_QUERY_OP_LESS_EQUAL | ASL_QUERY_OP_NUMERIC);
++
++    // Don't retrieve logs from our own DDASLLogger
++    asl_set_query(query, kDDASLKeyDDLog, kDDASLDDLogValue, ASL_QUERY_OP_NOT_EQUAL);
++    
++#if !TARGET_OS_IPHONE || TARGET_SIMULATOR
++    int processId = [[NSProcessInfo processInfo] processIdentifier];
++    char pid[16];
++    sprintf(pid, "%d", processId);
++    asl_set_query(query, ASL_KEY_PID, pid, ASL_QUERY_OP_EQUAL | ASL_QUERY_OP_NUMERIC);
++#endif
++}
++
+++ (void)aslMessageReceived:(aslmsg)msg {
++    const char* messageCString = asl_get( msg, ASL_KEY_MSG );
++    if ( messageCString == NULL )
++        return;
++
++    int flag;
++    BOOL async;
++
++    const char* levelCString = asl_get(msg, ASL_KEY_LEVEL);
++    switch (levelCString? atoi(levelCString) : 0) {
++        // By default all NSLog's with a ASL_LEVEL_WARNING level
++        case ASL_LEVEL_EMERG    :
++        case ASL_LEVEL_ALERT    :
++        case ASL_LEVEL_CRIT     : flag = DDLogFlagError;    async = NO;  break;
++        case ASL_LEVEL_ERR      : flag = DDLogFlagWarning;  async = YES; break;
++        case ASL_LEVEL_WARNING  : flag = DDLogFlagInfo;     async = YES; break;
++        case ASL_LEVEL_NOTICE   : flag = DDLogFlagDebug;    async = YES; break;
++        case ASL_LEVEL_INFO     :
++        case ASL_LEVEL_DEBUG    :
++        default                 : flag = DDLogFlagVerbose;  async = YES;  break;
++    }
++
++    if (!(_captureLevel & flag)) {
++        return;
++    }
++
++    //  NSString * sender = [NSString stringWithCString:asl_get(msg, ASL_KEY_SENDER) encoding:NSUTF8StringEncoding];
++    NSString *message = @(messageCString);
++
++    const char* secondsCString = asl_get( msg, ASL_KEY_TIME );
++    const char* nanoCString = asl_get( msg, ASL_KEY_TIME_NSEC );
++    NSTimeInterval seconds = secondsCString ? strtod(secondsCString, NULL) : [NSDate timeIntervalSinceReferenceDate] - NSTimeIntervalSince1970;
++    double nanoSeconds = nanoCString? strtod(nanoCString, NULL) : 0;
++    NSTimeInterval totalSeconds = seconds + (nanoSeconds / 1e9);
++
++    NSDate *timeStamp = [NSDate dateWithTimeIntervalSince1970:totalSeconds];
++
++    DDLogMessage *logMessage = [[DDLogMessage alloc]initWithMessage:message
++                                                              level:_captureLevel
++                                                               flag:flag
++                                                            context:0
++                                                               file:@"DDASLLogCapture"
++                                                           function:0
++                                                               line:0
++                                                                tag:nil
++                                                            options:0
++                                                          timestamp:timeStamp];
++    
++    [DDLog log:async message:logMessage];
++}
++
+++ (void)captureAslLogs {
++    @autoreleasepool
++    {
++        /*
++           We use ASL_KEY_MSG_ID to see each message once, but there's no
++           obvious way to get the "next" ID. To bootstrap the process, we'll
++           search by timestamp until we've seen a message.
++         */
++
++        struct timeval timeval = {
++            .tv_sec = 0
++        };
++        gettimeofday(&timeval, NULL);
++        unsigned long long startTime = timeval.tv_sec;
++        __block unsigned long long lastSeenID = 0;
++
++        /*
++           syslogd posts kNotifyASLDBUpdate (com.apple.system.logger.message)
++           through the notify API when it saves messages to the ASL database.
++           There is some coalescing - currently it is sent at most twice per
++           second - but there is no documented guarantee about this. In any
++           case, there may be multiple messages per notification.
++
++           Notify notifications don't carry any payload, so we need to search
++           for the messages.
++         */
++        int notifyToken = 0;  // Can be used to unregister with notify_cancel().
++        notify_register_dispatch(kNotifyASLDBUpdate, &notifyToken, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(int token)
++        {
++            // At least one message has been posted; build a search query.
++            @autoreleasepool
++            {
++                aslmsg query = asl_new(ASL_TYPE_QUERY);
++                char stringValue[64];
++
++                if (lastSeenID > 0) {
++                    snprintf(stringValue, sizeof stringValue, "%llu", lastSeenID);
++                    asl_set_query(query, ASL_KEY_MSG_ID, stringValue, ASL_QUERY_OP_GREATER | ASL_QUERY_OP_NUMERIC);
++                } else {
++                    snprintf(stringValue, sizeof stringValue, "%llu", startTime);
++                    asl_set_query(query, ASL_KEY_TIME, stringValue, ASL_QUERY_OP_GREATER_EQUAL | ASL_QUERY_OP_NUMERIC);
++                }
++
++                [self configureAslQuery:query];
++
++                // Iterate over new messages.
++                aslmsg msg;
++                aslresponse response = asl_search(NULL, query);
++                
++                while ((msg = dd_asl_next(response)))
++                {
++                    [self aslMessageReceived:msg];
++
++                    // Keep track of which messages we've seen.
++                    lastSeenID = atoll(asl_get(msg, ASL_KEY_MSG_ID));
++                }
++                dd_asl_release(response);
++                asl_free(query);
++
++                if (_cancel) {
++                    notify_cancel(token);
++                    return;
++                }
++
++            }
++        });
++    }
++}
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/DDASLLogger.h b/Pods/CocoaLumberjack/Classes/DDASLLogger.h
+new file mode 100644
+index 0000000..24cc1c3
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDASLLogger.h
+@@ -0,0 +1,58 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++#import <Foundation/Foundation.h>
++
++// Disable legacy macros
++#ifndef DD_LEGACY_MACROS
++    #define DD_LEGACY_MACROS 0
++#endif
++
++#import "DDLog.h"
++
++// Custom key set on messages sent to ASL
++extern const char* const kDDASLKeyDDLog;
++
++// Value set for kDDASLKeyDDLog
++extern const char* const kDDASLDDLogValue;
++
++/**
++ * This class provides a logger for the Apple System Log facility.
++ *
++ * As described in the "Getting Started" page,
++ * the traditional NSLog() function directs its output to two places:
++ *
++ * - Apple System Log
++ * - StdErr (if stderr is a TTY) so log statements show up in Xcode console
++ *
++ * To duplicate NSLog() functionality you can simply add this logger and a tty logger.
++ * However, if you instead choose to use file logging (for faster performance),
++ * you may choose to use a file logger and a tty logger.
++ **/
++@interface DDASLLogger : DDAbstractLogger <DDLogger>
++
++/**
++ *  Singleton method
++ *
++ *  @return the shared instance
++ */
+++ (instancetype)sharedInstance;
++
++// Inherited from DDAbstractLogger
++
++// - (id <DDLogFormatter>)logFormatter;
++// - (void)setLogFormatter:(id <DDLogFormatter>)formatter;
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/DDASLLogger.m b/Pods/CocoaLumberjack/Classes/DDASLLogger.m
+new file mode 100644
+index 0000000..90061c8
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDASLLogger.m
+@@ -0,0 +1,121 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++#import "DDASLLogger.h"
++#import <asl.h>
++
++#if !__has_feature(objc_arc)
++#error This file must be compiled with ARC. Use -fobjc-arc flag (or convert project to ARC).
++#endif
++
++const char* const kDDASLKeyDDLog = "DDLog";
++
++const char* const kDDASLDDLogValue = "1";
++
++static DDASLLogger *sharedInstance;
++
++@interface DDASLLogger () {
++    aslclient _client;
++}
++
++@end
++
++
++@implementation DDASLLogger
++
+++ (instancetype)sharedInstance {
++    static dispatch_once_t DDASLLoggerOnceToken;
++
++    dispatch_once(&DDASLLoggerOnceToken, ^{
++        sharedInstance = [[[self class] alloc] init];
++    });
++
++    return sharedInstance;
++}
++
++- (instancetype)init {
++    if (sharedInstance != nil) {
++        return nil;
++    }
++
++    if ((self = [super init])) {
++        // A default asl client is provided for the main thread,
++        // but background threads need to create their own client.
++
++        _client = asl_open(NULL, "com.apple.console", 0);
++    }
++
++    return self;
++}
++
++- (void)logMessage:(DDLogMessage *)logMessage {
++    // Skip captured log messages
++    if ([logMessage->_fileName isEqualToString:@"DDASLLogCapture"]) {
++        return;
++    }
++
++    NSString * message = _logFormatter ? [_logFormatter formatLogMessage:logMessage] : logMessage->_message;
++
++    if (logMessage) {
++        const char *msg = [message UTF8String];
++
++        size_t aslLogLevel;
++        switch (logMessage->_flag) {
++            // Note: By default ASL will filter anything above level 5 (Notice).
++            // So our mappings shouldn't go above that level.
++            case DDLogFlagError     : aslLogLevel = ASL_LEVEL_CRIT;     break;
++            case DDLogFlagWarning   : aslLogLevel = ASL_LEVEL_ERR;      break;
++            case DDLogFlagInfo      : aslLogLevel = ASL_LEVEL_WARNING;  break; // Regular NSLog's level
++            case DDLogFlagDebug     :
++            case DDLogFlagVerbose   :
++            default                 : aslLogLevel = ASL_LEVEL_NOTICE;   break;
++        }
++
++        static char const *const level_strings[] = { "0", "1", "2", "3", "4", "5", "6", "7" };
++
++        // NSLog uses the current euid to set the ASL_KEY_READ_UID.
++        uid_t const readUID = geteuid();
++
++        char readUIDString[16];
++#ifndef NS_BLOCK_ASSERTIONS
++        int l = snprintf(readUIDString, sizeof(readUIDString), "%d", readUID);
++#else
++        snprintf(readUIDString, sizeof(readUIDString), "%d", readUID);
++#endif
++
++        NSAssert(l < sizeof(readUIDString),
++                 @"Formatted euid is too long.");
++        NSAssert(aslLogLevel < (sizeof(level_strings) / sizeof(level_strings[0])),
++                 @"Unhandled ASL log level.");
++
++        aslmsg m = asl_new(ASL_TYPE_MSG);
++        if (m != NULL) {
++            if (asl_set(m, ASL_KEY_LEVEL, level_strings[aslLogLevel]) == 0 &&
++                asl_set(m, ASL_KEY_MSG, msg) == 0 &&
++                asl_set(m, ASL_KEY_READ_UID, readUIDString) == 0 &&
++                asl_set(m, kDDASLKeyDDLog, kDDASLDDLogValue) == 0) {
++                asl_send(_client, m);
++            }
++            asl_free(m);
++        }
++        //TODO handle asl_* failures non-silently?
++    }
++}
++
++- (NSString *)loggerName {
++    return @"cocoa.lumberjack.aslLogger";
++}
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/DDAbstractDatabaseLogger.h b/Pods/CocoaLumberjack/Classes/DDAbstractDatabaseLogger.h
+new file mode 100644
+index 0000000..aad3666
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDAbstractDatabaseLogger.h
+@@ -0,0 +1,123 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++// Disable legacy macros
++#ifndef DD_LEGACY_MACROS
++    #define DD_LEGACY_MACROS 0
++#endif
++
++#import "DDLog.h"
++
++/**
++ * This class provides an abstract implementation of a database logger.
++ *
++ * That is, it provides the base implementation for a database logger to build atop of.
++ * All that is needed for a concrete database logger is to extend this class
++ * and override the methods in the implementation file that are prefixed with "db_".
++ **/
++@interface DDAbstractDatabaseLogger : DDAbstractLogger {
++    
++@protected
++    NSUInteger _saveThreshold;
++    NSTimeInterval _saveInterval;
++    NSTimeInterval _maxAge;
++    NSTimeInterval _deleteInterval;
++    BOOL _deleteOnEverySave;
++    
++    BOOL _saveTimerSuspended;
++    NSUInteger _unsavedCount;
++    dispatch_time_t _unsavedTime;
++    dispatch_source_t _saveTimer;
++    dispatch_time_t _lastDeleteTime;
++    dispatch_source_t _deleteTimer;
++}
++
++/**
++ * Specifies how often to save the data to disk.
++ * Since saving is an expensive operation (disk io) it is not done after every log statement.
++ * These properties allow you to configure how/when the logger saves to disk.
++ *
++ * A save is done when either (whichever happens first):
++ *
++ * - The number of unsaved log entries reaches saveThreshold
++ * - The amount of time since the oldest unsaved log entry was created reaches saveInterval
++ *
++ * You can optionally disable the saveThreshold by setting it to zero.
++ * If you disable the saveThreshold you are entirely dependent on the saveInterval.
++ *
++ * You can optionally disable the saveInterval by setting it to zero (or a negative value).
++ * If you disable the saveInterval you are entirely dependent on the saveThreshold.
++ *
++ * It's not wise to disable both saveThreshold and saveInterval.
++ *
++ * The default saveThreshold is 500.
++ * The default saveInterval is 60 seconds.
++ **/
++@property (assign, readwrite) NSUInteger saveThreshold;
++
++/**
++ *  See the description for the `saveThreshold` property
++ */
++@property (assign, readwrite) NSTimeInterval saveInterval;
++
++/**
++ * It is likely you don't want the log entries to persist forever.
++ * Doing so would allow the database to grow infinitely large over time.
++ *
++ * The maxAge property provides a way to specify how old a log statement can get
++ * before it should get deleted from the database.
++ *
++ * The deleteInterval specifies how often to sweep for old log entries.
++ * Since deleting is an expensive operation (disk io) is is done on a fixed interval.
++ *
++ * An alternative to the deleteInterval is the deleteOnEverySave option.
++ * This specifies that old log entries should be deleted during every save operation.
++ *
++ * You can optionally disable the maxAge by setting it to zero (or a negative value).
++ * If you disable the maxAge then old log statements are not deleted.
++ *
++ * You can optionally disable the deleteInterval by setting it to zero (or a negative value).
++ *
++ * If you disable both deleteInterval and deleteOnEverySave then old log statements are not deleted.
++ *
++ * It's not wise to enable both deleteInterval and deleteOnEverySave.
++ *
++ * The default maxAge is 7 days.
++ * The default deleteInterval is 5 minutes.
++ * The default deleteOnEverySave is NO.
++ **/
++@property (assign, readwrite) NSTimeInterval maxAge;
++
++/**
++ *  See the description for the `maxAge` property
++ */
++@property (assign, readwrite) NSTimeInterval deleteInterval;
++
++/**
++ *  See the description for the `maxAge` property
++ */
++@property (assign, readwrite) BOOL deleteOnEverySave;
++
++/**
++ * Forces a save of any pending log entries (flushes log entries to disk).
++ **/
++- (void)savePendingLogEntries;
++
++/**
++ * Removes any log entries that are older than maxAge.
++ **/
++- (void)deleteOldLogEntries;
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/DDAbstractDatabaseLogger.m b/Pods/CocoaLumberjack/Classes/DDAbstractDatabaseLogger.m
+new file mode 100644
+index 0000000..c8782de
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDAbstractDatabaseLogger.m
+@@ -0,0 +1,660 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++#import "DDAbstractDatabaseLogger.h"
++#import <math.h>
++
++
++#if !__has_feature(objc_arc)
++#error This file must be compiled with ARC. Use -fobjc-arc flag (or convert project to ARC).
++#endif
++
++@interface DDAbstractDatabaseLogger ()
++
++- (void)destroySaveTimer;
++- (void)destroyDeleteTimer;
++
++@end
++
++#pragma mark -
++
++@implementation DDAbstractDatabaseLogger
++
++- (instancetype)init {
++    if ((self = [super init])) {
++        _saveThreshold = 500;
++        _saveInterval = 60;           // 60 seconds
++        _maxAge = (60 * 60 * 24 * 7); //  7 days
++        _deleteInterval = (60 * 5);   //  5 minutes
++    }
++
++    return self;
++}
++
++- (void)dealloc {
++    [self destroySaveTimer];
++    [self destroyDeleteTimer];
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Override Me
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (BOOL)db_log:(DDLogMessage *)logMessage {
++    // Override me and add your implementation.
++    //
++    // Return YES if an item was added to the buffer.
++    // Return NO if the logMessage was ignored.
++
++    return NO;
++}
++
++- (void)db_save {
++    // Override me and add your implementation.
++}
++
++- (void)db_delete {
++    // Override me and add your implementation.
++}
++
++- (void)db_saveAndDelete {
++    // Override me and add your implementation.
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Private API
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (void)performSaveAndSuspendSaveTimer {
++    if (_unsavedCount > 0) {
++        if (_deleteOnEverySave) {
++            [self db_saveAndDelete];
++        } else {
++            [self db_save];
++        }
++    }
++
++    _unsavedCount = 0;
++    _unsavedTime = 0;
++
++    if (_saveTimer && !_saveTimerSuspended) {
++        dispatch_suspend(_saveTimer);
++        _saveTimerSuspended = YES;
++    }
++}
++
++- (void)performDelete {
++    if (_maxAge > 0.0) {
++        [self db_delete];
++
++        _lastDeleteTime = dispatch_time(DISPATCH_TIME_NOW, 0);
++    }
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Timers
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (void)destroySaveTimer {
++    if (_saveTimer) {
++        dispatch_source_cancel(_saveTimer);
++
++        if (_saveTimerSuspended) {
++            // Must resume a timer before releasing it (or it will crash)
++            dispatch_resume(_saveTimer);
++            _saveTimerSuspended = NO;
++        }
++
++        #if !OS_OBJECT_USE_OBJC
++        dispatch_release(_saveTimer);
++        #endif
++        _saveTimer = NULL;
++    }
++}
++
++- (void)updateAndResumeSaveTimer {
++    if ((_saveTimer != NULL) && (_saveInterval > 0.0) && (_unsavedTime > 0.0)) {
++        uint64_t interval = (uint64_t)(_saveInterval * NSEC_PER_SEC);
++        dispatch_time_t startTime = dispatch_time(_unsavedTime, interval);
++
++        dispatch_source_set_timer(_saveTimer, startTime, interval, 1.0);
++
++        if (_saveTimerSuspended) {
++            dispatch_resume(_saveTimer);
++            _saveTimerSuspended = NO;
++        }
++    }
++}
++
++- (void)createSuspendedSaveTimer {
++    if ((_saveTimer == NULL) && (_saveInterval > 0.0)) {
++        _saveTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, self.loggerQueue);
++
++        dispatch_source_set_event_handler(_saveTimer, ^{ @autoreleasepool {
++                                                            [self performSaveAndSuspendSaveTimer];
++                                                        } });
++
++        _saveTimerSuspended = YES;
++    }
++}
++
++- (void)destroyDeleteTimer {
++    if (_deleteTimer) {
++        dispatch_source_cancel(_deleteTimer);
++        #if !OS_OBJECT_USE_OBJC
++        dispatch_release(_deleteTimer);
++        #endif
++        _deleteTimer = NULL;
++    }
++}
++
++- (void)updateDeleteTimer {
++    if ((_deleteTimer != NULL) && (_deleteInterval > 0.0) && (_maxAge > 0.0)) {
++        uint64_t interval = (uint64_t)(_deleteInterval * NSEC_PER_SEC);
++        dispatch_time_t startTime;
++
++        if (_lastDeleteTime > 0) {
++            startTime = dispatch_time(_lastDeleteTime, interval);
++        } else {
++            startTime = dispatch_time(DISPATCH_TIME_NOW, interval);
++        }
++
++        dispatch_source_set_timer(_deleteTimer, startTime, interval, 1.0);
++    }
++}
++
++- (void)createAndStartDeleteTimer {
++    if ((_deleteTimer == NULL) && (_deleteInterval > 0.0) && (_maxAge > 0.0)) {
++        _deleteTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, self.loggerQueue);
++
++        if (_deleteTimer != NULL) {
++            dispatch_source_set_event_handler(_deleteTimer, ^{ @autoreleasepool {
++                                                                  [self performDelete];
++                                                              } });
++
++            [self updateDeleteTimer];
++
++            if (_deleteTimer != NULL) {
++                dispatch_resume(_deleteTimer);
++            }
++        }
++    }
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Configuration
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (NSUInteger)saveThreshold {
++    // The design of this method is taken from the DDAbstractLogger implementation.
++    // For extensive documentation please refer to the DDAbstractLogger implementation.
++
++    // Note: The internal implementation MUST access the colorsEnabled variable directly,
++    // This method is designed explicitly for external access.
++    //
++    // Using "self." syntax to go through this method will cause immediate deadlock.
++    // This is the intended result. Fix it by accessing the ivar directly.
++    // Great strides have been take to ensure this is safe to do. Plus it's MUCH faster.
++
++    NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++    NSAssert(![self isOnInternalLoggerQueue], @"MUST access ivar directly, NOT via self.* syntax.");
++
++    dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++
++    __block NSUInteger result;
++
++    dispatch_sync(globalLoggingQueue, ^{
++        dispatch_sync(self.loggerQueue, ^{
++            result = _saveThreshold;
++        });
++    });
++
++    return result;
++}
++
++- (void)setSaveThreshold:(NSUInteger)threshold {
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            if (_saveThreshold != threshold) {
++                _saveThreshold = threshold;
++
++                // Since the saveThreshold has changed,
++                // we check to see if the current unsavedCount has surpassed the new threshold.
++                //
++                // If it has, we immediately save the log.
++
++                if ((_unsavedCount >= _saveThreshold) && (_saveThreshold > 0)) {
++                    [self performSaveAndSuspendSaveTimer];
++                }
++            }
++        }
++    };
++
++    // The design of the setter logic below is taken from the DDAbstractLogger implementation.
++    // For documentation please refer to the DDAbstractLogger implementation.
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++        NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++
++        dispatch_async(globalLoggingQueue, ^{
++            dispatch_async(self.loggerQueue, block);
++        });
++    }
++}
++
++- (NSTimeInterval)saveInterval {
++    // The design of this method is taken from the DDAbstractLogger implementation.
++    // For extensive documentation please refer to the DDAbstractLogger implementation.
++
++    // Note: The internal implementation MUST access the colorsEnabled variable directly,
++    // This method is designed explicitly for external access.
++    //
++    // Using "self." syntax to go through this method will cause immediate deadlock.
++    // This is the intended result. Fix it by accessing the ivar directly.
++    // Great strides have been take to ensure this is safe to do. Plus it's MUCH faster.
++
++    NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++    NSAssert(![self isOnInternalLoggerQueue], @"MUST access ivar directly, NOT via self.* syntax.");
++
++    dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++
++    __block NSTimeInterval result;
++
++    dispatch_sync(globalLoggingQueue, ^{
++        dispatch_sync(self.loggerQueue, ^{
++            result = _saveInterval;
++        });
++    });
++
++    return result;
++}
++
++- (void)setSaveInterval:(NSTimeInterval)interval {
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            // C99 recommended floating point comparison macro
++            // Read: isLessThanOrGreaterThan(floatA, floatB)
++
++            if (/* saveInterval != interval */ islessgreater(_saveInterval, interval)) {
++                _saveInterval = interval;
++
++                // There are several cases we need to handle here.
++                //
++                // 1. If the saveInterval was previously enabled and it just got disabled,
++                //    then we need to stop the saveTimer. (And we might as well release it.)
++                //
++                // 2. If the saveInterval was previously disabled and it just got enabled,
++                //    then we need to setup the saveTimer. (Plus we might need to do an immediate save.)
++                //
++                // 3. If the saveInterval increased, then we need to reset the timer so that it fires at the later date.
++                //
++                // 4. If the saveInterval decreased, then we need to reset the timer so that it fires at an earlier date.
++                //    (Plus we might need to do an immediate save.)
++
++                if (_saveInterval > 0.0) {
++                    if (_saveTimer == NULL) {
++                        // Handles #2
++                        //
++                        // Since the saveTimer uses the unsavedTime to calculate it's first fireDate,
++                        // if a save is needed the timer will fire immediately.
++
++                        [self createSuspendedSaveTimer];
++                        [self updateAndResumeSaveTimer];
++                    } else {
++                        // Handles #3
++                        // Handles #4
++                        //
++                        // Since the saveTimer uses the unsavedTime to calculate it's first fireDate,
++                        // if a save is needed the timer will fire immediately.
++
++                        [self updateAndResumeSaveTimer];
++                    }
++                } else if (_saveTimer) {
++                    // Handles #1
++
++                    [self destroySaveTimer];
++                }
++            }
++        }
++    };
++
++    // The design of the setter logic below is taken from the DDAbstractLogger implementation.
++    // For documentation please refer to the DDAbstractLogger implementation.
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++        NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++
++        dispatch_async(globalLoggingQueue, ^{
++            dispatch_async(self.loggerQueue, block);
++        });
++    }
++}
++
++- (NSTimeInterval)maxAge {
++    // The design of this method is taken from the DDAbstractLogger implementation.
++    // For extensive documentation please refer to the DDAbstractLogger implementation.
++
++    // Note: The internal implementation MUST access the colorsEnabled variable directly,
++    // This method is designed explicitly for external access.
++    //
++    // Using "self." syntax to go through this method will cause immediate deadlock.
++    // This is the intended result. Fix it by accessing the ivar directly.
++    // Great strides have been take to ensure this is safe to do. Plus it's MUCH faster.
++
++    NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++    NSAssert(![self isOnInternalLoggerQueue], @"MUST access ivar directly, NOT via self.* syntax.");
++
++    dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++
++    __block NSTimeInterval result;
++
++    dispatch_sync(globalLoggingQueue, ^{
++        dispatch_sync(self.loggerQueue, ^{
++            result = _maxAge;
++        });
++    });
++
++    return result;
++}
++
++- (void)setMaxAge:(NSTimeInterval)interval {
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            // C99 recommended floating point comparison macro
++            // Read: isLessThanOrGreaterThan(floatA, floatB)
++
++            if (/* maxAge != interval */ islessgreater(_maxAge, interval)) {
++                NSTimeInterval oldMaxAge = _maxAge;
++                NSTimeInterval newMaxAge = interval;
++
++                _maxAge = interval;
++
++                // There are several cases we need to handle here.
++                //
++                // 1. If the maxAge was previously enabled and it just got disabled,
++                //    then we need to stop the deleteTimer. (And we might as well release it.)
++                //
++                // 2. If the maxAge was previously disabled and it just got enabled,
++                //    then we need to setup the deleteTimer. (Plus we might need to do an immediate delete.)
++                //
++                // 3. If the maxAge was increased,
++                //    then we don't need to do anything.
++                //
++                // 4. If the maxAge was decreased,
++                //    then we should do an immediate delete.
++
++                BOOL shouldDeleteNow = NO;
++
++                if (oldMaxAge > 0.0) {
++                    if (newMaxAge <= 0.0) {
++                        // Handles #1
++
++                        [self destroyDeleteTimer];
++                    } else if (oldMaxAge > newMaxAge) {
++                        // Handles #4
++                        shouldDeleteNow = YES;
++                    }
++                } else if (newMaxAge > 0.0) {
++                    // Handles #2
++                    shouldDeleteNow = YES;
++                }
++
++                if (shouldDeleteNow) {
++                    [self performDelete];
++
++                    if (_deleteTimer) {
++                        [self updateDeleteTimer];
++                    } else {
++                        [self createAndStartDeleteTimer];
++                    }
++                }
++            }
++        }
++    };
++
++    // The design of the setter logic below is taken from the DDAbstractLogger implementation.
++    // For documentation please refer to the DDAbstractLogger implementation.
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++        NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++
++        dispatch_async(globalLoggingQueue, ^{
++            dispatch_async(self.loggerQueue, block);
++        });
++    }
++}
++
++- (NSTimeInterval)deleteInterval {
++    // The design of this method is taken from the DDAbstractLogger implementation.
++    // For extensive documentation please refer to the DDAbstractLogger implementation.
++
++    // Note: The internal implementation MUST access the colorsEnabled variable directly,
++    // This method is designed explicitly for external access.
++    //
++    // Using "self." syntax to go through this method will cause immediate deadlock.
++    // This is the intended result. Fix it by accessing the ivar directly.
++    // Great strides have been take to ensure this is safe to do. Plus it's MUCH faster.
++
++    NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++    NSAssert(![self isOnInternalLoggerQueue], @"MUST access ivar directly, NOT via self.* syntax.");
++
++    dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++
++    __block NSTimeInterval result;
++
++    dispatch_sync(globalLoggingQueue, ^{
++        dispatch_sync(self.loggerQueue, ^{
++            result = _deleteInterval;
++        });
++    });
++
++    return result;
++}
++
++- (void)setDeleteInterval:(NSTimeInterval)interval {
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            // C99 recommended floating point comparison macro
++            // Read: isLessThanOrGreaterThan(floatA, floatB)
++
++            if (/* deleteInterval != interval */ islessgreater(_deleteInterval, interval)) {
++                _deleteInterval = interval;
++
++                // There are several cases we need to handle here.
++                //
++                // 1. If the deleteInterval was previously enabled and it just got disabled,
++                //    then we need to stop the deleteTimer. (And we might as well release it.)
++                //
++                // 2. If the deleteInterval was previously disabled and it just got enabled,
++                //    then we need to setup the deleteTimer. (Plus we might need to do an immediate delete.)
++                //
++                // 3. If the deleteInterval increased, then we need to reset the timer so that it fires at the later date.
++                //
++                // 4. If the deleteInterval decreased, then we need to reset the timer so that it fires at an earlier date.
++                //    (Plus we might need to do an immediate delete.)
++
++                if (_deleteInterval > 0.0) {
++                    if (_deleteTimer == NULL) {
++                        // Handles #2
++                        //
++                        // Since the deleteTimer uses the lastDeleteTime to calculate it's first fireDate,
++                        // if a delete is needed the timer will fire immediately.
++
++                        [self createAndStartDeleteTimer];
++                    } else {
++                        // Handles #3
++                        // Handles #4
++                        //
++                        // Since the deleteTimer uses the lastDeleteTime to calculate it's first fireDate,
++                        // if a save is needed the timer will fire immediately.
++
++                        [self updateDeleteTimer];
++                    }
++                } else if (_deleteTimer) {
++                    // Handles #1
++
++                    [self destroyDeleteTimer];
++                }
++            }
++        }
++    };
++
++    // The design of the setter logic below is taken from the DDAbstractLogger implementation.
++    // For documentation please refer to the DDAbstractLogger implementation.
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++        NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++
++        dispatch_async(globalLoggingQueue, ^{
++            dispatch_async(self.loggerQueue, block);
++        });
++    }
++}
++
++- (BOOL)deleteOnEverySave {
++    // The design of this method is taken from the DDAbstractLogger implementation.
++    // For extensive documentation please refer to the DDAbstractLogger implementation.
++
++    // Note: The internal implementation MUST access the colorsEnabled variable directly,
++    // This method is designed explicitly for external access.
++    //
++    // Using "self." syntax to go through this method will cause immediate deadlock.
++    // This is the intended result. Fix it by accessing the ivar directly.
++    // Great strides have been take to ensure this is safe to do. Plus it's MUCH faster.
++
++    NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++    NSAssert(![self isOnInternalLoggerQueue], @"MUST access ivar directly, NOT via self.* syntax.");
++
++    dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++
++    __block BOOL result;
++
++    dispatch_sync(globalLoggingQueue, ^{
++        dispatch_sync(self.loggerQueue, ^{
++            result = _deleteOnEverySave;
++        });
++    });
++
++    return result;
++}
++
++- (void)setDeleteOnEverySave:(BOOL)flag {
++    dispatch_block_t block = ^{
++        _deleteOnEverySave = flag;
++    };
++
++    // The design of the setter logic below is taken from the DDAbstractLogger implementation.
++    // For documentation please refer to the DDAbstractLogger implementation.
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++        NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++
++        dispatch_async(globalLoggingQueue, ^{
++            dispatch_async(self.loggerQueue, block);
++        });
++    }
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Public API
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (void)savePendingLogEntries {
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            [self performSaveAndSuspendSaveTimer];
++        }
++    };
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_async(self.loggerQueue, block);
++    }
++}
++
++- (void)deleteOldLogEntries {
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            [self performDelete];
++        }
++    };
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_async(self.loggerQueue, block);
++    }
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark DDLogger
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (void)didAddLogger {
++    // If you override me be sure to invoke [super didAddLogger];
++
++    [self createSuspendedSaveTimer];
++
++    [self createAndStartDeleteTimer];
++}
++
++- (void)willRemoveLogger {
++    // If you override me be sure to invoke [super willRemoveLogger];
++
++    [self performSaveAndSuspendSaveTimer];
++
++    [self destroySaveTimer];
++    [self destroyDeleteTimer];
++}
++
++- (void)logMessage:(DDLogMessage *)logMessage {
++    if ([self db_log:logMessage]) {
++        BOOL firstUnsavedEntry = (++_unsavedCount == 1);
++
++        if ((_unsavedCount >= _saveThreshold) && (_saveThreshold > 0)) {
++            [self performSaveAndSuspendSaveTimer];
++        } else if (firstUnsavedEntry) {
++            _unsavedTime = dispatch_time(DISPATCH_TIME_NOW, 0);
++            [self updateAndResumeSaveTimer];
++        }
++    }
++}
++
++- (void)flush {
++    // This method is invoked by DDLog's flushLog method.
++    //
++    // It is called automatically when the application quits,
++    // or if the developer invokes DDLog's flushLog method prior to crashing or something.
++
++    [self performSaveAndSuspendSaveTimer];
++}
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/DDAssertMacros.h b/Pods/CocoaLumberjack/Classes/DDAssertMacros.h
+new file mode 100644
+index 0000000..870d31f
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDAssertMacros.h
+@@ -0,0 +1,26 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++/**
++ * NSAsset replacement that will output a log message even when assertions are disabled.
++ **/
++#define DDAssert(condition, frmt, ...)                                                \
++        if (!(condition)) {                                                           \
++            NSString *description = [NSString stringWithFormat:frmt, ## __VA_ARGS__]; \
++            DDLogError(@"%@", description);                                           \
++            NSAssert(NO, description);                                                \
++        }
++#define DDAssertCondition(condition) DDAssert(condition, @"Condition not satisfied: %s", #condition)
++
+diff --git a/Pods/CocoaLumberjack/Classes/DDFileLogger.h b/Pods/CocoaLumberjack/Classes/DDFileLogger.h
+new file mode 100644
+index 0000000..f0bfdb6
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDFileLogger.h
+@@ -0,0 +1,487 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++// Disable legacy macros
++#ifndef DD_LEGACY_MACROS
++    #define DD_LEGACY_MACROS 0
++#endif
++
++#import "DDLog.h"
++
++@class DDLogFileInfo;
++
++/**
++ * This class provides a logger to write log statements to a file.
++ **/
++
++
++// Default configuration and safety/sanity values.
++//
++// maximumFileSize         -> kDDDefaultLogMaxFileSize
++// rollingFrequency        -> kDDDefaultLogRollingFrequency
++// maximumNumberOfLogFiles -> kDDDefaultLogMaxNumLogFiles
++// logFilesDiskQuota       -> kDDDefaultLogFilesDiskQuota
++//
++// You should carefully consider the proper configuration values for your application.
++
++extern unsigned long long const kDDDefaultLogMaxFileSize;
++extern NSTimeInterval     const kDDDefaultLogRollingFrequency;
++extern NSUInteger         const kDDDefaultLogMaxNumLogFiles;
++extern unsigned long long const kDDDefaultLogFilesDiskQuota;
++
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++/**
++ *  The LogFileManager protocol is designed to allow you to control all aspects of your log files.
++ *
++ *  The primary purpose of this is to allow you to do something with the log files after they have been rolled.
++ *  Perhaps you want to compress them to save disk space.
++ *  Perhaps you want to upload them to an FTP server.
++ *  Perhaps you want to run some analytics on the file.
++ *
++ *  A default LogFileManager is, of course, provided.
++ *  The default LogFileManager simply deletes old log files according to the maximumNumberOfLogFiles property.
++ *
++ *  This protocol provides various methods to fetch the list of log files.
++ *
++ *  There are two variants: sorted and unsorted.
++ *  If sorting is not necessary, the unsorted variant is obviously faster.
++ *  The sorted variant will return an array sorted by when the log files were created,
++ *  with the most recently created log file at index 0, and the oldest log file at the end of the array.
++ *
++ *  You can fetch only the log file paths (full path including name), log file names (name only),
++ *  or an array of `DDLogFileInfo` objects.
++ *  The `DDLogFileInfo` class is documented below, and provides a handy wrapper that
++ *  gives you easy access to various file attributes such as the creation date or the file size.
++ */
++@protocol DDLogFileManager <NSObject>
++@required
++
++// Public properties
++
++/**
++ * The maximum number of archived log files to keep on disk.
++ * For example, if this property is set to 3,
++ * then the LogFileManager will only keep 3 archived log files (plus the current active log file) on disk.
++ * Once the active log file is rolled/archived, then the oldest of the existing 3 rolled/archived log files is deleted.
++ *
++ * You may optionally disable this option by setting it to zero.
++ **/
++@property (readwrite, assign, atomic) NSUInteger maximumNumberOfLogFiles;
++
++/**
++ * The maximum space that logs can take. On rolling logfile all old logfiles that exceed logFilesDiskQuota will
++ * be deleted.
++ *
++ * You may optionally disable this option by setting it to zero.
++ **/
++@property (readwrite, assign, atomic) unsigned long long logFilesDiskQuota;
++
++// Public methods
++
++/**
++ *  Returns the logs directory (path)
++ */
++- (NSString *)logsDirectory;
++
++/**
++ * Returns an array of `NSString` objects,
++ * each of which is the filePath to an existing log file on disk.
++ **/
++- (NSArray *)unsortedLogFilePaths;
++
++/**
++ * Returns an array of `NSString` objects,
++ * each of which is the fileName of an existing log file on disk.
++ **/
++- (NSArray *)unsortedLogFileNames;
++
++/**
++ * Returns an array of `DDLogFileInfo` objects,
++ * each representing an existing log file on disk,
++ * and containing important information about the log file such as it's modification date and size.
++ **/
++- (NSArray *)unsortedLogFileInfos;
++
++/**
++ * Just like the `unsortedLogFilePaths` method, but sorts the array.
++ * The items in the array are sorted by creation date.
++ * The first item in the array will be the most recently created log file.
++ **/
++- (NSArray *)sortedLogFilePaths;
++
++/**
++ * Just like the `unsortedLogFileNames` method, but sorts the array.
++ * The items in the array are sorted by creation date.
++ * The first item in the array will be the most recently created log file.
++ **/
++- (NSArray *)sortedLogFileNames;
++
++/**
++ * Just like the `unsortedLogFileInfos` method, but sorts the array.
++ * The items in the array are sorted by creation date.
++ * The first item in the array will be the most recently created log file.
++ **/
++- (NSArray *)sortedLogFileInfos;
++
++// Private methods (only to be used by DDFileLogger)
++
++/**
++ * Generates a new unique log file path, and creates the corresponding log file.
++ **/
++- (NSString *)createNewLogFile;
++
++@optional
++
++// Notifications from DDFileLogger
++
++/**
++ *  Called when a log file was archieved
++ */
++- (void)didArchiveLogFile:(NSString *)logFilePath;
++
++/**
++ *  Called when the roll action was executed and the log was archieved
++ */
++- (void)didRollAndArchiveLogFile:(NSString *)logFilePath;
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++/**
++ * Default log file manager.
++ *
++ * All log files are placed inside the logsDirectory.
++ * If a specific logsDirectory isn't specified, the default directory is used.
++ * On Mac, this is in `~/Library/Logs/<Application Name>`.
++ * On iPhone, this is in `~/Library/Caches/Logs`.
++ *
++ * Log files are named `"<bundle identifier> <date> <time>.log"`
++ * Example: `com.organization.myapp 2013-12-03 17-14.log`
++ *
++ * Archived log files are automatically deleted according to the `maximumNumberOfLogFiles` property.
++ **/
++@interface DDLogFileManagerDefault : NSObject <DDLogFileManager>
++
++/**
++ *  Default initializer
++ */
++- (instancetype)init;
++
++/**
++ *  Designated initialized, requires the logs directory
++ */
++- (instancetype)initWithLogsDirectory:(NSString *)logsDirectory NS_DESIGNATED_INITIALIZER;
++
++#if TARGET_OS_IPHONE
++/*
++ * Calling this constructor you can override the default "automagically" chosen NSFileProtection level.
++ * Useful if you are writing a command line utility / CydiaSubstrate addon for iOS that has no NSBundle
++ * or like SpringBoard no BackgroundModes key in the NSBundle:
++ *    iPhone:~ root# cycript -p SpringBoard
++ *    cy# [NSBundle mainBundle]
++ *    #"NSBundle </System/Library/CoreServices/SpringBoard.app> (loaded)"
++ *    cy# [[NSBundle mainBundle] objectForInfoDictionaryKey:@"UIBackgroundModes"];
++ *    null
++ *    cy#
++ **/
++- (instancetype)initWithLogsDirectory:(NSString *)logsDirectory defaultFileProtectionLevel:(NSString *)fileProtectionLevel;
++#endif
++
++/*
++ * Methods to override.
++ *
++ * Log files are named `"<bundle identifier> <date> <time>.log"`
++ * Example: `com.organization.myapp 2013-12-03 17-14.log`
++ *
++ * If you wish to change default filename, you can override following two methods.
++ * - `newLogFileName` method would be called on new logfile creation.
++ * - `isLogFile:` method would be called to filter logfiles from all other files in logsDirectory.
++ *   You have to parse given filename and return YES if it is logFile.
++ *
++ * **NOTE**
++ * `newLogFileName` returns filename. If appropriate file already exists, number would be added
++ * to filename before extension. You have to handle this case in isLogFile: method.
++ *
++ * Example:
++ * - newLogFileName returns `"com.organization.myapp 2013-12-03.log"`,
++ *   file `"com.organization.myapp 2013-12-03.log"` would be created.
++ * - after some time `"com.organization.myapp 2013-12-03.log"` is archived
++ * - newLogFileName again returns `"com.organization.myapp 2013-12-03.log"`,
++ *   file `"com.organization.myapp 2013-12-03 2.log"` would be created.
++ * - after some time `"com.organization.myapp 2013-12-03 1.log"` is archived
++ * - newLogFileName again returns `"com.organization.myapp 2013-12-03.log"`,
++ *   file `"com.organization.myapp 2013-12-03 3.log"` would be created.
++ **/
++
++/**
++ * Generates log file name with default format `"<bundle identifier> <date> <time>.log"`
++ * Example: `MobileSafari 2013-12-03 17-14.log`
++ *
++ * You can change it by overriding `newLogFileName` and `isLogFile:` methods.
++ **/
++@property (readonly, copy) NSString *newLogFileName;
++
++/**
++ * Default log file name is `"<bundle identifier> <date> <time>.log"`.
++ * Example: `MobileSafari 2013-12-03 17-14.log`
++ *
++ * You can change it by overriding `newLogFileName` and `isLogFile:` methods.
++ **/
++- (BOOL)isLogFile:(NSString *)fileName;
++
++/* Inherited from DDLogFileManager protocol:
++
++   @property (readwrite, assign, atomic) NSUInteger maximumNumberOfLogFiles;
++   @property (readwrite, assign, atomic) NSUInteger logFilesDiskQuota;
++
++   - (NSString *)logsDirectory;
++
++   - (NSArray *)unsortedLogFilePaths;
++   - (NSArray *)unsortedLogFileNames;
++   - (NSArray *)unsortedLogFileInfos;
++
++   - (NSArray *)sortedLogFilePaths;
++   - (NSArray *)sortedLogFileNames;
++   - (NSArray *)sortedLogFileInfos;
++
++ */
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++/**
++ * Most users will want file log messages to be prepended with the date and time.
++ * Rather than forcing the majority of users to write their own formatter,
++ * we will supply a logical default formatter.
++ * Users can easily replace this formatter with their own by invoking the `setLogFormatter:` method.
++ * It can also be removed by calling `setLogFormatter:`, and passing a nil parameter.
++ *
++ * In addition to the convenience of having a logical default formatter,
++ * it will also provide a template that makes it easy for developers to copy and change.
++ **/
++@interface DDLogFileFormatterDefault : NSObject <DDLogFormatter>
++
++/**
++ *  Default initializer
++ */
++- (instancetype)init;
++
++/**
++ *  Designated initializer, requires a date formatter
++ */
++- (instancetype)initWithDateFormatter:(NSDateFormatter *)dateFormatter NS_DESIGNATED_INITIALIZER;
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++/**
++ *  The standard implementation for a file logger
++ */
++@interface DDFileLogger : DDAbstractLogger <DDLogger>
++
++/**
++ *  Default initializer
++ */
++- (instancetype)init;
++
++/**
++ *  Designated initializer, requires a `DDLogFileManager` instance
++ */
++- (instancetype)initWithLogFileManager:(id <DDLogFileManager>)logFileManager NS_DESIGNATED_INITIALIZER;
++
++/**
++ * Log File Rolling:
++ *
++ * `maximumFileSize`:
++ *   The approximate maximum size to allow log files to grow.
++ *   If a log file is larger than this value after a log statement is appended,
++ *   then the log file is rolled.
++ *
++ * `rollingFrequency`
++ *   How often to roll the log file.
++ *   The frequency is given as an `NSTimeInterval`, which is a double that specifies the interval in seconds.
++ *   Once the log file gets to be this old, it is rolled.
++ *
++ * Both the `maximumFileSize` and the `rollingFrequency` are used to manage rolling.
++ * Whichever occurs first will cause the log file to be rolled.
++ *
++ * For example:
++ * The `rollingFrequency` is 24 hours,
++ * but the log file surpasses the `maximumFileSize` after only 20 hours.
++ * The log file will be rolled at that 20 hour mark.
++ * A new log file will be created, and the 24 hour timer will be restarted.
++ *
++ * You may optionally disable rolling due to filesize by setting `maximumFileSize` to zero.
++ * If you do so, rolling is based solely on `rollingFrequency`.
++ *
++ * You may optionally disable rolling due to time by setting `rollingFrequency` to zero (or any non-positive number).
++ * If you do so, rolling is based solely on `maximumFileSize`.
++ *
++ * If you disable both `maximumFileSize` and `rollingFrequency`, then the log file won't ever be rolled.
++ * This is strongly discouraged.
++ **/
++@property (readwrite, assign) unsigned long long maximumFileSize;
++
++/**
++ *  See description for `maximumFileSize`
++ */
++@property (readwrite, assign) NSTimeInterval rollingFrequency;
++
++/**
++ *  See description for `maximumFileSize`
++ */
++@property (readwrite, assign, atomic) BOOL doNotReuseLogFiles;
++
++/**
++ * The DDLogFileManager instance can be used to retrieve the list of log files,
++ * and configure the maximum number of archived log files to keep.
++ *
++ * @see DDLogFileManager.maximumNumberOfLogFiles
++ **/
++@property (strong, nonatomic, readonly) id <DDLogFileManager> logFileManager;
++
++/**
++ * When using a custom formatter you can set the `logMessage` method not to append
++ * `\n` character after each output. This allows for some greater flexibility with
++ * custom formatters. Default value is YES.
++ **/
++@property (nonatomic, readwrite, assign) BOOL automaticallyAppendNewlineForCustomFormatters;
++
++/**
++ *  You can optionally force the current log file to be rolled with this method.
++ *  CompletionBlock will be called on main queue.
++ */
++- (void)rollLogFileWithCompletionBlock:(void (^)())completionBlock;
++
++/**
++ *  Method is deprecated.
++ *  @deprecated Use `rollLogFileWithCompletionBlock:` method instead.
++ */
++- (void)rollLogFile __attribute((deprecated));
++
++// Inherited from DDAbstractLogger
++
++// - (id <DDLogFormatter>)logFormatter;
++// - (void)setLogFormatter:(id <DDLogFormatter>)formatter;
++
++/**
++ * Returns the log file that should be used.
++ * If there is an existing log file that is suitable,
++ * within the constraints of `maximumFileSize` and `rollingFrequency`, then it is returned.
++ *
++ * Otherwise a new file is created and returned.
++ **/
++- (DDLogFileInfo *)currentLogFileInfo;
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++/**
++ * `DDLogFileInfo` is a simple class that provides access to various file attributes.
++ * It provides good performance as it only fetches the information if requested,
++ * and it caches the information to prevent duplicate fetches.
++ *
++ * It was designed to provide quick snapshots of the current state of log files,
++ * and to help sort log files in an array.
++ *
++ * This class does not monitor the files, or update it's cached attribute values if the file changes on disk.
++ * This is not what the class was designed for.
++ *
++ * If you absolutely must get updated values,
++ * you can invoke the reset method which will clear the cache.
++ **/
++@interface DDLogFileInfo : NSObject
++
++@property (strong, nonatomic, readonly) NSString *filePath;
++@property (strong, nonatomic, readonly) NSString *fileName;
++
++@property (strong, nonatomic, readonly) NSDictionary *fileAttributes;
++
++@property (strong, nonatomic, readonly) NSDate *creationDate;
++@property (strong, nonatomic, readonly) NSDate *modificationDate;
++
++@property (nonatomic, readonly) unsigned long long fileSize;
++
++@property (nonatomic, readonly) NSTimeInterval age;
++
++@property (nonatomic, readwrite) BOOL isArchived;
++
+++ (instancetype)logFileWithPath:(NSString *)filePath;
++
++- (instancetype)init NS_UNAVAILABLE;
++- (instancetype)initWithFilePath:(NSString *)filePath NS_DESIGNATED_INITIALIZER;
++
++- (void)reset;
++- (void)renameFile:(NSString *)newFileName;
++
++#if TARGET_IPHONE_SIMULATOR
++
++// So here's the situation.
++// Extended attributes are perfect for what we're trying to do here (marking files as archived).
++// This is exactly what extended attributes were designed for.
++//
++// But Apple screws us over on the simulator.
++// Everytime you build-and-go, they copy the application into a new folder on the hard drive,
++// and as part of the process they strip extended attributes from our log files.
++// Normally, a copy of a file preserves extended attributes.
++// So obviously Apple has gone to great lengths to piss us off.
++//
++// Thus we use a slightly different tactic for marking log files as archived in the simulator.
++// That way it "just works" and there's no confusion when testing.
++//
++// The difference in method names is indicative of the difference in functionality.
++// On the simulator we add an attribute by appending a filename extension.
++//
++// For example:
++// "mylog.txt" -> "mylog.archived.txt"
++// "mylog"     -> "mylog.archived"
++
++- (BOOL)hasExtensionAttributeWithName:(NSString *)attrName;
++
++- (void)addExtensionAttributeWithName:(NSString *)attrName;
++- (void)removeExtensionAttributeWithName:(NSString *)attrName;
++
++#else /* if TARGET_IPHONE_SIMULATOR */
++
++// Normal use of extended attributes used everywhere else,
++// such as on Macs and on iPhone devices.
++
++- (BOOL)hasExtendedAttributeWithName:(NSString *)attrName;
++
++- (void)addExtendedAttributeWithName:(NSString *)attrName;
++- (void)removeExtendedAttributeWithName:(NSString *)attrName;
++
++#endif /* if TARGET_IPHONE_SIMULATOR */
++
++- (NSComparisonResult)reverseCompareByCreationDate:(DDLogFileInfo *)another;
++- (NSComparisonResult)reverseCompareByModificationDate:(DDLogFileInfo *)another;
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/DDFileLogger.m b/Pods/CocoaLumberjack/Classes/DDFileLogger.m
+new file mode 100644
+index 0000000..1b78578
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDFileLogger.m
+@@ -0,0 +1,1484 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++#import "DDFileLogger.h"
++
++#import <unistd.h>
++#import <sys/attr.h>
++#import <sys/xattr.h>
++#import <libkern/OSAtomic.h>
++
++#if !__has_feature(objc_arc)
++#error This file must be compiled with ARC. Use -fobjc-arc flag (or convert project to ARC).
++#endif
++
++// We probably shouldn't be using DDLog() statements within the DDLog implementation.
++// But we still want to leave our log statements for any future debugging,
++// and to allow other developers to trace the implementation (which is a great learning tool).
++//
++// So we use primitive logging macros around NSLog.
++// We maintain the NS prefix on the macros to be explicit about the fact that we're using NSLog.
++
++#ifndef DD_NSLOG_LEVEL
++    #define DD_NSLOG_LEVEL 2
++#endif
++
++#define NSLogError(frmt, ...)    do{ if(DD_NSLOG_LEVEL >= 1) NSLog((frmt), ##__VA_ARGS__); } while(0)
++#define NSLogWarn(frmt, ...)     do{ if(DD_NSLOG_LEVEL >= 2) NSLog((frmt), ##__VA_ARGS__); } while(0)
++#define NSLogInfo(frmt, ...)     do{ if(DD_NSLOG_LEVEL >= 3) NSLog((frmt), ##__VA_ARGS__); } while(0)
++#define NSLogDebug(frmt, ...)    do{ if(DD_NSLOG_LEVEL >= 4) NSLog((frmt), ##__VA_ARGS__); } while(0)
++#define NSLogVerbose(frmt, ...)  do{ if(DD_NSLOG_LEVEL >= 5) NSLog((frmt), ##__VA_ARGS__); } while(0)
++
++
++#if TARGET_OS_IPHONE
++BOOL doesAppRunInBackground(void);
++#endif
++
++unsigned long long const kDDDefaultLogMaxFileSize      = 1024 * 1024;      // 1 MB
++NSTimeInterval     const kDDDefaultLogRollingFrequency = 60 * 60 * 24;     // 24 Hours
++NSUInteger         const kDDDefaultLogMaxNumLogFiles   = 5;                // 5 Files
++unsigned long long const kDDDefaultLogFilesDiskQuota   = 20 * 1024 * 1024; // 20 MB
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++@interface DDLogFileManagerDefault () {
++    NSUInteger _maximumNumberOfLogFiles;
++    unsigned long long _logFilesDiskQuota;
++    NSString *_logsDirectory;
++#if TARGET_OS_IPHONE
++    NSString *_defaultFileProtectionLevel;
++#endif
++}
++
++- (void)deleteOldLogFiles;
++- (NSString *)defaultLogsDirectory;
++
++@end
++
++@implementation DDLogFileManagerDefault
++
++@synthesize maximumNumberOfLogFiles = _maximumNumberOfLogFiles;
++@synthesize logFilesDiskQuota = _logFilesDiskQuota;
++
++
++- (instancetype)init {
++    return [self initWithLogsDirectory:nil];
++}
++
++- (instancetype)initWithLogsDirectory:(NSString *)aLogsDirectory {
++    if ((self = [super init])) {
++        _maximumNumberOfLogFiles = kDDDefaultLogMaxNumLogFiles;
++        _logFilesDiskQuota = kDDDefaultLogFilesDiskQuota;
++
++        if (aLogsDirectory) {
++            _logsDirectory = [aLogsDirectory copy];
++        } else {
++            _logsDirectory = [[self defaultLogsDirectory] copy];
++        }
++
++        NSKeyValueObservingOptions kvoOptions = NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew;
++
++        [self addObserver:self forKeyPath:NSStringFromSelector(@selector(maximumNumberOfLogFiles)) options:kvoOptions context:nil];
++        [self addObserver:self forKeyPath:NSStringFromSelector(@selector(logFilesDiskQuota)) options:kvoOptions context:nil];
++
++        NSLogVerbose(@"DDFileLogManagerDefault: logsDirectory:\n%@", [self logsDirectory]);
++        NSLogVerbose(@"DDFileLogManagerDefault: sortedLogFileNames:\n%@", [self sortedLogFileNames]);
++    }
++
++    return self;
++}
++
+++ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey
++{
++    BOOL automatic = NO;
++    if ([theKey isEqualToString:@"maximumNumberOfLogFiles"] || [theKey isEqualToString:@"logFilesDiskQuota"]) {
++        automatic = NO;
++    } else {
++        automatic = [super automaticallyNotifiesObserversForKey:theKey];
++    }
++    
++    return automatic;
++}
++
++#if TARGET_OS_IPHONE
++- (instancetype)initWithLogsDirectory:(NSString *)logsDirectory defaultFileProtectionLevel:(NSString *)fileProtectionLevel {
++    if ((self = [self initWithLogsDirectory:logsDirectory])) {
++        if ([fileProtectionLevel isEqualToString:NSFileProtectionNone] ||
++            [fileProtectionLevel isEqualToString:NSFileProtectionComplete] ||
++            [fileProtectionLevel isEqualToString:NSFileProtectionCompleteUnlessOpen] ||
++            [fileProtectionLevel isEqualToString:NSFileProtectionCompleteUntilFirstUserAuthentication]) {
++            _defaultFileProtectionLevel = fileProtectionLevel;
++        }
++    }
++
++    return self;
++}
++
++#endif
++
++- (void)dealloc {
++    // try-catch because the observer might be removed or never added. In this case, removeObserver throws and exception
++    @try {
++        [self removeObserver:self forKeyPath:NSStringFromSelector(@selector(maximumNumberOfLogFiles))];
++        [self removeObserver:self forKeyPath:NSStringFromSelector(@selector(logFilesDiskQuota))];
++    } @catch (NSException *exception) {
++    }
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Configuration
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (void)observeValueForKeyPath:(NSString *)keyPath
++                      ofObject:(id)object
++                        change:(NSDictionary *)change
++                       context:(void *)context {
++    NSNumber *old = change[NSKeyValueChangeOldKey];
++    NSNumber *new = change[NSKeyValueChangeNewKey];
++
++    if ([old isEqual:new]) {
++        // No change in value - don't bother with any processing.
++        return;
++    }
++
++    if ([keyPath isEqualToString:NSStringFromSelector(@selector(maximumNumberOfLogFiles))] ||
++        [keyPath isEqualToString:NSStringFromSelector(@selector(logFilesDiskQuota))]) {
++        NSLogInfo(@"DDFileLogManagerDefault: Responding to configuration change: %@", keyPath);
++
++        dispatch_async([DDLog loggingQueue], ^{ @autoreleasepool {
++                                                    [self deleteOldLogFiles];
++                                                } });
++    }
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark File Deleting
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++/**
++ * Deletes archived log files that exceed the maximumNumberOfLogFiles or logFilesDiskQuota configuration values.
++ **/
++- (void)deleteOldLogFiles {
++    NSLogVerbose(@"DDLogFileManagerDefault: deleteOldLogFiles");
++
++    NSArray *sortedLogFileInfos = [self sortedLogFileInfos];
++
++    NSUInteger firstIndexToDelete = NSNotFound;
++
++    const unsigned long long diskQuota = self.logFilesDiskQuota;
++    const NSUInteger maxNumLogFiles = self.maximumNumberOfLogFiles;
++
++    if (diskQuota) {
++        unsigned long long used = 0;
++
++        for (NSUInteger i = 0; i < sortedLogFileInfos.count; i++) {
++            DDLogFileInfo *info = sortedLogFileInfos[i];
++            used += info.fileSize;
++
++            if (used > diskQuota) {
++                firstIndexToDelete = i;
++                break;
++            }
++        }
++    }
++
++    if (maxNumLogFiles) {
++        if (firstIndexToDelete == NSNotFound) {
++            firstIndexToDelete = maxNumLogFiles;
++        } else {
++            firstIndexToDelete = MIN(firstIndexToDelete, maxNumLogFiles);
++        }
++    }
++
++    if (firstIndexToDelete == 0) {
++        // Do we consider the first file?
++        // We are only supposed to be deleting archived files.
++        // In most cases, the first file is likely the log file that is currently being written to.
++        // So in most cases, we do not want to consider this file for deletion.
++
++        if (sortedLogFileInfos.count > 0) {
++            DDLogFileInfo *logFileInfo = sortedLogFileInfos[0];
++
++            if (!logFileInfo.isArchived) {
++                // Don't delete active file.
++                ++firstIndexToDelete;
++            }
++        }
++    }
++
++    if (firstIndexToDelete != NSNotFound) {
++        // removing all logfiles starting with firstIndexToDelete
++
++        for (NSUInteger i = firstIndexToDelete; i < sortedLogFileInfos.count; i++) {
++            DDLogFileInfo *logFileInfo = sortedLogFileInfos[i];
++
++            NSLogInfo(@"DDLogFileManagerDefault: Deleting file: %@", logFileInfo.fileName);
++
++            [[NSFileManager defaultManager] removeItemAtPath:logFileInfo.filePath error:nil];
++        }
++    }
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Log Files
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++/**
++ * Returns the path to the default logs directory.
++ * If the logs directory doesn't exist, this method automatically creates it.
++ **/
++- (NSString *)defaultLogsDirectory {
++#if TARGET_OS_IPHONE
++    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
++    NSString *baseDir = paths.firstObject;
++    NSString *logsDirectory = [baseDir stringByAppendingPathComponent:@"Logs"];
++
++#else
++    NSString *appName = [[NSProcessInfo processInfo] processName];
++    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
++    NSString *basePath = ([paths count] > 0) ? paths[0] : NSTemporaryDirectory();
++    NSString *logsDirectory = [[basePath stringByAppendingPathComponent:@"Logs"] stringByAppendingPathComponent:appName];
++
++#endif
++
++    return logsDirectory;
++}
++
++- (NSString *)logsDirectory {
++    // We could do this check once, during initalization, and not bother again.
++    // But this way the code continues to work if the directory gets deleted while the code is running.
++
++    if (![[NSFileManager defaultManager] fileExistsAtPath:_logsDirectory]) {
++        NSError *err = nil;
++
++        if (![[NSFileManager defaultManager] createDirectoryAtPath:_logsDirectory
++                                       withIntermediateDirectories:YES
++                                                        attributes:nil
++                                                             error:&err]) {
++            NSLogError(@"DDFileLogManagerDefault: Error creating logsDirectory: %@", err);
++        }
++    }
++
++    return _logsDirectory;
++}
++
++- (BOOL)isLogFile:(NSString *)fileName {
++    NSString *appName = [self applicationName];
++
++    BOOL hasProperPrefix = [fileName hasPrefix:appName];
++    BOOL hasProperSuffix = [fileName hasSuffix:@".log"];
++    BOOL hasProperDate = NO;
++
++    if (hasProperPrefix && hasProperSuffix) {
++        NSUInteger lengthOfMiddle = fileName.length - appName.length - @".log".length;
++
++        // Date string should have at least 16 characters - " 2013-12-03 17-14"
++        if (lengthOfMiddle >= 17) {
++            NSRange range = NSMakeRange(appName.length, lengthOfMiddle);
++
++            NSString *middle = [fileName substringWithRange:range];
++            NSArray *components = [middle componentsSeparatedByString:@" "];
++
++            // When creating logfile if there is existing file with the same name, we append attemp number at the end.
++            // Thats why here we can have three or four components. For details see createNewLogFile method.
++            //
++            // Components:
++            //     "", "2013-12-03", "17-14"
++            // or
++            //     "", "2013-12-03", "17-14", "1"
++            if (components.count == 3 || components.count == 4) {
++                NSString *dateString = [NSString stringWithFormat:@"%@ %@", components[1], components[2]];
++                NSDateFormatter *dateFormatter = [self logFileDateFormatter];
++
++                NSDate *date = [dateFormatter dateFromString:dateString];
++
++                if (date) {
++                    hasProperDate = YES;
++                }
++            }
++        }
++    }
++
++    return (hasProperPrefix && hasProperDate && hasProperSuffix);
++}
++
++- (NSDateFormatter *)logFileDateFormatter {
++    NSMutableDictionary *dictionary = [[NSThread currentThread]
++                                       threadDictionary];
++    NSString *dateFormat = @"yyyy'-'MM'-'dd' 'HH'-'mm'";
++    NSString *key = [NSString stringWithFormat:@"logFileDateFormatter.%@", dateFormat];
++    NSDateFormatter *dateFormatter = dictionary[key];
++
++    if (dateFormatter == nil) {
++        dateFormatter = [[NSDateFormatter alloc] init];
++        [dateFormatter setLocale:[NSLocale localeWithLocaleIdentifier:@"en_US_POSIX"]];
++        [dateFormatter setDateFormat:dateFormat];
++        [dateFormatter setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];
++        dictionary[key] = dateFormatter;
++    }
++
++    return dateFormatter;
++}
++
++- (NSArray *)unsortedLogFilePaths {
++    NSString *logsDirectory = [self logsDirectory];
++    NSArray *fileNames = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:logsDirectory error:nil];
++
++    NSMutableArray *unsortedLogFilePaths = [NSMutableArray arrayWithCapacity:[fileNames count]];
++
++    for (NSString *fileName in fileNames) {
++        // Filter out any files that aren't log files. (Just for extra safety)
++
++    #if TARGET_IPHONE_SIMULATOR
++        // In case of iPhone simulator there can be 'archived' extension. isLogFile:
++        // method knows nothing about it. Thus removing it for this method.
++        //
++        // See full explanation in the header file.
++        NSString *theFileName = [fileName stringByReplacingOccurrencesOfString:@".archived"
++                                                                    withString:@""];
++
++        if ([self isLogFile:theFileName])
++    #else
++
++        if ([self isLogFile:fileName])
++    #endif
++        {
++            NSString *filePath = [logsDirectory stringByAppendingPathComponent:fileName];
++
++            [unsortedLogFilePaths addObject:filePath];
++        }
++    }
++
++    return unsortedLogFilePaths;
++}
++
++- (NSArray *)unsortedLogFileNames {
++    NSArray *unsortedLogFilePaths = [self unsortedLogFilePaths];
++
++    NSMutableArray *unsortedLogFileNames = [NSMutableArray arrayWithCapacity:[unsortedLogFilePaths count]];
++
++    for (NSString *filePath in unsortedLogFilePaths) {
++        [unsortedLogFileNames addObject:[filePath lastPathComponent]];
++    }
++
++    return unsortedLogFileNames;
++}
++
++- (NSArray *)unsortedLogFileInfos {
++    NSArray *unsortedLogFilePaths = [self unsortedLogFilePaths];
++
++    NSMutableArray *unsortedLogFileInfos = [NSMutableArray arrayWithCapacity:[unsortedLogFilePaths count]];
++
++    for (NSString *filePath in unsortedLogFilePaths) {
++        DDLogFileInfo *logFileInfo = [[DDLogFileInfo alloc] initWithFilePath:filePath];
++
++        [unsortedLogFileInfos addObject:logFileInfo];
++    }
++
++    return unsortedLogFileInfos;
++}
++
++- (NSArray *)sortedLogFilePaths {
++    NSArray *sortedLogFileInfos = [self sortedLogFileInfos];
++
++    NSMutableArray *sortedLogFilePaths = [NSMutableArray arrayWithCapacity:[sortedLogFileInfos count]];
++
++    for (DDLogFileInfo *logFileInfo in sortedLogFileInfos) {
++        [sortedLogFilePaths addObject:[logFileInfo filePath]];
++    }
++
++    return sortedLogFilePaths;
++}
++
++- (NSArray *)sortedLogFileNames {
++    NSArray *sortedLogFileInfos = [self sortedLogFileInfos];
++
++    NSMutableArray *sortedLogFileNames = [NSMutableArray arrayWithCapacity:[sortedLogFileInfos count]];
++
++    for (DDLogFileInfo *logFileInfo in sortedLogFileInfos) {
++        [sortedLogFileNames addObject:[logFileInfo fileName]];
++    }
++
++    return sortedLogFileNames;
++}
++
++- (NSArray *)sortedLogFileInfos {
++    return [[self unsortedLogFileInfos] sortedArrayUsingSelector:@selector(reverseCompareByCreationDate:)];
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Creation
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (NSString *)newLogFileName {
++    NSString *appName = [self applicationName];
++
++    NSDateFormatter *dateFormatter = [self logFileDateFormatter];
++    NSString *formattedDate = [dateFormatter stringFromDate:[NSDate date]];
++
++    return [NSString stringWithFormat:@"%@ %@.log", appName, formattedDate];
++}
++
++- (NSString *)createNewLogFile {
++    NSString *fileName = [self newLogFileName];
++    NSString *logsDirectory = [self logsDirectory];
++
++    NSUInteger attempt = 1;
++
++    do {
++        NSString *actualFileName = fileName;
++
++        if (attempt > 1) {
++            NSString *extension = [actualFileName pathExtension];
++
++            actualFileName = [actualFileName stringByDeletingPathExtension];
++            actualFileName = [actualFileName stringByAppendingFormat:@" %lu", (unsigned long)attempt];
++
++            if (extension.length) {
++                actualFileName = [actualFileName stringByAppendingPathExtension:extension];
++            }
++        }
++
++        NSString *filePath = [logsDirectory stringByAppendingPathComponent:actualFileName];
++
++        if (![[NSFileManager defaultManager] fileExistsAtPath:filePath]) {
++            NSLogVerbose(@"DDLogFileManagerDefault: Creating new log file: %@", actualFileName);
++
++            NSDictionary *attributes = nil;
++
++        #if TARGET_OS_IPHONE
++            // When creating log file on iOS we're setting NSFileProtectionKey attribute to NSFileProtectionCompleteUnlessOpen.
++            //
++            // But in case if app is able to launch from background we need to have an ability to open log file any time we
++            // want (even if device is locked). Thats why that attribute have to be changed to
++            // NSFileProtectionCompleteUntilFirstUserAuthentication.
++
++            NSString *key = _defaultFileProtectionLevel ? :
++                (doesAppRunInBackground() ? NSFileProtectionCompleteUntilFirstUserAuthentication : NSFileProtectionCompleteUnlessOpen);
++
++            attributes = @{
++                NSFileProtectionKey: key
++            };
++        #endif
++
++            [[NSFileManager defaultManager] createFileAtPath:filePath contents:nil attributes:attributes];
++
++            // Since we just created a new log file, we may need to delete some old log files
++            [self deleteOldLogFiles];
++
++            return filePath;
++        } else {
++            attempt++;
++        }
++    } while (YES);
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Utility
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (NSString *)applicationName {
++    static NSString *_appName;
++    static dispatch_once_t onceToken;
++
++    dispatch_once(&onceToken, ^{
++        _appName = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleIdentifier"];
++
++        if (!_appName) {
++            _appName = [[NSProcessInfo processInfo] processName];
++        }
++
++        if (!_appName) {
++            _appName = @"";
++        }
++    });
++
++    return _appName;
++}
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++@interface DDLogFileFormatterDefault () {
++    NSDateFormatter *_dateFormatter;
++}
++
++@end
++
++@implementation DDLogFileFormatterDefault
++
++- (instancetype)init {
++    return [self initWithDateFormatter:nil];
++}
++
++- (instancetype)initWithDateFormatter:(NSDateFormatter *)aDateFormatter {
++    if ((self = [super init])) {
++        if (aDateFormatter) {
++            _dateFormatter = aDateFormatter;
++        } else {
++            _dateFormatter = [[NSDateFormatter alloc] init];
++            [_dateFormatter setFormatterBehavior:NSDateFormatterBehavior10_4]; // 10.4+ style
++            [_dateFormatter setDateFormat:@"yyyy/MM/dd HH:mm:ss:SSS"];
++        }
++    }
++
++    return self;
++}
++
++- (NSString *)formatLogMessage:(DDLogMessage *)logMessage {
++    NSString *dateAndTime = [_dateFormatter stringFromDate:(logMessage->_timestamp)];
++
++    return [NSString stringWithFormat:@"%@  %@", dateAndTime, logMessage->_message];
++}
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++@interface DDFileLogger () {
++    __strong id <DDLogFileManager> _logFileManager;
++    
++    DDLogFileInfo *_currentLogFileInfo;
++    NSFileHandle *_currentLogFileHandle;
++    
++    dispatch_source_t _currentLogFileVnode;
++    dispatch_source_t _rollingTimer;
++    
++    unsigned long long _maximumFileSize;
++    NSTimeInterval _rollingFrequency;
++}
++
++- (void)rollLogFileNow;
++- (void)maybeRollLogFileDueToAge;
++- (void)maybeRollLogFileDueToSize;
++
++@end
++
++@implementation DDFileLogger
++
++- (instancetype)init {
++    DDLogFileManagerDefault *defaultLogFileManager = [[DDLogFileManagerDefault alloc] init];
++
++    return [self initWithLogFileManager:defaultLogFileManager];
++}
++
++- (instancetype)initWithLogFileManager:(id <DDLogFileManager>)aLogFileManager {
++    if ((self = [super init])) {
++        _maximumFileSize = kDDDefaultLogMaxFileSize;
++        _rollingFrequency = kDDDefaultLogRollingFrequency;
++        _automaticallyAppendNewlineForCustomFormatters = YES;
++
++        logFileManager = aLogFileManager;
++
++        self.logFormatter = [DDLogFileFormatterDefault new];
++    }
++
++    return self;
++}
++
++- (void)dealloc {
++    [_currentLogFileHandle synchronizeFile];
++    [_currentLogFileHandle closeFile];
++
++    if (_currentLogFileVnode) {
++        dispatch_source_cancel(_currentLogFileVnode);
++        _currentLogFileVnode = NULL;
++    }
++
++    if (_rollingTimer) {
++        dispatch_source_cancel(_rollingTimer);
++        _rollingTimer = NULL;
++    }
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Properties
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++@synthesize logFileManager;
++
++- (unsigned long long)maximumFileSize {
++    __block unsigned long long result;
++
++    dispatch_block_t block = ^{
++        result = _maximumFileSize;
++    };
++
++    // The design of this method is taken from the DDAbstractLogger implementation.
++    // For extensive documentation please refer to the DDAbstractLogger implementation.
++
++    // Note: The internal implementation MUST access the maximumFileSize variable directly,
++    // This method is designed explicitly for external access.
++    //
++    // Using "self." syntax to go through this method will cause immediate deadlock.
++    // This is the intended result. Fix it by accessing the ivar directly.
++    // Great strides have been take to ensure this is safe to do. Plus it's MUCH faster.
++
++    NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++    NSAssert(![self isOnInternalLoggerQueue], @"MUST access ivar directly, NOT via self.* syntax.");
++
++    dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++
++    dispatch_sync(globalLoggingQueue, ^{
++        dispatch_sync(self.loggerQueue, block);
++    });
++
++    return result;
++}
++
++- (void)setMaximumFileSize:(unsigned long long)newMaximumFileSize {
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            _maximumFileSize = newMaximumFileSize;
++            [self maybeRollLogFileDueToSize];
++        }
++    };
++
++    // The design of this method is taken from the DDAbstractLogger implementation.
++    // For extensive documentation please refer to the DDAbstractLogger implementation.
++
++    // Note: The internal implementation MUST access the maximumFileSize variable directly,
++    // This method is designed explicitly for external access.
++    //
++    // Using "self." syntax to go through this method will cause immediate deadlock.
++    // This is the intended result. Fix it by accessing the ivar directly.
++    // Great strides have been take to ensure this is safe to do. Plus it's MUCH faster.
++
++    NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++    NSAssert(![self isOnInternalLoggerQueue], @"MUST access ivar directly, NOT via self.* syntax.");
++
++    dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++
++    dispatch_async(globalLoggingQueue, ^{
++        dispatch_async(self.loggerQueue, block);
++    });
++}
++
++- (NSTimeInterval)rollingFrequency {
++    __block NSTimeInterval result;
++
++    dispatch_block_t block = ^{
++        result = _rollingFrequency;
++    };
++
++    // The design of this method is taken from the DDAbstractLogger implementation.
++    // For extensive documentation please refer to the DDAbstractLogger implementation.
++
++    // Note: The internal implementation should access the rollingFrequency variable directly,
++    // This method is designed explicitly for external access.
++    //
++    // Using "self." syntax to go through this method will cause immediate deadlock.
++    // This is the intended result. Fix it by accessing the ivar directly.
++    // Great strides have been take to ensure this is safe to do. Plus it's MUCH faster.
++
++    NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++    NSAssert(![self isOnInternalLoggerQueue], @"MUST access ivar directly, NOT via self.* syntax.");
++
++    dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++
++    dispatch_sync(globalLoggingQueue, ^{
++        dispatch_sync(self.loggerQueue, block);
++    });
++
++    return result;
++}
++
++- (void)setRollingFrequency:(NSTimeInterval)newRollingFrequency {
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            _rollingFrequency = newRollingFrequency;
++            [self maybeRollLogFileDueToAge];
++        }
++    };
++
++    // The design of this method is taken from the DDAbstractLogger implementation.
++    // For extensive documentation please refer to the DDAbstractLogger implementation.
++
++    // Note: The internal implementation should access the rollingFrequency variable directly,
++    // This method is designed explicitly for external access.
++    //
++    // Using "self." syntax to go through this method will cause immediate deadlock.
++    // This is the intended result. Fix it by accessing the ivar directly.
++    // Great strides have been take to ensure this is safe to do. Plus it's MUCH faster.
++
++    NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++    NSAssert(![self isOnInternalLoggerQueue], @"MUST access ivar directly, NOT via self.* syntax.");
++
++    dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++
++    dispatch_async(globalLoggingQueue, ^{
++        dispatch_async(self.loggerQueue, block);
++    });
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark File Rolling
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (void)scheduleTimerToRollLogFileDueToAge {
++    if (_rollingTimer) {
++        dispatch_source_cancel(_rollingTimer);
++        _rollingTimer = NULL;
++    }
++
++    if (_currentLogFileInfo == nil || _rollingFrequency <= 0.0) {
++        return;
++    }
++
++    NSDate *logFileCreationDate = [_currentLogFileInfo creationDate];
++
++    NSTimeInterval ti = [logFileCreationDate timeIntervalSinceReferenceDate];
++    ti += _rollingFrequency;
++
++    NSDate *logFileRollingDate = [NSDate dateWithTimeIntervalSinceReferenceDate:ti];
++
++    NSLogVerbose(@"DDFileLogger: scheduleTimerToRollLogFileDueToAge");
++
++    NSLogVerbose(@"DDFileLogger: logFileCreationDate: %@", logFileCreationDate);
++    NSLogVerbose(@"DDFileLogger: logFileRollingDate : %@", logFileRollingDate);
++
++    _rollingTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, self.loggerQueue);
++
++    dispatch_source_set_event_handler(_rollingTimer, ^{ @autoreleasepool {
++                                                           [self maybeRollLogFileDueToAge];
++                                                       } });
++
++    #if !OS_OBJECT_USE_OBJC
++    dispatch_source_t theRollingTimer = _rollingTimer;
++    dispatch_source_set_cancel_handler(_rollingTimer, ^{
++        dispatch_release(theRollingTimer);
++    });
++    #endif
++
++    uint64_t delay = (uint64_t)([logFileRollingDate timeIntervalSinceNow] * NSEC_PER_SEC);
++    dispatch_time_t fireTime = dispatch_time(DISPATCH_TIME_NOW, delay);
++
++    dispatch_source_set_timer(_rollingTimer, fireTime, DISPATCH_TIME_FOREVER, 1.0);
++    dispatch_resume(_rollingTimer);
++}
++
++- (void)rollLogFile {
++    [self rollLogFileWithCompletionBlock:nil];
++}
++
++- (void)rollLogFileWithCompletionBlock:(void (^)())completionBlock {
++    // This method is public.
++    // We need to execute the rolling on our logging thread/queue.
++
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            [self rollLogFileNow];
++
++            if (completionBlock) {
++                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
++                    completionBlock();
++                });
++            }
++        }
++    };
++
++    // The design of this method is taken from the DDAbstractLogger implementation.
++    // For extensive documentation please refer to the DDAbstractLogger implementation.
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++        NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++
++        dispatch_async(globalLoggingQueue, ^{
++            dispatch_async(self.loggerQueue, block);
++        });
++    }
++}
++
++- (void)rollLogFileNow {
++    NSLogVerbose(@"DDFileLogger: rollLogFileNow");
++
++    if (_currentLogFileHandle == nil) {
++        return;
++    }
++
++    [_currentLogFileHandle synchronizeFile];
++    [_currentLogFileHandle closeFile];
++    _currentLogFileHandle = nil;
++
++    _currentLogFileInfo.isArchived = YES;
++
++    if ([logFileManager respondsToSelector:@selector(didRollAndArchiveLogFile:)]) {
++        [logFileManager didRollAndArchiveLogFile:(_currentLogFileInfo.filePath)];
++    }
++
++    _currentLogFileInfo = nil;
++
++    if (_currentLogFileVnode) {
++        dispatch_source_cancel(_currentLogFileVnode);
++        _currentLogFileVnode = NULL;
++    }
++
++    if (_rollingTimer) {
++        dispatch_source_cancel(_rollingTimer);
++        _rollingTimer = NULL;
++    }
++}
++
++- (void)maybeRollLogFileDueToAge {
++    if (_rollingFrequency > 0.0 && _currentLogFileInfo.age >= _rollingFrequency) {
++        NSLogVerbose(@"DDFileLogger: Rolling log file due to age...");
++
++        [self rollLogFileNow];
++    } else {
++        [self scheduleTimerToRollLogFileDueToAge];
++    }
++}
++
++- (void)maybeRollLogFileDueToSize {
++    // This method is called from logMessage.
++    // Keep it FAST.
++
++    // Note: Use direct access to maximumFileSize variable.
++    // We specifically wrote our own getter/setter method to allow us to do this (for performance reasons).
++
++    if (_maximumFileSize > 0) {
++        unsigned long long fileSize = [_currentLogFileHandle offsetInFile];
++
++        if (fileSize >= _maximumFileSize) {
++            NSLogVerbose(@"DDFileLogger: Rolling log file due to size (%qu)...", fileSize);
++
++            [self rollLogFileNow];
++        }
++    }
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark File Logging
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++/**
++ * Returns the log file that should be used.
++ * If there is an existing log file that is suitable,
++ * within the constraints of maximumFileSize and rollingFrequency, then it is returned.
++ *
++ * Otherwise a new file is created and returned.
++ **/
++- (DDLogFileInfo *)currentLogFileInfo {
++    if (_currentLogFileInfo == nil) {
++        NSArray *sortedLogFileInfos = [logFileManager sortedLogFileInfos];
++
++        if ([sortedLogFileInfos count] > 0) {
++            DDLogFileInfo *mostRecentLogFileInfo = sortedLogFileInfos[0];
++
++            BOOL shouldArchiveMostRecent = NO;
++
++            if (mostRecentLogFileInfo.isArchived) {
++                shouldArchiveMostRecent = NO;
++            } else if (_maximumFileSize > 0 && mostRecentLogFileInfo.fileSize >= _maximumFileSize) {
++                shouldArchiveMostRecent = YES;
++            } else if (_rollingFrequency > 0.0 && mostRecentLogFileInfo.age >= _rollingFrequency) {
++                shouldArchiveMostRecent = YES;
++            }
++
++        #if TARGET_OS_IPHONE
++            // When creating log file on iOS we're setting NSFileProtectionKey attribute to NSFileProtectionCompleteUnlessOpen.
++            //
++            // But in case if app is able to launch from background we need to have an ability to open log file any time we
++            // want (even if device is locked). Thats why that attribute have to be changed to
++            // NSFileProtectionCompleteUntilFirstUserAuthentication.
++            //
++            // If previous log was created when app wasn't running in background, but now it is - we archive it and create
++            // a new one.
++            //
++            // If user has owerwritten to NSFileProtectionNone there is no neeed to create a new one.
++
++            if (!_doNotReuseLogFiles && doesAppRunInBackground()) {
++                NSString *key = mostRecentLogFileInfo.fileAttributes[NSFileProtectionKey];
++
++                if ([key length] > 0 && !([key isEqualToString:NSFileProtectionCompleteUntilFirstUserAuthentication] || [key isEqualToString:NSFileProtectionNone])) {
++                    shouldArchiveMostRecent = YES;
++                }
++            }
++
++        #endif
++
++            if (!_doNotReuseLogFiles && !mostRecentLogFileInfo.isArchived && !shouldArchiveMostRecent) {
++                NSLogVerbose(@"DDFileLogger: Resuming logging with file %@", mostRecentLogFileInfo.fileName);
++
++                _currentLogFileInfo = mostRecentLogFileInfo;
++            } else {
++                if (shouldArchiveMostRecent) {
++                    mostRecentLogFileInfo.isArchived = YES;
++
++                    if ([logFileManager respondsToSelector:@selector(didArchiveLogFile:)]) {
++                        [logFileManager didArchiveLogFile:(mostRecentLogFileInfo.filePath)];
++                    }
++                }
++            }
++        }
++
++        if (_currentLogFileInfo == nil) {
++            NSString *currentLogFilePath = [logFileManager createNewLogFile];
++
++            _currentLogFileInfo = [[DDLogFileInfo alloc] initWithFilePath:currentLogFilePath];
++        }
++    }
++
++    return _currentLogFileInfo;
++}
++
++- (NSFileHandle *)currentLogFileHandle {
++    if (_currentLogFileHandle == nil) {
++        NSString *logFilePath = [[self currentLogFileInfo] filePath];
++
++        _currentLogFileHandle = [NSFileHandle fileHandleForWritingAtPath:logFilePath];
++        [_currentLogFileHandle seekToEndOfFile];
++
++        if (_currentLogFileHandle) {
++            [self scheduleTimerToRollLogFileDueToAge];
++
++            // Here we are monitoring the log file. In case if it would be deleted ormoved
++            // somewhere we want to roll it and use a new one.
++            _currentLogFileVnode = dispatch_source_create(
++                    DISPATCH_SOURCE_TYPE_VNODE,
++                    [_currentLogFileHandle fileDescriptor],
++                    DISPATCH_VNODE_DELETE | DISPATCH_VNODE_RENAME,
++                    self.loggerQueue
++                    );
++
++            dispatch_source_set_event_handler(_currentLogFileVnode, ^{ @autoreleasepool {
++                                                                          NSLogInfo(@"DDFileLogger: Current logfile was moved. Rolling it and creating a new one");
++                                                                          [self rollLogFileNow];
++                                                                      } });
++
++            #if !OS_OBJECT_USE_OBJC
++            dispatch_source_t vnode = _currentLogFileVnode;
++            dispatch_source_set_cancel_handler(_currentLogFileVnode, ^{
++                dispatch_release(vnode);
++            });
++            #endif
++
++            dispatch_resume(_currentLogFileVnode);
++        }
++    }
++
++    return _currentLogFileHandle;
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark DDLogger Protocol
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++static int exception_count = 0;
++- (void)logMessage:(DDLogMessage *)logMessage {
++    NSString *message = logMessage->_message;
++    BOOL isFormatted = NO;
++
++    if (_logFormatter) {
++        message = [_logFormatter formatLogMessage:logMessage];
++        isFormatted = message != logMessage->_message;
++    }
++
++    if (message) {
++        if ((!isFormatted || _automaticallyAppendNewlineForCustomFormatters) &&
++            (![message hasSuffix:@"\n"])) {
++            message = [message stringByAppendingString:@"\n"];
++        }
++
++        NSData *logData = [message dataUsingEncoding:NSUTF8StringEncoding];
++
++        @try {
++            [[self currentLogFileHandle] writeData:logData];
++
++            [self maybeRollLogFileDueToSize];
++        } @catch (NSException *exception) {
++            exception_count++;
++
++            if (exception_count <= 10) {
++                NSLogError(@"DDFileLogger.logMessage: %@", exception);
++
++                if (exception_count == 10) {
++                    NSLogError(@"DDFileLogger.logMessage: Too many exceptions -- will not log any more of them.");
++                }
++            }
++        }
++    }
++}
++
++- (void)willRemoveLogger {
++    // If you override me be sure to invoke [super willRemoveLogger];
++
++    [self rollLogFileNow];
++}
++
++- (NSString *)loggerName {
++    return @"cocoa.lumberjack.fileLogger";
++}
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++#if TARGET_IPHONE_SIMULATOR
++    static NSString * const kDDXAttrArchivedName = @"archived";
++#else
++    static NSString * const kDDXAttrArchivedName = @"lumberjack.log.archived";
++#endif
++
++@interface DDLogFileInfo () {
++    __strong NSString *_filePath;
++    __strong NSString *_fileName;
++    
++    __strong NSDictionary *_fileAttributes;
++    
++    __strong NSDate *_creationDate;
++    __strong NSDate *_modificationDate;
++    
++    unsigned long long _fileSize;
++}
++
++@end
++
++
++@implementation DDLogFileInfo
++
++@synthesize filePath;
++
++@dynamic fileName;
++@dynamic fileAttributes;
++@dynamic creationDate;
++@dynamic modificationDate;
++@dynamic fileSize;
++@dynamic age;
++
++@dynamic isArchived;
++
++
++#pragma mark Lifecycle
++
+++ (instancetype)logFileWithPath:(NSString *)aFilePath {
++    return [[self alloc] initWithFilePath:aFilePath];
++}
++
++- (instancetype)initWithFilePath:(NSString *)aFilePath {
++    if ((self = [super init])) {
++        filePath = [aFilePath copy];
++    }
++
++    return self;
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Standard Info
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (NSDictionary *)fileAttributes {
++    if (_fileAttributes == nil) {
++        _fileAttributes = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil];
++    }
++
++    return _fileAttributes;
++}
++
++- (NSString *)fileName {
++    if (_fileName == nil) {
++        _fileName = [filePath lastPathComponent];
++    }
++
++    return _fileName;
++}
++
++- (NSDate *)modificationDate {
++    if (_modificationDate == nil) {
++        _modificationDate = self.fileAttributes[NSFileModificationDate];
++    }
++
++    return _modificationDate;
++}
++
++- (NSDate *)creationDate {
++    if (_creationDate == nil) {
++        _creationDate = self.fileAttributes[NSFileCreationDate];
++    }
++
++    return _creationDate;
++}
++
++- (unsigned long long)fileSize {
++    if (_fileSize == 0) {
++        _fileSize = [self.fileAttributes[NSFileSize] unsignedLongLongValue];
++    }
++
++    return _fileSize;
++}
++
++- (NSTimeInterval)age {
++    return [[self creationDate] timeIntervalSinceNow] * -1.0;
++}
++
++- (NSString *)description {
++    return [@{ @"filePath": self.filePath ? : @"",
++               @"fileName": self.fileName ? : @"",
++               @"fileAttributes": self.fileAttributes ? : @"",
++               @"creationDate": self.creationDate ? : @"",
++               @"modificationDate": self.modificationDate ? : @"",
++               @"fileSize": @(self.fileSize),
++               @"age": @(self.age),
++               @"isArchived": @(self.isArchived) } description];
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Archiving
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (BOOL)isArchived {
++#if TARGET_IPHONE_SIMULATOR
++
++    // Extended attributes don't work properly on the simulator.
++    // So we have to use a less attractive alternative.
++    // See full explanation in the header file.
++
++    return [self hasExtensionAttributeWithName:kDDXAttrArchivedName];
++
++#else
++
++    return [self hasExtendedAttributeWithName:kDDXAttrArchivedName];
++
++#endif
++}
++
++- (void)setIsArchived:(BOOL)flag {
++#if TARGET_IPHONE_SIMULATOR
++
++    // Extended attributes don't work properly on the simulator.
++    // So we have to use a less attractive alternative.
++    // See full explanation in the header file.
++
++    if (flag) {
++        [self addExtensionAttributeWithName:kDDXAttrArchivedName];
++    } else {
++        [self removeExtensionAttributeWithName:kDDXAttrArchivedName];
++    }
++
++#else
++
++    if (flag) {
++        [self addExtendedAttributeWithName:kDDXAttrArchivedName];
++    } else {
++        [self removeExtendedAttributeWithName:kDDXAttrArchivedName];
++    }
++
++#endif
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Changes
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (void)reset {
++    _fileName = nil;
++    _fileAttributes = nil;
++    _creationDate = nil;
++    _modificationDate = nil;
++}
++
++- (void)renameFile:(NSString *)newFileName {
++    // This method is only used on the iPhone simulator, where normal extended attributes are broken.
++    // See full explanation in the header file.
++
++    if (![newFileName isEqualToString:[self fileName]]) {
++        NSString *fileDir = [filePath stringByDeletingLastPathComponent];
++
++        NSString *newFilePath = [fileDir stringByAppendingPathComponent:newFileName];
++
++        NSLogVerbose(@"DDLogFileInfo: Renaming file: '%@' -> '%@'", self.fileName, newFileName);
++
++        NSError *error = nil;
++
++        if ([[NSFileManager defaultManager] fileExistsAtPath:newFilePath] &&
++            ![[NSFileManager defaultManager] removeItemAtPath:newFilePath error:&error]) {
++            NSLogError(@"DDLogFileInfo: Error deleting archive (%@): %@", self.fileName, error);
++        }
++
++        if (![[NSFileManager defaultManager] moveItemAtPath:filePath toPath:newFilePath error:&error]) {
++            NSLogError(@"DDLogFileInfo: Error renaming file (%@): %@", self.fileName, error);
++        }
++
++        filePath = newFilePath;
++        [self reset];
++    }
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Attribute Management
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++#if TARGET_IPHONE_SIMULATOR
++
++// Extended attributes don't work properly on the simulator.
++// So we have to use a less attractive alternative.
++// See full explanation in the header file.
++
++- (BOOL)hasExtensionAttributeWithName:(NSString *)attrName {
++    // This method is only used on the iPhone simulator, where normal extended attributes are broken.
++    // See full explanation in the header file.
++
++    // Split the file name into components. File name may have various format, but generally
++    // structure is same:
++    //
++    // <name part>.<extension part> and <name part>.archived.<extension part>
++    // or
++    // <name part> and <name part>.archived
++    //
++    // So we want to search for the attrName in the components (ignoring the first array index).
++
++    NSArray *components = [[self fileName] componentsSeparatedByString:@"."];
++
++    // Watch out for file names without an extension
++
++    for (NSUInteger i = 1; i < components.count; i++) {
++        NSString *attr = components[i];
++
++        if ([attrName isEqualToString:attr]) {
++            return YES;
++        }
++    }
++
++    return NO;
++}
++
++- (void)addExtensionAttributeWithName:(NSString *)attrName {
++    // This method is only used on the iPhone simulator, where normal extended attributes are broken.
++    // See full explanation in the header file.
++
++    if ([attrName length] == 0) {
++        return;
++    }
++
++    // Example:
++    // attrName = "archived"
++    //
++    // "mylog.txt" -> "mylog.archived.txt"
++    // "mylog"     -> "mylog.archived"
++
++    NSArray *components = [[self fileName] componentsSeparatedByString:@"."];
++
++    NSUInteger count = [components count];
++
++    NSUInteger estimatedNewLength = [[self fileName] length] + [attrName length] + 1;
++    NSMutableString *newFileName = [NSMutableString stringWithCapacity:estimatedNewLength];
++
++    if (count > 0) {
++        [newFileName appendString:components.firstObject];
++    }
++
++    NSString *lastExt = @"";
++
++    NSUInteger i;
++
++    for (i = 1; i < count; i++) {
++        NSString *attr = components[i];
++
++        if ([attr length] == 0) {
++            continue;
++        }
++
++        if ([attrName isEqualToString:attr]) {
++            // Extension attribute already exists in file name
++            return;
++        }
++
++        if ([lastExt length] > 0) {
++            [newFileName appendFormat:@".%@", lastExt];
++        }
++
++        lastExt = attr;
++    }
++
++    [newFileName appendFormat:@".%@", attrName];
++
++    if ([lastExt length] > 0) {
++        [newFileName appendFormat:@".%@", lastExt];
++    }
++
++    [self renameFile:newFileName];
++}
++
++- (void)removeExtensionAttributeWithName:(NSString *)attrName {
++    // This method is only used on the iPhone simulator, where normal extended attributes are broken.
++    // See full explanation in the header file.
++
++    if ([attrName length] == 0) {
++        return;
++    }
++
++    // Example:
++    // attrName = "archived"
++    //
++    // "mylog.archived.txt" -> "mylog.txt"
++    // "mylog.archived"     -> "mylog"
++
++    NSArray *components = [[self fileName] componentsSeparatedByString:@"."];
++
++    NSUInteger count = [components count];
++
++    NSUInteger estimatedNewLength = [[self fileName] length];
++    NSMutableString *newFileName = [NSMutableString stringWithCapacity:estimatedNewLength];
++
++    if (count > 0) {
++        [newFileName appendString:components.firstObject];
++    }
++
++    BOOL found = NO;
++
++    NSUInteger i;
++
++    for (i = 1; i < count; i++) {
++        NSString *attr = components[i];
++
++        if ([attrName isEqualToString:attr]) {
++            found = YES;
++        } else {
++            [newFileName appendFormat:@".%@", attr];
++        }
++    }
++
++    if (found) {
++        [self renameFile:newFileName];
++    }
++}
++
++#else /* if TARGET_IPHONE_SIMULATOR */
++
++- (BOOL)hasExtendedAttributeWithName:(NSString *)attrName {
++    const char *path = [filePath UTF8String];
++    const char *name = [attrName UTF8String];
++
++    ssize_t result = getxattr(path, name, NULL, 0, 0, 0);
++
++    return (result >= 0);
++}
++
++- (void)addExtendedAttributeWithName:(NSString *)attrName {
++    const char *path = [filePath UTF8String];
++    const char *name = [attrName UTF8String];
++
++    int result = setxattr(path, name, NULL, 0, 0, 0);
++
++    if (result < 0) {
++        NSLogError(@"DDLogFileInfo: setxattr(%@, %@): error = %s",
++                   attrName,
++                   filePath,
++                   strerror(errno));
++    }
++}
++
++- (void)removeExtendedAttributeWithName:(NSString *)attrName {
++    const char *path = [filePath UTF8String];
++    const char *name = [attrName UTF8String];
++
++    int result = removexattr(path, name, 0);
++
++    if (result < 0 && errno != ENOATTR) {
++        NSLogError(@"DDLogFileInfo: removexattr(%@, %@): error = %s",
++                   attrName,
++                   self.fileName,
++                   strerror(errno));
++    }
++}
++
++#endif /* if TARGET_IPHONE_SIMULATOR */
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Comparisons
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (BOOL)isEqual:(id)object {
++    if ([object isKindOfClass:[self class]]) {
++        DDLogFileInfo *another = (DDLogFileInfo *)object;
++
++        return [filePath isEqualToString:[another filePath]];
++    }
++
++    return NO;
++}
++
++- (NSComparisonResult)reverseCompareByCreationDate:(DDLogFileInfo *)another {
++    NSDate *us = [self creationDate];
++    NSDate *them = [another creationDate];
++
++    NSComparisonResult result = [us compare:them];
++
++    if (result == NSOrderedAscending) {
++        return NSOrderedDescending;
++    }
++
++    if (result == NSOrderedDescending) {
++        return NSOrderedAscending;
++    }
++
++    return NSOrderedSame;
++}
++
++- (NSComparisonResult)reverseCompareByModificationDate:(DDLogFileInfo *)another {
++    NSDate *us = [self modificationDate];
++    NSDate *them = [another modificationDate];
++
++    NSComparisonResult result = [us compare:them];
++
++    if (result == NSOrderedAscending) {
++        return NSOrderedDescending;
++    }
++
++    if (result == NSOrderedDescending) {
++        return NSOrderedAscending;
++    }
++
++    return NSOrderedSame;
++}
++
++@end
++
++#if TARGET_OS_IPHONE
++/**
++ * When creating log file on iOS we're setting NSFileProtectionKey attribute to NSFileProtectionCompleteUnlessOpen.
++ *
++ * But in case if app is able to launch from background we need to have an ability to open log file any time we
++ * want (even if device is locked). Thats why that attribute have to be changed to
++ * NSFileProtectionCompleteUntilFirstUserAuthentication.
++ */
++BOOL doesAppRunInBackground() {
++    BOOL answer = NO;
++
++    NSArray *backgroundModes = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"UIBackgroundModes"];
++
++    for (NSString *mode in backgroundModes) {
++        if (mode.length > 0) {
++            answer = YES;
++            break;
++        }
++    }
++
++    return answer;
++}
++
++#endif
+diff --git a/Pods/CocoaLumberjack/Classes/DDLegacyMacros.h b/Pods/CocoaLumberjack/Classes/DDLegacyMacros.h
+new file mode 100644
+index 0000000..e0671b9
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDLegacyMacros.h
+@@ -0,0 +1,75 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++/**
++ * Legacy macros used for 1.9.x backwards compatibility.
++ *
++ * Imported by default when importing a DDLog.h directly and DD_LEGACY_MACROS is not defined and set to 0.
++ **/
++#if DD_LEGACY_MACROS
++
++#warning CocoaLumberjack 1.9.x legacy macros enabled. \
++Disable legacy macros by importing CocoaLumberjack.h or DDLogMacros.h instead of DDLog.h or add `#define DD_LEGACY_MACROS 0` before importing DDLog.h.
++
++#ifndef LOG_LEVEL_DEF
++    #define LOG_LEVEL_DEF ddLogLevel
++#endif
++
++#define LOG_FLAG_ERROR    DDLogFlagError
++#define LOG_FLAG_WARN     DDLogFlagWarning
++#define LOG_FLAG_INFO     DDLogFlagInfo
++#define LOG_FLAG_DEBUG    DDLogFlagDebug
++#define LOG_FLAG_VERBOSE  DDLogFlagVerbose
++
++#define LOG_LEVEL_OFF     DDLogLevelOff
++#define LOG_LEVEL_ERROR   DDLogLevelError
++#define LOG_LEVEL_WARN    DDLogLevelWarning
++#define LOG_LEVEL_INFO    DDLogLevelInfo
++#define LOG_LEVEL_DEBUG   DDLogLevelDebug
++#define LOG_LEVEL_VERBOSE DDLogLevelVerbose
++#define LOG_LEVEL_ALL     DDLogLevelAll
++
++#define LOG_ASYNC_ENABLED YES
++
++#define LOG_ASYNC_ERROR    ( NO && LOG_ASYNC_ENABLED)
++#define LOG_ASYNC_WARN     (YES && LOG_ASYNC_ENABLED)
++#define LOG_ASYNC_INFO     (YES && LOG_ASYNC_ENABLED)
++#define LOG_ASYNC_DEBUG    (YES && LOG_ASYNC_ENABLED)
++#define LOG_ASYNC_VERBOSE  (YES && LOG_ASYNC_ENABLED)
++
++#define LOG_MACRO(isAsynchronous, lvl, flg, ctx, atag, fnct, frmt, ...) \
++        [DDLog log : isAsynchronous                                     \
++             level : lvl                                                \
++              flag : flg                                                \
++           context : ctx                                                \
++              file : __FILE__                                           \
++          function : fnct                                               \
++              line : __LINE__                                           \
++               tag : atag                                               \
++            format : (frmt), ## __VA_ARGS__]
++
++#define LOG_MAYBE(async, lvl, flg, ctx, fnct, frmt, ...)                       \
++        do { if(lvl & flg) LOG_MACRO(async, lvl, flg, ctx, nil, fnct, frmt, ##__VA_ARGS__); } while(0)
++
++#define LOG_OBJC_MAYBE(async, lvl, flg, ctx, frmt, ...) \
++        LOG_MAYBE(async, lvl, flg, ctx, __PRETTY_FUNCTION__, frmt, ## __VA_ARGS__)
++
++#define DDLogError(frmt, ...)   LOG_OBJC_MAYBE(LOG_ASYNC_ERROR,   LOG_LEVEL_DEF, LOG_FLAG_ERROR,   0, frmt, ##__VA_ARGS__)
++#define DDLogWarn(frmt, ...)    LOG_OBJC_MAYBE(LOG_ASYNC_WARN,    LOG_LEVEL_DEF, LOG_FLAG_WARN,    0, frmt, ##__VA_ARGS__)
++#define DDLogInfo(frmt, ...)    LOG_OBJC_MAYBE(LOG_ASYNC_INFO,    LOG_LEVEL_DEF, LOG_FLAG_INFO,    0, frmt, ##__VA_ARGS__)
++#define DDLogDebug(frmt, ...)   LOG_OBJC_MAYBE(LOG_ASYNC_DEBUG,   LOG_LEVEL_DEF, LOG_FLAG_DEBUG,   0, frmt, ##__VA_ARGS__)
++#define DDLogVerbose(frmt, ...) LOG_OBJC_MAYBE(LOG_ASYNC_VERBOSE, LOG_LEVEL_DEF, LOG_FLAG_VERBOSE, 0, frmt, ##__VA_ARGS__)
++
++#endif
+diff --git a/Pods/CocoaLumberjack/Classes/DDLog+LOGV.h b/Pods/CocoaLumberjack/Classes/DDLog+LOGV.h
+new file mode 100644
+index 0000000..cf4bfc3
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDLog+LOGV.h
+@@ -0,0 +1,83 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++// Disable legacy macros
++#ifndef DD_LEGACY_MACROS
++    #define DD_LEGACY_MACROS 0
++#endif
++
++#import "DDLog.h"
++
++/**
++ * The constant/variable/method responsible for controlling the current log level.
++ **/
++#ifndef LOG_LEVEL_DEF
++    #define LOG_LEVEL_DEF ddLogLevel
++#endif
++
++/**
++ * Whether async should be used by log messages, excluding error messages that are always sent sync.
++ **/
++#ifndef LOG_ASYNC_ENABLED
++    #define LOG_ASYNC_ENABLED YES
++#endif
++
++/**
++ * This is the single macro that all other macros below compile into.
++ * This big multiline macro makes all the other macros easier to read.
++ **/
++#define LOGV_MACRO(isAsynchronous, lvl, flg, ctx, atag, fnct, frmt, avalist) \
++        [DDLog log : isAsynchronous                                     \
++             level : lvl                                                \
++              flag : flg                                                \
++           context : ctx                                                \
++              file : __FILE__                                           \
++          function : fnct                                               \
++              line : __LINE__                                           \
++               tag : atag                                               \
++            format : frmt                                               \
++              args : avalist]
++
++/**
++ * Define version of the macro that only execute if the log level is above the threshold.
++ * The compiled versions essentially look like this:
++ *
++ * if (logFlagForThisLogMsg & ddLogLevel) { execute log message }
++ *
++ * When LOG_LEVEL_DEF is defined as ddLogLevel.
++ *
++ * As shown further below, Lumberjack actually uses a bitmask as opposed to primitive log levels.
++ * This allows for a great amount of flexibility and some pretty advanced fine grained logging techniques.
++ *
++ * Note that when compiler optimizations are enabled (as they are for your release builds),
++ * the log messages above your logging threshold will automatically be compiled out.
++ *
++ * (If the compiler sees LOG_LEVEL_DEF/ddLogLevel declared as a constant, the compiler simply checks to see
++ *  if the 'if' statement would execute, and if not it strips it from the binary.)
++ *
++ * We also define shorthand versions for asynchronous and synchronous logging.
++ **/
++#define LOGV_MAYBE(async, lvl, flg, ctx, tag, fnct, frmt, avalist) \
++        do { if(lvl & flg) LOGV_MACRO(async, lvl, flg, ctx, tag, fnct, frmt, avalist); } while(0)
++
++/**
++ * Ready to use log macros with no context or tag.
++ **/
++#define DDLogVError(frmt, avalist)   LOGV_MAYBE(NO,                LOG_LEVEL_DEF, DDLogFlagError,   0, nil, __PRETTY_FUNCTION__, frmt, avalist)
++#define DDLogVWarn(frmt, avalist)    LOGV_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagWarning, 0, nil, __PRETTY_FUNCTION__, frmt, avalist)
++#define DDLogVInfo(frmt, avalist)    LOGV_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagInfo,    0, nil, __PRETTY_FUNCTION__, frmt, avalist)
++#define DDLogVDebug(frmt, avalist)   LOGV_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagDebug,   0, nil, __PRETTY_FUNCTION__, frmt, avalist)
++#define DDLogVVerbose(frmt, avalist) LOGV_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagVerbose, 0, nil, __PRETTY_FUNCTION__, frmt, avalist)
++
+diff --git a/Pods/CocoaLumberjack/Classes/DDLog.h b/Pods/CocoaLumberjack/Classes/DDLog.h
+new file mode 100644
+index 0000000..b7f1074
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDLog.h
+@@ -0,0 +1,743 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++#import <Foundation/Foundation.h>
++
++// Enable 1.9.x legacy macros if imported directly
++#ifndef DD_LEGACY_MACROS
++    #define DD_LEGACY_MACROS 1
++#endif
++// DD_LEGACY_MACROS is checked in the file itself
++#import "DDLegacyMacros.h"
++
++#if OS_OBJECT_USE_OBJC
++    #define DISPATCH_QUEUE_REFERENCE_TYPE strong
++#else
++    #define DISPATCH_QUEUE_REFERENCE_TYPE assign
++#endif
++
++@class DDLogMessage;
++@protocol DDLogger;
++@protocol DDLogFormatter;
++
++/**
++ * Define the standard options.
++ *
++ * We default to only 4 levels because it makes it easier for beginners
++ * to make the transition to a logging framework.
++ *
++ * More advanced users may choose to completely customize the levels (and level names) to suite their needs.
++ * For more information on this see the "Custom Log Levels" page:
++ * Documentation/CustomLogLevels.md
++ *
++ * Advanced users may also notice that we're using a bitmask.
++ * This is to allow for custom fine grained logging:
++ * Documentation/FineGrainedLogging.md
++ *
++ * -- Flags --
++ *
++ * Typically you will use the LOG_LEVELS (see below), but the flags may be used directly in certain situations.
++ * For example, say you have a lot of warning log messages, and you wanted to disable them.
++ * However, you still needed to see your error and info log messages.
++ * You could accomplish that with the following:
++ *
++ * static const DDLogLevel ddLogLevel = DDLogFlagError | DDLogFlagInfo;
++ *
++ * When LOG_LEVEL_DEF is defined as ddLogLevel.
++ *
++ * Flags may also be consulted when writing custom log formatters,
++ * as the DDLogMessage class captures the individual flag that caused the log message to fire.
++ *
++ * -- Levels --
++ *
++ * Log levels are simply the proper bitmask of the flags.
++ *
++ * -- Booleans --
++ *
++ * The booleans may be used when your logging code involves more than one line.
++ * For example:
++ *
++ * if (LOG_VERBOSE) {
++ *     for (id sprocket in sprockets)
++ *         DDLogVerbose(@"sprocket: %@", [sprocket description])
++ * }
++ *
++ * -- Async --
++ *
++ * Defines the default asynchronous options.
++ * The default philosophy for asynchronous logging is very simple:
++ *
++ * Log messages with errors should be executed synchronously.
++ *     After all, an error just occurred. The application could be unstable.
++ *
++ * All other log messages, such as debug output, are executed asynchronously.
++ *     After all, if it wasn't an error, then it was just informational output,
++ *     or something the application was easily able to recover from.
++ *
++ * -- Changes --
++ *
++ * You are strongly discouraged from modifying this file.
++ * If you do, you make it more difficult on yourself to merge future bug fixes and improvements from the project.
++ * Instead, create your own MyLogging.h or ApplicationNameLogging.h or CompanyLogging.h
++ *
++ * For an example of customizing your logging experience, see the "Custom Log Levels" page:
++ * Documentation/CustomLogLevels.md
++ **/
++
++/**
++ *  Flags accompany each log. They are used together with levels to filter out logs.
++ */
++typedef NS_OPTIONS(NSUInteger, DDLogFlag){
++    /**
++     *  0...00000 DDLogFlagError
++     */
++    DDLogFlagError      = (1 << 0),
++    
++    /**
++     *  0...00001 DDLogFlagWarning
++     */
++    DDLogFlagWarning    = (1 << 1),
++    
++    /**
++     *  0...00010 DDLogFlagInfo
++     */
++    DDLogFlagInfo       = (1 << 2),
++    
++    /**
++     *  0...00100 DDLogFlagDebug
++     */
++    DDLogFlagDebug      = (1 << 3),
++    
++    /**
++     *  0...01000 DDLogFlagVerbose
++     */
++    DDLogFlagVerbose    = (1 << 4)
++};
++
++/**
++ *  Log levels are used to filter out logs. Used together with flags.
++ */
++typedef NS_ENUM(NSUInteger, DDLogLevel){
++    /**
++     *  No logs
++     */
++    DDLogLevelOff       = 0,
++    
++    /**
++     *  Error logs only
++     */
++    DDLogLevelError     = (DDLogFlagError),
++    
++    /**
++     *  Error and warning logs
++     */
++    DDLogLevelWarning   = (DDLogLevelError   | DDLogFlagWarning),
++    
++    /**
++     *  Error, warning and info logs
++     */
++    DDLogLevelInfo      = (DDLogLevelWarning | DDLogFlagInfo),
++    
++    /**
++     *  Error, warning, info and debug logs
++     */
++    DDLogLevelDebug     = (DDLogLevelInfo    | DDLogFlagDebug),
++    
++    /**
++     *  Error, warning, info, debug and verbose logs
++     */
++    DDLogLevelVerbose   = (DDLogLevelDebug   | DDLogFlagVerbose),
++    
++    /**
++     *  All logs (1...11111)
++     */
++    DDLogLevelAll       = NSUIntegerMax
++};
++
++/**
++ *  Extracts just the file name, no path or extension
++ *
++ *  @param filePath input file path
++ *  @param copy     YES if we want the result to be copied
++ *
++ *  @return the file name
++ */
++NSString * DDExtractFileNameWithoutExtension(const char *filePath, BOOL copy);
++
++/**
++ * The THIS_FILE macro gives you an NSString of the file name.
++ * For simplicity and clarity, the file name does not include the full path or file extension.
++ *
++ * For example: DDLogWarn(@"%@: Unable to find thingy", THIS_FILE) -> @"MyViewController: Unable to find thingy"
++ **/
++#define THIS_FILE         (DDExtractFileNameWithoutExtension(__FILE__, NO))
++
++/**
++ * The THIS_METHOD macro gives you the name of the current objective-c method.
++ *
++ * For example: DDLogWarn(@"%@ - Requires non-nil strings", THIS_METHOD) -> @"setMake:model: requires non-nil strings"
++ *
++ * Note: This does NOT work in straight C functions (non objective-c).
++ * Instead you should use the predefined __FUNCTION__ macro.
++ **/
++#define THIS_METHOD       NSStringFromSelector(_cmd)
++
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++/**
++ *  The main class, exposes all logging mechanisms, loggers, ...
++ *  For most of the users, this class is hidden behind the logging functions like `DDLogInfo`
++ */
++@interface DDLog : NSObject
++
++/**
++ * Provides access to the underlying logging queue.
++ * This may be helpful to Logger classes for things like thread synchronization.
++ **/
+++ (dispatch_queue_t)loggingQueue;
++
++/**
++ * Logging Primitive.
++ *
++ * This method is used by the macros or logging functions.
++ * It is suggested you stick with the macros as they're easier to use.
++ *
++ *  @param asynchronous YES if the logging is done async, NO if you want to force sync
++ *  @param level        the log level
++ *  @param flag         the log flag
++ *  @param context      the context (if any is defined)
++ *  @param file         the current file
++ *  @param function     the current function
++ *  @param line         the current code line
++ *  @param tag          potential tag
++ *  @param format       the log format
++ */
+++ (void)log:(BOOL)asynchronous
++      level:(DDLogLevel)level
++       flag:(DDLogFlag)flag
++    context:(NSInteger)context
++       file:(const char *)file
++   function:(const char *)function
++       line:(NSUInteger)line
++        tag:(id)tag
++     format:(NSString *)format, ... NS_FORMAT_FUNCTION(9,10);
++
++/**
++ * Logging Primitive.
++ *
++ * This method can be used if you have a prepared va_list.
++ * Similar to `log:level:flag:context:file:function:line:tag:format:...`
++ *
++ *  @param asynchronous YES if the logging is done async, NO if you want to force sync
++ *  @param level        the log level
++ *  @param flag         the log flag
++ *  @param context      the context (if any is defined)
++ *  @param file         the current file
++ *  @param function     the current function
++ *  @param line         the current code line
++ *  @param tag          potential tag
++ *  @param format       the log format
++ *  @param argList      the arguments list as a va_list
++ */
+++ (void)log:(BOOL)asynchronous
++      level:(DDLogLevel)level
++       flag:(DDLogFlag)flag
++    context:(NSInteger)context
++       file:(const char *)file
++   function:(const char *)function
++       line:(NSUInteger)line
++        tag:(id)tag
++     format:(NSString *)format
++       args:(va_list)argList;
++
++/**
++ *  Logging Primitive.
++ *
++ *  @param asynchronous YES if the logging is done async, NO if you want to force sync
++ *  @param message      the message
++ *  @param level        the log level
++ *  @param flag         the log flag
++ *  @param context      the context (if any is defined)
++ *  @param file         the current file
++ *  @param function     the current function
++ *  @param line         the current code line
++ *  @param tag          potential tag
++ */
+++ (void)log:(BOOL)asynchronous
++    message:(NSString *)message
++      level:(DDLogLevel)level
++       flag:(DDLogFlag)flag
++    context:(NSInteger)context
++       file:(const char *)file
++   function:(const char *)function
++       line:(NSUInteger)line
++        tag:(id)tag;
++
++/**
++ * Logging Primitive.
++ *
++ * This method can be used if you manualy prepared DDLogMessage.
++ *
++ *  @param asynchronous YES if the logging is done async, NO if you want to force sync
++ *  @param logMessage   the log message stored in a `DDLogMessage` model object
++ */
+++ (void)log:(BOOL)asynchronous
++    message:(DDLogMessage *)logMessage;
++
++/**
++ * Since logging can be asynchronous, there may be times when you want to flush the logs.
++ * The framework invokes this automatically when the application quits.
++ **/
+++ (void)flushLog;
++
++/**
++ * Loggers
++ *
++ * In order for your log statements to go somewhere, you should create and add a logger.
++ *
++ * You can add multiple loggers in order to direct your log statements to multiple places.
++ * And each logger can be configured separately.
++ * So you could have, for example, verbose logging to the console, but a concise log file with only warnings & errors.
++ **/
++
++/**
++ * Adds the logger to the system.
++ *
++ * This is equivalent to invoking `[DDLog addLogger:logger withLogLevel:DDLogLevelAll]`.
++ **/
+++ (void)addLogger:(id <DDLogger>)logger;
++
++/**
++ * Adds the logger to the system.
++ *
++ * The level that you provide here is a preemptive filter (for performance).
++ * That is, the level specified here will be used to filter out logMessages so that
++ * the logger is never even invoked for the messages.
++ *
++ * More information:
++ * When you issue a log statement, the logging framework iterates over each logger,
++ * and checks to see if it should forward the logMessage to the logger.
++ * This check is done using the level parameter passed to this method.
++ *
++ * For example:
++ *
++ * `[DDLog addLogger:consoleLogger withLogLevel:DDLogLevelVerbose];`
++ * `[DDLog addLogger:fileLogger    withLogLevel:DDLogLevelWarning];`
++ *
++ * `DDLogError(@"oh no");` => gets forwarded to consoleLogger & fileLogger
++ * `DDLogInfo(@"hi");`     => gets forwarded to consoleLogger only
++ *
++ * It is important to remember that Lumberjack uses a BITMASK.
++ * Many developers & third party frameworks may define extra log levels & flags.
++ * For example:
++ *
++ * `#define SOME_FRAMEWORK_LOG_FLAG_TRACE (1 << 6) // 0...1000000`
++ *
++ * So if you specify `DDLogLevelVerbose` to this method, you won't see the framework's trace messages.
++ *
++ * `(SOME_FRAMEWORK_LOG_FLAG_TRACE & DDLogLevelVerbose) => (01000000 & 00011111) => NO`
++ *
++ * Consider passing `DDLogLevelAll` to this method, which has all bits set.
++ * You can also use the exclusive-or bitwise operator to get a bitmask that has all flags set,
++ * except the ones you explicitly don't want. For example, if you wanted everything except verbose & debug:
++ *
++ * `((DDLogLevelAll ^ DDLogLevelVerbose) | DDLogLevelInfo)`
++ **/
+++ (void)addLogger:(id <DDLogger>)logger withLevel:(DDLogLevel)level;
++
++/**
++ *  Remove the logger from the system
++ */
+++ (void)removeLogger:(id <DDLogger>)logger;
++
++/**
++ *  Remove all the current loggers
++ */
+++ (void)removeAllLoggers;
++
++/**
++ *  Return all the current loggers
++ */
+++ (NSArray *)allLoggers;
++
++/**
++ * Registered Dynamic Logging
++ *
++ * These methods allow you to obtain a list of classes that are using registered dynamic logging,
++ * and also provides methods to get and set their log level during run time.
++ **/
++
++/**
++ *  Returns an array with the classes that are using registered dynamic logging
++ */
+++ (NSArray *)registeredClasses;
++
++/**
++ *  Returns an array with the classes names that are using registered dynamic logging
++ */
+++ (NSArray *)registeredClassNames;
++
++/**
++ *  Returns the current log level for a certain class
++ *
++ *  @param aClass `Class` param
++ */
+++ (DDLogLevel)levelForClass:(Class)aClass;
++
++/**
++ *  Returns the current log level for a certain class
++ *
++ *  @param aClassName string param
++ */
+++ (DDLogLevel)levelForClassWithName:(NSString *)aClassName;
++
++/**
++ *  Set the log level for a certain class
++ *
++ *  @param level  the new level
++ *  @param aClass `Class` param
++ */
+++ (void)setLevel:(DDLogLevel)level forClass:(Class)aClass;
++
++/**
++ *  Set the log level for a certain class
++ *
++ *  @param level      the new level
++ *  @param aClassName string param
++ */
+++ (void)setLevel:(DDLogLevel)level forClassWithName:(NSString *)aClassName;
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++/**
++ *  This protocol describes a basic logger behavior. 
++ *  Basically, it can log messages, store a logFormatter plus a bunch of optional behaviors.
++ *  (i.e. flush, get its loggerQueue, get its name, ...
++ */
++@protocol DDLogger <NSObject>
++
++/**
++ *  The log message method
++ *
++ *  @param logMessage the message (model)
++ */
++- (void)logMessage:(DDLogMessage *)logMessage;
++
++/**
++ * Formatters may optionally be added to any logger.
++ *
++ * If no formatter is set, the logger simply logs the message as it is given in logMessage,
++ * or it may use its own built in formatting style.
++ **/
++@property (nonatomic, strong) id <DDLogFormatter> logFormatter;
++
++@optional
++
++/**
++ * Since logging is asynchronous, adding and removing loggers is also asynchronous.
++ * In other words, the loggers are added and removed at appropriate times with regards to log messages.
++ *
++ * - Loggers will not receive log messages that were executed prior to when they were added.
++ * - Loggers will not receive log messages that were executed after they were removed.
++ *
++ * These methods are executed in the logging thread/queue.
++ * This is the same thread/queue that will execute every logMessage: invocation.
++ * Loggers may use these methods for thread synchronization or other setup/teardown tasks.
++ **/
++- (void)didAddLogger;
++
++/**
++ *  See the above description for `didAddLoger`
++ */
++- (void)willRemoveLogger;
++
++/**
++ * Some loggers may buffer IO for optimization purposes.
++ * For example, a database logger may only save occasionaly as the disk IO is slow.
++ * In such loggers, this method should be implemented to flush any pending IO.
++ *
++ * This allows invocations of DDLog's flushLog method to be propogated to loggers that need it.
++ *
++ * Note that DDLog's flushLog method is invoked automatically when the application quits,
++ * and it may be also invoked manually by the developer prior to application crashes, or other such reasons.
++ **/
++- (void)flush;
++
++/**
++ * Each logger is executed concurrently with respect to the other loggers.
++ * Thus, a dedicated dispatch queue is used for each logger.
++ * Logger implementations may optionally choose to provide their own dispatch queue.
++ **/
++@property (nonatomic, DISPATCH_QUEUE_REFERENCE_TYPE, readonly) dispatch_queue_t loggerQueue;
++
++/**
++ * If the logger implementation does not choose to provide its own queue,
++ * one will automatically be created for it.
++ * The created queue will receive its name from this method.
++ * This may be helpful for debugging or profiling reasons.
++ **/
++@property (nonatomic, readonly) NSString *loggerName;
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++/**
++ *  This protocol describes the behavior of a log formatter
++ */
++@protocol DDLogFormatter <NSObject>
++@required
++
++/**
++ * Formatters may optionally be added to any logger.
++ * This allows for increased flexibility in the logging environment.
++ * For example, log messages for log files may be formatted differently than log messages for the console.
++ *
++ * For more information about formatters, see the "Custom Formatters" page:
++ * Documentation/CustomFormatters.md
++ *
++ * The formatter may also optionally filter the log message by returning nil,
++ * in which case the logger will not log the message.
++ **/
++- (NSString *)formatLogMessage:(DDLogMessage *)logMessage;
++
++@optional
++
++/**
++ * A single formatter instance can be added to multiple loggers.
++ * These methods provides hooks to notify the formatter of when it's added/removed.
++ *
++ * This is primarily for thread-safety.
++ * If a formatter is explicitly not thread-safe, it may wish to throw an exception if added to multiple loggers.
++ * Or if a formatter has potentially thread-unsafe code (e.g. NSDateFormatter),
++ * it could possibly use these hooks to switch to thread-safe versions of the code.
++ **/
++- (void)didAddToLogger:(id <DDLogger>)logger;
++
++/**
++ *  See the above description for `didAddToLogger:`
++ */
++- (void)willRemoveFromLogger:(id <DDLogger>)logger;
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++/**
++ *  This protocol describes a dynamic logging component
++ */
++@protocol DDRegisteredDynamicLogging
++
++/**
++ * Implement these methods to allow a file's log level to be managed from a central location.
++ *
++ * This is useful if you'd like to be able to change log levels for various parts
++ * of your code from within the running application.
++ *
++ * Imagine pulling up the settings for your application,
++ * and being able to configure the logging level on a per file basis.
++ *
++ * The implementation can be very straight-forward:
++ *
++ * ```
++ * + (int)ddLogLevel
++ * {
++ *     return ddLogLevel;
++ * }
++ *
++ * + (void)ddSetLogLevel:(DDLogLevel)level
++ * {
++ *     ddLogLevel = level;
++ * }
++ * ```
++ **/
+++ (DDLogLevel)ddLogLevel;
++
++/**
++ *  See the above description for `ddLogLevel`
++ */
+++ (void)ddSetLogLevel:(DDLogLevel)level;
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++#ifndef NS_DESIGNATED_INITIALIZER
++    #define NS_DESIGNATED_INITIALIZER
++#endif
++
++/**
++ *  Log message options, allow copying certain log elements
++ */
++typedef NS_OPTIONS(NSInteger, DDLogMessageOptions){
++    /**
++     *  Use this to use a copy of the file path
++     */
++    DDLogMessageCopyFile     = 1 << 0,
++    /**
++     *  Use this to use a copy of the function name
++     */
++    DDLogMessageCopyFunction = 1 << 1
++};
++
++/**
++ * The `DDLogMessage` class encapsulates information about the log message.
++ * If you write custom loggers or formatters, you will be dealing with objects of this class.
++ **/
++@interface DDLogMessage : NSObject <NSCopying>
++{
++    // Direct accessors to be used only for performance
++    @public
++    NSString *_message;
++    DDLogLevel _level;
++    DDLogFlag _flag;
++    NSInteger _context;
++    NSString *_file;
++    NSString *_fileName;
++    NSString *_function;
++    NSUInteger _line;
++    id _tag;
++    DDLogMessageOptions _options;
++    NSDate *_timestamp;
++    NSString *_threadID;
++    NSString *_threadName;
++    NSString *_queueLabel;
++}
++
++/**
++ *  Default `init` is not available
++ */
++- (instancetype)init NS_UNAVAILABLE;
++
++/**
++ * Standard init method for a log message object.
++ * Used by the logging primitives. (And the macros use the logging primitives.)
++ *
++ * If you find need to manually create logMessage objects, there is one thing you should be aware of:
++ *
++ * If no flags are passed, the method expects the file and function parameters to be string literals.
++ * That is, it expects the given strings to exist for the duration of the object's lifetime,
++ * and it expects the given strings to be immutable.
++ * In other words, it does not copy these strings, it simply points to them.
++ * This is due to the fact that __FILE__ and __FUNCTION__ are usually used to specify these parameters,
++ * so it makes sense to optimize and skip the unnecessary allocations.
++ * However, if you need them to be copied you may use the options parameter to specify this.
++ *
++ *  @param message   the message
++ *  @param level     the log level
++ *  @param flag      the log flag
++ *  @param context   the context (if any is defined)
++ *  @param file      the current file
++ *  @param function  the current function
++ *  @param line      the current code line
++ *  @param tag       potential tag
++ *  @param options   a bitmask which supports DDLogMessageCopyFile and DDLogMessageCopyFunction.
++ *  @param timestamp the log timestamp
++ *
++ *  @return a new instance of a log message model object
++ */
++- (instancetype)initWithMessage:(NSString *)message
++                          level:(DDLogLevel)level
++                           flag:(DDLogFlag)flag
++                        context:(NSInteger)context
++                           file:(NSString *)file
++                       function:(NSString *)function
++                           line:(NSUInteger)line
++                            tag:(id)tag
++                        options:(DDLogMessageOptions)options
++                      timestamp:(NSDate *)timestamp NS_DESIGNATED_INITIALIZER;
++
++/**
++ * Read-only properties
++ **/
++
++/**
++ *  The log message
++ */
++@property (readonly, nonatomic) NSString *message;
++@property (readonly, nonatomic) DDLogLevel level;
++@property (readonly, nonatomic) DDLogFlag flag;
++@property (readonly, nonatomic) NSInteger context;
++@property (readonly, nonatomic) NSString *file;
++@property (readonly, nonatomic) NSString *fileName;
++@property (readonly, nonatomic) NSString *function;
++@property (readonly, nonatomic) NSUInteger line;
++@property (readonly, nonatomic) id tag;
++@property (readonly, nonatomic) DDLogMessageOptions options;
++@property (readonly, nonatomic) NSDate *timestamp;
++@property (readonly, nonatomic) NSString *threadID; // ID as it appears in NSLog calculated from the machThreadID
++@property (readonly, nonatomic) NSString *threadName;
++@property (readonly, nonatomic) NSString *queueLabel;
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++/**
++ * The `DDLogger` protocol specifies that an optional formatter can be added to a logger.
++ * Most (but not all) loggers will want to support formatters.
++ *
++ * However, writting getters and setters in a thread safe manner,
++ * while still maintaining maximum speed for the logging process, is a difficult task.
++ *
++ * To do it right, the implementation of the getter/setter has strict requiremenets:
++ * - Must NOT require the `logMessage:` method to acquire a lock.
++ * - Must NOT require the `logMessage:` method to access an atomic property (also a lock of sorts).
++ *
++ * To simplify things, an abstract logger is provided that implements the getter and setter.
++ *
++ * Logger implementations may simply extend this class,
++ * and they can ACCESS THE FORMATTER VARIABLE DIRECTLY from within their `logMessage:` method!
++ **/
++@interface DDAbstractLogger : NSObject <DDLogger>
++{
++    // Direct accessors to be used only for performance
++    @public
++    id <DDLogFormatter> _logFormatter;
++    dispatch_queue_t _loggerQueue;
++}
++
++@property (nonatomic, strong) id <DDLogFormatter> logFormatter;
++@property (nonatomic, DISPATCH_QUEUE_REFERENCE_TYPE) dispatch_queue_t loggerQueue;
++
++// For thread-safety assertions
++
++/**
++ *  Return YES if the current logger uses a global queue for logging
++ */
++@property (nonatomic, readonly, getter=isOnGlobalLoggingQueue)  BOOL onGlobalLoggingQueue;
++
++/**
++ *  Return YES if the current logger uses the internal designated queue for logging
++ */
++@property (nonatomic, readonly, getter=isOnInternalLoggerQueue) BOOL onInternalLoggerQueue;
++
++@end
++
+diff --git a/Pods/CocoaLumberjack/Classes/DDLog.m b/Pods/CocoaLumberjack/Classes/DDLog.m
+new file mode 100644
+index 0000000..03c6e7c
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDLog.m
+@@ -0,0 +1,1167 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++// Disable legacy macros
++#ifndef DD_LEGACY_MACROS
++    #define DD_LEGACY_MACROS 0
++#endif
++
++#import "DDLog.h"
++
++#import <pthread.h>
++#import <objc/runtime.h>
++#import <mach/mach_host.h>
++#import <mach/host_info.h>
++#import <libkern/OSAtomic.h>
++#import <Availability.h>
++#if TARGET_OS_IOS
++    #import <UIKit/UIDevice.h>
++#endif
++
++
++#if !__has_feature(objc_arc)
++#error This file must be compiled with ARC. Use -fobjc-arc flag (or convert project to ARC).
++#endif
++
++// We probably shouldn't be using DDLog() statements within the DDLog implementation.
++// But we still want to leave our log statements for any future debugging,
++// and to allow other developers to trace the implementation (which is a great learning tool).
++//
++// So we use a primitive logging macro around NSLog.
++// We maintain the NS prefix on the macros to be explicit about the fact that we're using NSLog.
++
++#ifndef DD_DEBUG
++    #define DD_DEBUG NO
++#endif
++
++#define NSLogDebug(frmt, ...) do{ if(DD_DEBUG) NSLog((frmt), ##__VA_ARGS__); } while(0)
++
++// Specifies the maximum queue size of the logging thread.
++//
++// Since most logging is asynchronous, its possible for rogue threads to flood the logging queue.
++// That is, to issue an abundance of log statements faster than the logging thread can keepup.
++// Typically such a scenario occurs when log statements are added haphazardly within large loops,
++// but may also be possible if relatively slow loggers are being used.
++//
++// This property caps the queue size at a given number of outstanding log statements.
++// If a thread attempts to issue a log statement when the queue is already maxed out,
++// the issuing thread will block until the queue size drops below the max again.
++
++#define LOG_MAX_QUEUE_SIZE 1000 // Should not exceed INT32_MAX
++
++// The "global logging queue" refers to [DDLog loggingQueue].
++// It is the queue that all log statements go through.
++//
++// The logging queue sets a flag via dispatch_queue_set_specific using this key.
++// We can check for this key via dispatch_get_specific() to see if we're on the "global logging queue".
++
++static void *const GlobalLoggingQueueIdentityKey = (void *)&GlobalLoggingQueueIdentityKey;
++
++@interface DDLoggerNode : NSObject
++{
++    // Direct accessors to be used only for performance
++    @public
++    id <DDLogger> _logger;
++    DDLogLevel _level;
++    dispatch_queue_t _loggerQueue;
++}
++
++@property (nonatomic, readonly) id <DDLogger> logger;
++@property (nonatomic, readonly) DDLogLevel level;
++@property (nonatomic, readonly) dispatch_queue_t loggerQueue;
++
+++ (DDLoggerNode *)nodeWithLogger:(id <DDLogger>)logger
++                     loggerQueue:(dispatch_queue_t)loggerQueue
++                           level:(DDLogLevel)level;
++
++@end
++
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++@implementation DDLog
++
++// An array used to manage all the individual loggers.
++// The array is only modified on the loggingQueue/loggingThread.
++static NSMutableArray *_loggers;
++
++// All logging statements are added to the same queue to ensure FIFO operation.
++static dispatch_queue_t _loggingQueue;
++
++// Individual loggers are executed concurrently per log statement.
++// Each logger has it's own associated queue, and a dispatch group is used for synchrnoization.
++static dispatch_group_t _loggingGroup;
++
++// In order to prevent to queue from growing infinitely large,
++// a maximum size is enforced (LOG_MAX_QUEUE_SIZE).
++static dispatch_semaphore_t _queueSemaphore;
++
++// Minor optimization for uniprocessor machines
++static NSUInteger _numProcessors;
++
++/**
++ * The runtime sends initialize to each class in a program exactly one time just before the class,
++ * or any class that inherits from it, is sent its first message from within the program. (Thus the
++ * method may never be invoked if the class is not used.) The runtime sends the initialize message to
++ * classes in a thread-safe manner. Superclasses receive this message before their subclasses.
++ *
++ * This method may also be called directly (assumably by accident), hence the safety mechanism.
++ **/
+++ (void)initialize {
++    static dispatch_once_t DDLogOnceToken;
++
++    dispatch_once(&DDLogOnceToken, ^{
++        _loggers = [[NSMutableArray alloc] initWithCapacity:4];
++
++        NSLogDebug(@"DDLog: Using grand central dispatch");
++
++        _loggingQueue = dispatch_queue_create("cocoa.lumberjack", NULL);
++        _loggingGroup = dispatch_group_create();
++
++        void *nonNullValue = GlobalLoggingQueueIdentityKey; // Whatever, just not null
++        dispatch_queue_set_specific(_loggingQueue, GlobalLoggingQueueIdentityKey, nonNullValue, NULL);
++
++        _queueSemaphore = dispatch_semaphore_create(LOG_MAX_QUEUE_SIZE);
++
++        // Figure out how many processors are available.
++        // This may be used later for an optimization on uniprocessor machines.
++        
++        _numProcessors = MAX([NSProcessInfo processInfo].processorCount, 1);
++
++        NSLogDebug(@"DDLog: numProcessors = %@", @(_numProcessors));
++
++
++#if TARGET_OS_IOS
++        NSString *notificationName = @"UIApplicationWillTerminateNotification";
++#else
++        NSString *notificationName = nil;
++
++        // On Command Line Tool apps AppKit may not be avaliable
++#ifdef NSAppKitVersionNumber10_0
++
++        if (NSApp) {
++            notificationName = @"NSApplicationWillTerminateNotification";
++        }
++
++#endif
++
++        if (!notificationName) {
++            // If there is no NSApp -> we are running Command Line Tool app.
++            // In this case terminate notification wouldn't be fired, so we use workaround.
++            atexit_b (^{
++                [self applicationWillTerminate:nil];
++            });
++        }
++
++#endif /* if TARGET_OS_IOS */
++
++        if (notificationName) {
++            [[NSNotificationCenter defaultCenter] addObserver:self
++                                                     selector:@selector(applicationWillTerminate:)
++                                                         name:notificationName
++                                                       object:nil];
++        }
++    });
++}
++
++/**
++ * Provides access to the logging queue.
++ **/
+++ (dispatch_queue_t)loggingQueue {
++    return _loggingQueue;
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Notifications
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
+++ (void)applicationWillTerminate:(NSNotification * __attribute__((unused)))notification {
++    [self flushLog];
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Logger Management
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
+++ (void)addLogger:(id <DDLogger>)logger {
++    [self addLogger:logger withLevel:DDLogLevelAll]; // DDLogLevelAll has all bits set
++}
++
+++ (void)addLogger:(id <DDLogger>)logger withLevel:(DDLogLevel)level {
++    if (!logger) {
++        return;
++    }
++
++    dispatch_async(_loggingQueue, ^{ @autoreleasepool {
++                                        [self lt_addLogger:logger level:level];
++                                    } });
++}
++
+++ (void)removeLogger:(id <DDLogger>)logger {
++    if (!logger) {
++        return;
++    }
++
++    dispatch_async(_loggingQueue, ^{ @autoreleasepool {
++                                        [self lt_removeLogger:logger];
++                                    } });
++}
++
+++ (void)removeAllLoggers {
++    dispatch_async(_loggingQueue, ^{ @autoreleasepool {
++                                        [self lt_removeAllLoggers];
++                                    } });
++}
++
+++ (NSArray *)allLoggers {
++    __block NSArray *theLoggers;
++
++    dispatch_sync(_loggingQueue, ^{ @autoreleasepool {
++                                       theLoggers = [self lt_allLoggers];
++                                   } });
++
++    return theLoggers;
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark - Master Logging
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
+++ (void)queueLogMessage:(DDLogMessage *)logMessage asynchronously:(BOOL)asyncFlag {
++    // We have a tricky situation here...
++    //
++    // In the common case, when the queueSize is below the maximumQueueSize,
++    // we want to simply enqueue the logMessage. And we want to do this as fast as possible,
++    // which means we don't want to block and we don't want to use any locks.
++    //
++    // However, if the queueSize gets too big, we want to block.
++    // But we have very strict requirements as to when we block, and how long we block.
++    //
++    // The following example should help illustrate our requirements:
++    //
++    // Imagine that the maximum queue size is configured to be 5,
++    // and that there are already 5 log messages queued.
++    // Let us call these 5 queued log messages A, B, C, D, and E. (A is next to be executed)
++    //
++    // Now if our thread issues a log statement (let us call the log message F),
++    // it should block before the message is added to the queue.
++    // Furthermore, it should be unblocked immediately after A has been unqueued.
++    //
++    // The requirements are strict in this manner so that we block only as long as necessary,
++    // and so that blocked threads are unblocked in the order in which they were blocked.
++    //
++    // Returning to our previous example, let us assume that log messages A through E are still queued.
++    // Our aforementioned thread is blocked attempting to queue log message F.
++    // Now assume we have another separate thread that attempts to issue log message G.
++    // It should block until log messages A and B have been unqueued.
++
++
++    // We are using a counting semaphore provided by GCD.
++    // The semaphore is initialized with our LOG_MAX_QUEUE_SIZE value.
++    // Everytime we want to queue a log message we decrement this value.
++    // If the resulting value is less than zero,
++    // the semaphore function waits in FIFO order for a signal to occur before returning.
++    //
++    // A dispatch semaphore is an efficient implementation of a traditional counting semaphore.
++    // Dispatch semaphores call down to the kernel only when the calling thread needs to be blocked.
++    // If the calling semaphore does not need to block, no kernel call is made.
++
++    dispatch_semaphore_wait(_queueSemaphore, DISPATCH_TIME_FOREVER);
++
++    // We've now sure we won't overflow the queue.
++    // It is time to queue our log message.
++
++    dispatch_block_t logBlock = ^{
++        @autoreleasepool {
++            [self lt_log:logMessage];
++        }
++    };
++
++    if (asyncFlag) {
++        dispatch_async(_loggingQueue, logBlock);
++    } else {
++        dispatch_sync(_loggingQueue, logBlock);
++    }
++}
++
+++ (void)log:(BOOL)asynchronous
++      level:(DDLogLevel)level
++       flag:(DDLogFlag)flag
++    context:(NSInteger)context
++       file:(const char *)file
++   function:(const char *)function
++       line:(NSUInteger)line
++        tag:(id)tag
++     format:(NSString *)format, ... {
++    va_list args;
++    
++    if (format) {
++        va_start(args, format);
++        
++        NSString *message = [[NSString alloc] initWithFormat:format arguments:args];
++        [self log:asynchronous
++          message:message
++            level:level
++             flag:flag
++          context:context
++             file:file
++         function:function
++             line:line
++              tag:tag];
++
++        va_end(args);
++    }
++}
++
+++ (void)log:(BOOL)asynchronous
++      level:(DDLogLevel)level
++       flag:(DDLogFlag)flag
++    context:(NSInteger)context
++       file:(const char *)file
++   function:(const char *)function
++       line:(NSUInteger)line
++        tag:(id)tag
++     format:(NSString *)format
++       args:(va_list)args {
++    
++    if (format) {
++        NSString *message = [[NSString alloc] initWithFormat:format arguments:args];
++        [self log:asynchronous
++          message:message
++            level:level
++             flag:flag
++          context:context
++             file:file
++         function:function
++             line:line
++              tag:tag];
++    }
++}
++
+++ (void)log:(BOOL)asynchronous
++    message:(NSString *)message
++      level:(DDLogLevel)level
++       flag:(DDLogFlag)flag
++    context:(NSInteger)context
++       file:(const char *)file
++   function:(const char *)function
++       line:(NSUInteger)line
++        tag:(id)tag {
++    
++    DDLogMessage *logMessage = [[DDLogMessage alloc] initWithMessage:message
++                                                               level:level
++                                                                flag:flag
++                                                             context:context
++                                                                file:[NSString stringWithFormat:@"%s", file]
++                                                            function:[NSString stringWithFormat:@"%s", function]
++                                                                line:line
++                                                                 tag:tag
++                                                             options:(DDLogMessageOptions)0
++                                                           timestamp:nil];
++    
++    [self queueLogMessage:logMessage asynchronously:asynchronous];
++}
++
+++ (void)log:(BOOL)asynchronous
++    message:(DDLogMessage *)logMessage {
++    [self queueLogMessage:logMessage asynchronously:asynchronous];
++}
++
+++ (void)flushLog {
++    dispatch_sync(_loggingQueue, ^{ @autoreleasepool {
++                                       [self lt_flush];
++                                   } });
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Registered Dynamic Logging
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
+++ (BOOL)isRegisteredClass:(Class)class {
++    SEL getterSel = @selector(ddLogLevel);
++    SEL setterSel = @selector(ddSetLogLevel:);
++
++#if TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR
++
++    // Issue #6 (GoogleCode) - Crashes on iOS 4.2.1 and iPhone 4
++    //
++    // Crash caused by class_getClassMethod(2).
++    //
++    //     "It's a bug with UIAccessibilitySafeCategory__NSObject so it didn't pop up until
++    //      users had VoiceOver enabled [...]. I was able to work around it by searching the
++    //      result of class_copyMethodList() instead of calling class_getClassMethod()"
++
++    BOOL result = NO;
++
++    unsigned int methodCount, i;
++    Method *methodList = class_copyMethodList(object_getClass(class), &methodCount);
++
++    if (methodList != NULL) {
++        BOOL getterFound = NO;
++        BOOL setterFound = NO;
++
++        for (i = 0; i < methodCount; ++i) {
++            SEL currentSel = method_getName(methodList[i]);
++
++            if (currentSel == getterSel) {
++                getterFound = YES;
++            } else if (currentSel == setterSel) {
++                setterFound = YES;
++            }
++
++            if (getterFound && setterFound) {
++                result = YES;
++                break;
++            }
++        }
++
++        free(methodList);
++    }
++
++    return result;
++
++#else /* if TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR */
++
++    // Issue #24 (GitHub) - Crashing in in ARC+Simulator
++    //
++    // The method +[DDLog isRegisteredClass] will crash a project when using it with ARC + Simulator.
++    // For running in the Simulator, it needs to execute the non-iOS code.
++
++    Method getter = class_getClassMethod(class, getterSel);
++    Method setter = class_getClassMethod(class, setterSel);
++
++    if ((getter != NULL) && (setter != NULL)) {
++        return YES;
++    }
++
++    return NO;
++
++#endif /* if TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR */
++}
++
+++ (NSArray *)registeredClasses {
++
++    // We're going to get the list of all registered classes.
++    // The Objective-C runtime library automatically registers all the classes defined in your source code.
++    //
++    // To do this we use the following method (documented in the Objective-C Runtime Reference):
++    //
++    // int objc_getClassList(Class *buffer, int bufferLen)
++    //
++    // We can pass (NULL, 0) to obtain the total number of
++    // registered class definitions without actually retrieving any class definitions.
++    // This allows us to allocate the minimum amount of memory needed for the application.
++
++    NSUInteger numClasses = 0;
++    Class *classes = NULL;
++
++    while (numClasses == 0) {
++
++        numClasses = (NSUInteger)MAX(objc_getClassList(NULL, 0), 0);
++
++        // numClasses now tells us how many classes we have (but it might change)
++        // So we can allocate our buffer, and get pointers to all the class definitions.
++
++        NSUInteger bufferSize = numClasses;
++
++        classes = numClasses ? (Class *)malloc(sizeof(Class) * bufferSize) : NULL;
++        if (classes == NULL) {
++            return nil; //no memory or classes?
++        }
++
++        numClasses = (NSUInteger)MAX(objc_getClassList(classes, (int)bufferSize),0);
++
++        if (numClasses > bufferSize || numClasses == 0) {
++            //apparently more classes added between calls (or a problem); try again
++            free(classes);
++            numClasses = 0;
++        }
++    }
++
++    // We can now loop through the classes, and test each one to see if it is a DDLogging class.
++
++    NSMutableArray *result = [NSMutableArray arrayWithCapacity:numClasses];
++
++    for (NSUInteger i = 0; i < numClasses; i++) {
++        Class class = classes[i];
++
++        if ([self isRegisteredClass:class]) {
++            [result addObject:class];
++        }
++    }
++
++    free(classes);
++
++    return result;
++}
++
+++ (NSArray *)registeredClassNames {
++    NSArray *registeredClasses = [self registeredClasses];
++    NSMutableArray *result = [NSMutableArray arrayWithCapacity:[registeredClasses count]];
++
++    for (Class class in registeredClasses) {
++        [result addObject:NSStringFromClass(class)];
++    }
++    return result;
++}
++
+++ (DDLogLevel)levelForClass:(Class)aClass {
++    if ([self isRegisteredClass:aClass]) {
++        return [aClass ddLogLevel];
++    }
++    return (DDLogLevel)-1;
++}
++
+++ (DDLogLevel)levelForClassWithName:(NSString *)aClassName {
++    Class aClass = NSClassFromString(aClassName);
++
++    return [self levelForClass:aClass];
++}
++
+++ (void)setLevel:(DDLogLevel)level forClass:(Class)aClass {
++    if ([self isRegisteredClass:aClass]) {
++        [aClass ddSetLogLevel:level];
++    }
++}
++
+++ (void)setLevel:(DDLogLevel)level forClassWithName:(NSString *)aClassName {
++    Class aClass = NSClassFromString(aClassName);
++    [self setLevel:level forClass:aClass];
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Logging Thread
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
+++ (void)lt_addLogger:(id <DDLogger>)logger level:(DDLogLevel)level {
++    // Add to loggers array.
++    // Need to create loggerQueue if loggerNode doesn't provide one.
++
++    NSAssert(dispatch_get_specific(GlobalLoggingQueueIdentityKey),
++             @"This method should only be run on the logging thread/queue");
++
++    dispatch_queue_t loggerQueue = NULL;
++
++    if ([logger respondsToSelector:@selector(loggerQueue)]) {
++        // Logger may be providing its own queue
++
++        loggerQueue = [logger loggerQueue];
++    }
++
++    if (loggerQueue == nil) {
++        // Automatically create queue for the logger.
++        // Use the logger name as the queue name if possible.
++
++        const char *loggerQueueName = NULL;
++
++        if ([logger respondsToSelector:@selector(loggerName)]) {
++            loggerQueueName = [[logger loggerName] UTF8String];
++        }
++
++        loggerQueue = dispatch_queue_create(loggerQueueName, NULL);
++    }
++
++    DDLoggerNode *loggerNode = [DDLoggerNode nodeWithLogger:logger loggerQueue:loggerQueue level:level];
++    [_loggers addObject:loggerNode];
++
++    if ([logger respondsToSelector:@selector(didAddLogger)]) {
++        dispatch_async(loggerNode->_loggerQueue, ^{ @autoreleasepool {
++            [logger didAddLogger];
++        } });
++    }
++}
++
+++ (void)lt_removeLogger:(id <DDLogger>)logger {
++    // Find associated loggerNode in list of added loggers
++
++    NSAssert(dispatch_get_specific(GlobalLoggingQueueIdentityKey),
++             @"This method should only be run on the logging thread/queue");
++
++    DDLoggerNode *loggerNode = nil;
++
++    for (DDLoggerNode *node in _loggers) {
++        if (node->_logger == logger) {
++            loggerNode = node;
++            break;
++        }
++    }
++    
++    if (loggerNode == nil) {
++        NSLogDebug(@"DDLog: Request to remove logger which wasn't added");
++        return;
++    }
++    
++    // Notify logger
++    if ([logger respondsToSelector:@selector(willRemoveLogger)]) {
++        dispatch_async(loggerNode->_loggerQueue, ^{ @autoreleasepool {
++            [logger willRemoveLogger];
++        } });
++    }
++    
++    // Remove from loggers array
++    [_loggers removeObject:loggerNode];
++}
++
+++ (void)lt_removeAllLoggers {
++    NSAssert(dispatch_get_specific(GlobalLoggingQueueIdentityKey),
++             @"This method should only be run on the logging thread/queue");
++    
++    // Notify all loggers
++    for (DDLoggerNode *loggerNode in _loggers) {
++        if ([loggerNode->_logger respondsToSelector:@selector(willRemoveLogger)]) {
++            dispatch_async(loggerNode->_loggerQueue, ^{ @autoreleasepool {
++                [loggerNode->_logger willRemoveLogger];
++            } });
++        }
++    }
++    
++    // Remove all loggers from array
++
++    [_loggers removeAllObjects];
++}
++
+++ (NSArray *)lt_allLoggers {
++    NSAssert(dispatch_get_specific(GlobalLoggingQueueIdentityKey),
++             @"This method should only be run on the logging thread/queue");
++
++    NSMutableArray *theLoggers = [NSMutableArray new];
++
++    for (DDLoggerNode *loggerNode in _loggers) {
++        [theLoggers addObject:loggerNode->_logger];
++    }
++
++    return [theLoggers copy];
++}
++
+++ (void)lt_log:(DDLogMessage *)logMessage {
++    // Execute the given log message on each of our loggers.
++
++    NSAssert(dispatch_get_specific(GlobalLoggingQueueIdentityKey),
++             @"This method should only be run on the logging thread/queue");
++
++    if (_numProcessors > 1) {
++        // Execute each logger concurrently, each within its own queue.
++        // All blocks are added to same group.
++        // After each block has been queued, wait on group.
++        //
++        // The waiting ensures that a slow logger doesn't end up with a large queue of pending log messages.
++        // This would defeat the purpose of the efforts we made earlier to restrict the max queue size.
++
++        for (DDLoggerNode *loggerNode in _loggers) {
++            // skip the loggers that shouldn't write this message based on the log level
++
++            if (!(logMessage->_flag & loggerNode->_level)) {
++                continue;
++            }
++            
++            dispatch_group_async(_loggingGroup, loggerNode->_loggerQueue, ^{ @autoreleasepool {
++                [loggerNode->_logger logMessage:logMessage];
++            } });
++        }
++        
++        dispatch_group_wait(_loggingGroup, DISPATCH_TIME_FOREVER);
++    } else {
++        // Execute each logger serialy, each within its own queue.
++        
++        for (DDLoggerNode *loggerNode in _loggers) {
++            // skip the loggers that shouldn't write this message based on the log level
++
++            if (!(logMessage->_flag & loggerNode->_level)) {
++                continue;
++            }
++            
++            dispatch_sync(loggerNode->_loggerQueue, ^{ @autoreleasepool {
++                [loggerNode->_logger logMessage:logMessage];
++            } });
++        }
++    }
++
++    // If our queue got too big, there may be blocked threads waiting to add log messages to the queue.
++    // Since we've now dequeued an item from the log, we may need to unblock the next thread.
++
++    // We are using a counting semaphore provided by GCD.
++    // The semaphore is initialized with our LOG_MAX_QUEUE_SIZE value.
++    // When a log message is queued this value is decremented.
++    // When a log message is dequeued this value is incremented.
++    // If the value ever drops below zero,
++    // the queueing thread blocks and waits in FIFO order for us to signal it.
++    //
++    // A dispatch semaphore is an efficient implementation of a traditional counting semaphore.
++    // Dispatch semaphores call down to the kernel only when the calling thread needs to be blocked.
++    // If the calling semaphore does not need to block, no kernel call is made.
++
++    dispatch_semaphore_signal(_queueSemaphore);
++}
++
+++ (void)lt_flush {
++    // All log statements issued before the flush method was invoked have now been executed.
++    //
++    // Now we need to propogate the flush request to any loggers that implement the flush method.
++    // This is designed for loggers that buffer IO.
++    
++    NSAssert(dispatch_get_specific(GlobalLoggingQueueIdentityKey),
++             @"This method should only be run on the logging thread/queue");
++    
++    for (DDLoggerNode *loggerNode in _loggers) {
++        if ([loggerNode->_logger respondsToSelector:@selector(flush)]) {
++            dispatch_group_async(_loggingGroup, loggerNode->_loggerQueue, ^{ @autoreleasepool {
++                [loggerNode->_logger flush];
++            } });
++        }
++    }
++    
++    dispatch_group_wait(_loggingGroup, DISPATCH_TIME_FOREVER);
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Utilities
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++NSString * DDExtractFileNameWithoutExtension(const char *filePath, BOOL copy) {
++    if (filePath == NULL) {
++        return nil;
++    }
++
++    char *lastSlash = NULL;
++    char *lastDot = NULL;
++
++    char *p = (char *)filePath;
++
++    while (*p != '\0') {
++        if (*p == '/') {
++            lastSlash = p;
++        } else if (*p == '.') {
++            lastDot = p;
++        }
++
++        p++;
++    }
++
++    char *subStr;
++    NSUInteger subLen;
++
++    if (lastSlash) {
++        if (lastDot) {
++            // lastSlash -> lastDot
++            subStr = lastSlash + 1;
++            subLen = (NSUInteger)(lastDot - subStr);
++        } else {
++            // lastSlash -> endOfString
++            subStr = lastSlash + 1;
++            subLen = (NSUInteger)(p - subStr);
++        }
++    } else {
++        if (lastDot) {
++            // startOfString -> lastDot
++            subStr = (char *)filePath;
++            subLen = (NSUInteger)(lastDot - subStr);
++        } else {
++            // startOfString -> endOfString
++            subStr = (char *)filePath;
++            subLen = (NSUInteger)(p - subStr);
++        }
++    }
++
++    if (copy) {
++        return [[NSString alloc] initWithBytes:subStr
++                                        length:subLen
++                                      encoding:NSUTF8StringEncoding];
++    } else {
++        // We can take advantage of the fact that __FILE__ is a string literal.
++        // Specifically, we don't need to waste time copying the string.
++        // We can just tell NSString to point to a range within the string literal.
++
++        return [[NSString alloc] initWithBytesNoCopy:subStr
++                                              length:subLen
++                                            encoding:NSUTF8StringEncoding
++                                        freeWhenDone:NO];
++    }
++}
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++@implementation DDLoggerNode
++
++- (instancetype)initWithLogger:(id <DDLogger>)logger loggerQueue:(dispatch_queue_t)loggerQueue level:(DDLogLevel)level {
++    if ((self = [super init])) {
++        _logger = logger;
++
++        if (loggerQueue) {
++            _loggerQueue = loggerQueue;
++            #if !OS_OBJECT_USE_OBJC
++            dispatch_retain(loggerQueue);
++            #endif
++        }
++
++        _level = level;
++    }
++    return self;
++}
++
+++ (DDLoggerNode *)nodeWithLogger:(id <DDLogger>)logger loggerQueue:(dispatch_queue_t)loggerQueue level:(DDLogLevel)level {
++    return [[DDLoggerNode alloc] initWithLogger:logger loggerQueue:loggerQueue level:level];
++}
++
++- (void)dealloc {
++    #if !OS_OBJECT_USE_OBJC
++    if (_loggerQueue) {
++        dispatch_release(_loggerQueue);
++    }
++    #endif
++}
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++@implementation DDLogMessage
++
++// Can we use DISPATCH_CURRENT_QUEUE_LABEL ?
++// Can we use dispatch_get_current_queue (without it crashing) ?
++//
++// a) Compiling against newer SDK's (iOS 7+/OS X 10.9+) where DISPATCH_CURRENT_QUEUE_LABEL is defined
++//    on a (iOS 7.0+/OS X 10.9+) runtime version
++//
++// b) Systems where dispatch_get_current_queue is not yet deprecated and won't crash (< iOS 6.0/OS X 10.9)
++//
++//    dispatch_get_current_queue(void);
++//      __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_6,__MAC_10_9,__IPHONE_4_0,__IPHONE_6_0)
++
++#if TARGET_OS_IOS
++
++// Compiling for iOS
++
++    #define USE_DISPATCH_CURRENT_QUEUE_LABEL ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0)
++    #define USE_DISPATCH_GET_CURRENT_QUEUE   ([[[UIDevice currentDevice] systemVersion] floatValue] >= 6.1)
++
++#elif TARGET_OS_WATCH || TARGET_OS_TV
++
++// Compiling for watchOS, tvOS
++
++#define USE_DISPATCH_CURRENT_QUEUE_LABEL YES
++#define USE_DISPATCH_GET_CURRENT_QUEUE   YES
++
++#else
++
++// Compiling for Mac OS X
++
++  #ifndef MAC_OS_X_VERSION_10_9
++    #define MAC_OS_X_VERSION_10_9            1090
++  #endif
++
++  #if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_9 // Mac OS X 10.9 or later required
++
++    #define USE_DISPATCH_CURRENT_QUEUE_LABEL YES
++    #define USE_DISPATCH_GET_CURRENT_QUEUE   NO
++
++  #else
++
++    #define USE_DISPATCH_CURRENT_QUEUE_LABEL ([NSTimer instancesRespondToSelector : @selector(tolerance)]) // OS X 10.9+
++    #define USE_DISPATCH_GET_CURRENT_QUEUE   (![NSTimer instancesRespondToSelector : @selector(tolerance)]) // < OS X 10.9
++
++  #endif
++
++#endif /* if TARGET_OS_IOS */
++
++// Should we use pthread_threadid_np ?
++// With iOS 8+/OSX 10.10+ NSLog uses pthread_threadid_np instead of pthread_mach_thread_np
++
++#if TARGET_OS_IOS
++
++// Compiling for iOS
++
++  #ifndef kCFCoreFoundationVersionNumber_iOS_8_0
++    #define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10
++  #endif
++
++    #define USE_PTHREAD_THREADID_NP                (kCFCoreFoundationVersionNumber >= kCFCoreFoundationVersionNumber_iOS_8_0)
++
++#elif TARGET_OS_WATCH || TARGET_OS_TV
++
++// Compiling for watchOS, tvOS
++
++#define USE_PTHREAD_THREADID_NP                    YES
++
++#else
++
++// Compiling for Mac OS X
++
++  #ifndef kCFCoreFoundationVersionNumber10_10
++    #define kCFCoreFoundationVersionNumber10_10    1151.16
++  #endif
++
++    #define USE_PTHREAD_THREADID_NP                (kCFCoreFoundationVersionNumber >= kCFCoreFoundationVersionNumber10_10)
++
++#endif /* if TARGET_OS_IOS */
++
++- (instancetype)initWithMessage:(NSString *)message
++                          level:(DDLogLevel)level
++                           flag:(DDLogFlag)flag
++                        context:(NSInteger)context
++                           file:(NSString *)file
++                       function:(NSString *)function
++                           line:(NSUInteger)line
++                            tag:(id)tag
++                        options:(DDLogMessageOptions)options
++                      timestamp:(NSDate *)timestamp {
++    if ((self = [super init])) {
++        _message      = [message copy];
++        _level        = level;
++        _flag         = flag;
++        _context      = context;
++
++        BOOL copyFile = (options & DDLogMessageCopyFile) == DDLogMessageCopyFile;
++        _file = copyFile ? [file copy] : file;
++
++        BOOL copyFunction = (options & DDLogMessageCopyFunction) == DDLogMessageCopyFunction;
++        _function = copyFunction ? [function copy] : function;
++
++        _line         = line;
++        _tag          = tag;
++        _options      = options;
++        _timestamp    = timestamp ?: [NSDate new];
++
++        if (USE_PTHREAD_THREADID_NP) {
++            __uint64_t tid;
++            pthread_threadid_np(NULL, &tid);
++            _threadID = [[NSString alloc] initWithFormat:@"%llu", tid];
++        } else {
++            _threadID = [[NSString alloc] initWithFormat:@"%x", pthread_mach_thread_np(pthread_self())];
++        }
++        _threadName   = NSThread.currentThread.name;
++
++        // Get the file name without extension
++        _fileName = [_file lastPathComponent];
++        NSUInteger dotLocation = [_fileName rangeOfString:@"." options:NSBackwardsSearch].location;
++        if (dotLocation != NSNotFound)
++        {
++            _fileName = [_fileName substringToIndex:dotLocation];
++        }
++        
++        // Try to get the current queue's label
++        if (USE_DISPATCH_CURRENT_QUEUE_LABEL) {
++            _queueLabel = [[NSString alloc] initWithFormat:@"%s", dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL)];
++        } else if (USE_DISPATCH_GET_CURRENT_QUEUE) {
++            #pragma clang diagnostic push
++            #pragma clang diagnostic ignored "-Wdeprecated-declarations"
++            dispatch_queue_t currentQueue = dispatch_get_current_queue();
++            #pragma clang diagnostic pop
++            _queueLabel = [[NSString alloc] initWithFormat:@"%s", dispatch_queue_get_label(currentQueue)];
++        } else {
++            _queueLabel = @""; // iOS 6.x only
++        }
++    }
++    return self;
++}
++
++- (id)copyWithZone:(NSZone * __attribute__((unused)))zone {
++    DDLogMessage *newMessage = [DDLogMessage new];
++    
++    newMessage->_message = _message;
++    newMessage->_level = _level;
++    newMessage->_flag = _flag;
++    newMessage->_context = _context;
++    newMessage->_file = _file;
++    newMessage->_fileName = _fileName;
++    newMessage->_function = _function;
++    newMessage->_line = _line;
++    newMessage->_tag = _tag;
++    newMessage->_options = _options;
++    newMessage->_timestamp = _timestamp;
++    newMessage->_threadID = _threadID;
++    newMessage->_threadName = _threadName;
++    newMessage->_queueLabel = _queueLabel;
++
++    return newMessage;
++}
++
++@end
++
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++@implementation DDAbstractLogger
++
++- (instancetype)init {
++    if ((self = [super init])) {
++        const char *loggerQueueName = NULL;
++
++        if ([self respondsToSelector:@selector(loggerName)]) {
++            loggerQueueName = [[self loggerName] UTF8String];
++        }
++
++        _loggerQueue = dispatch_queue_create(loggerQueueName, NULL);
++
++        // We're going to use dispatch_queue_set_specific() to "mark" our loggerQueue.
++        // Later we can use dispatch_get_specific() to determine if we're executing on our loggerQueue.
++        // The documentation states:
++        //
++        // > Keys are only compared as pointers and are never dereferenced.
++        // > Thus, you can use a pointer to a static variable for a specific subsystem or
++        // > any other value that allows you to identify the value uniquely.
++        // > Specifying a pointer to a string constant is not recommended.
++        //
++        // So we're going to use the very convenient key of "self",
++        // which also works when multiple logger classes extend this class, as each will have a different "self" key.
++        //
++        // This is used primarily for thread-safety assertions (via the isOnInternalLoggerQueue method below).
++
++        void *key = (__bridge void *)self;
++        void *nonNullValue = (__bridge void *)self;
++
++        dispatch_queue_set_specific(_loggerQueue, key, nonNullValue, NULL);
++    }
++
++    return self;
++}
++
++- (void)dealloc {
++    #if !OS_OBJECT_USE_OBJC
++
++    if (_loggerQueue) {
++        dispatch_release(_loggerQueue);
++    }
++
++    #endif
++}
++
++- (void)logMessage:(DDLogMessage * __attribute__((unused)))logMessage {
++    // Override me
++}
++
++- (id <DDLogFormatter>)logFormatter {
++    // This method must be thread safe and intuitive.
++    // Therefore if somebody executes the following code:
++    //
++    // [logger setLogFormatter:myFormatter];
++    // formatter = [logger logFormatter];
++    //
++    // They would expect formatter to equal myFormatter.
++    // This functionality must be ensured by the getter and setter method.
++    //
++    // The thread safety must not come at a cost to the performance of the logMessage method.
++    // This method is likely called sporadically, while the logMessage method is called repeatedly.
++    // This means, the implementation of this method:
++    // - Must NOT require the logMessage method to acquire a lock.
++    // - Must NOT require the logMessage method to access an atomic property (also a lock of sorts).
++    //
++    // Thread safety is ensured by executing access to the formatter variable on the loggerQueue.
++    // This is the same queue that the logMessage method operates on.
++    //
++    // Note: The last time I benchmarked the performance of direct access vs atomic property access,
++    // direct access was over twice as fast on the desktop and over 6 times as fast on the iPhone.
++    //
++    // Furthermore, consider the following code:
++    //
++    // DDLogVerbose(@"log msg 1");
++    // DDLogVerbose(@"log msg 2");
++    // [logger setFormatter:myFormatter];
++    // DDLogVerbose(@"log msg 3");
++    //
++    // Our intuitive requirement means that the new formatter will only apply to the 3rd log message.
++    // This must remain true even when using asynchronous logging.
++    // We must keep in mind the various queue's that are in play here:
++    //
++    // loggerQueue : Our own private internal queue that the logMessage method runs on.
++    //               Operations are added to this queue from the global loggingQueue.
++    //
++    // globalLoggingQueue : The queue that all log messages go through before they arrive in our loggerQueue.
++    //
++    // All log statements go through the serial gloabalLoggingQueue before they arrive at our loggerQueue.
++    // Thus this method also goes through the serial globalLoggingQueue to ensure intuitive operation.
++
++    // IMPORTANT NOTE:
++    //
++    // Methods within the DDLogger implementation MUST access the formatter ivar directly.
++    // This method is designed explicitly for external access.
++    //
++    // Using "self." syntax to go through this method will cause immediate deadlock.
++    // This is the intended result. Fix it by accessing the ivar directly.
++    // Great strides have been take to ensure this is safe to do. Plus it's MUCH faster.
++
++    NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++    NSAssert(![self isOnInternalLoggerQueue], @"MUST access ivar directly, NOT via self.* syntax.");
++
++    dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++
++    __block id <DDLogFormatter> result;
++
++    dispatch_sync(globalLoggingQueue, ^{
++        dispatch_sync(_loggerQueue, ^{
++            result = _logFormatter;
++        });
++    });
++
++    return result;
++}
++
++- (void)setLogFormatter:(id <DDLogFormatter>)logFormatter {
++    // The design of this method is documented extensively in the logFormatter message (above in code).
++
++    NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++    NSAssert(![self isOnInternalLoggerQueue], @"MUST access ivar directly, NOT via self.* syntax.");
++
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            if (_logFormatter != logFormatter) {
++                if ([_logFormatter respondsToSelector:@selector(willRemoveFromLogger:)]) {
++                    [_logFormatter willRemoveFromLogger:self];
++                }
++
++                _logFormatter = logFormatter;
++
++                if ([_logFormatter respondsToSelector:@selector(didAddToLogger:)]) {
++                    [_logFormatter didAddToLogger:self];
++                }
++            }
++        }
++    };
++
++    dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++
++    dispatch_async(globalLoggingQueue, ^{
++        dispatch_async(_loggerQueue, block);
++    });
++}
++
++- (dispatch_queue_t)loggerQueue {
++    return _loggerQueue;
++}
++
++- (NSString *)loggerName {
++    return NSStringFromClass([self class]);
++}
++
++- (BOOL)isOnGlobalLoggingQueue {
++    return (dispatch_get_specific(GlobalLoggingQueueIdentityKey) != NULL);
++}
++
++- (BOOL)isOnInternalLoggerQueue {
++    void *key = (__bridge void *)self;
++
++    return (dispatch_get_specific(key) != NULL);
++}
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/DDLogMacros.h b/Pods/CocoaLumberjack/Classes/DDLogMacros.h
+new file mode 100644
+index 0000000..975d00a
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDLogMacros.h
+@@ -0,0 +1,82 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++// Disable legacy macros
++#ifndef DD_LEGACY_MACROS
++    #define DD_LEGACY_MACROS 0
++#endif
++
++#import "DDLog.h"
++
++/**
++ * The constant/variable/method responsible for controlling the current log level.
++ **/
++#ifndef LOG_LEVEL_DEF
++    #define LOG_LEVEL_DEF ddLogLevel
++#endif
++
++/**
++ * Whether async should be used by log messages, excluding error messages that are always sent sync.
++ **/
++#ifndef LOG_ASYNC_ENABLED
++    #define LOG_ASYNC_ENABLED YES
++#endif
++
++/**
++ * This is the single macro that all other macros below compile into.
++ * This big multiline macro makes all the other macros easier to read.
++ **/
++#define LOG_MACRO(isAsynchronous, lvl, flg, ctx, atag, fnct, frmt, ...) \
++        [DDLog log : isAsynchronous                                     \
++             level : lvl                                                \
++              flag : flg                                                \
++           context : ctx                                                \
++              file : __FILE__                                           \
++          function : fnct                                               \
++              line : __LINE__                                           \
++               tag : atag                                               \
++            format : (frmt), ## __VA_ARGS__]
++
++/**
++ * Define version of the macro that only execute if the log level is above the threshold.
++ * The compiled versions essentially look like this:
++ *
++ * if (logFlagForThisLogMsg & ddLogLevel) { execute log message }
++ *
++ * When LOG_LEVEL_DEF is defined as ddLogLevel.
++ *
++ * As shown further below, Lumberjack actually uses a bitmask as opposed to primitive log levels.
++ * This allows for a great amount of flexibility and some pretty advanced fine grained logging techniques.
++ *
++ * Note that when compiler optimizations are enabled (as they are for your release builds),
++ * the log messages above your logging threshold will automatically be compiled out.
++ *
++ * (If the compiler sees LOG_LEVEL_DEF/ddLogLevel declared as a constant, the compiler simply checks to see
++ *  if the 'if' statement would execute, and if not it strips it from the binary.)
++ *
++ * We also define shorthand versions for asynchronous and synchronous logging.
++ **/
++#define LOG_MAYBE(async, lvl, flg, ctx, tag, fnct, frmt, ...) \
++        do { if(lvl & flg) LOG_MACRO(async, lvl, flg, ctx, tag, fnct, frmt, ##__VA_ARGS__); } while(0)
++
++/**
++ * Ready to use log macros with no context or tag.
++ **/
++#define DDLogError(frmt, ...)   LOG_MAYBE(NO,                LOG_LEVEL_DEF, DDLogFlagError,   0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)
++#define DDLogWarn(frmt, ...)    LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagWarning, 0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)
++#define DDLogInfo(frmt, ...)    LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagInfo,    0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)
++#define DDLogDebug(frmt, ...)   LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagDebug,   0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)
++#define DDLogVerbose(frmt, ...) LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagVerbose, 0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)
++
+diff --git a/Pods/CocoaLumberjack/Classes/DDTTYLogger.h b/Pods/CocoaLumberjack/Classes/DDTTYLogger.h
+new file mode 100644
+index 0000000..c27415c
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDTTYLogger.h
+@@ -0,0 +1,178 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++// Disable legacy macros
++#ifndef DD_LEGACY_MACROS
++    #define DD_LEGACY_MACROS 0
++#endif
++
++#import "DDLog.h"
++
++#define LOG_CONTEXT_ALL INT_MAX
++
++#pragma clang diagnostic push
++#pragma clang diagnostic ignored "-Wunused-function"
++#if TARGET_OS_IPHONE
++    // iOS
++    #import <UIKit/UIColor.h>
++    typedef UIColor DDColor;
++    static inline DDColor* DDMakeColor(CGFloat r, CGFloat g, CGFloat b) {return [DDColor colorWithRed:(r/255.0f) green:(g/255.0f) blue:(b/255.0f) alpha:1.0f];}
++#elif defined(DD_CLI) || !__has_include(<AppKit/NSColor.h>)
++    // OS X CLI
++    #import "CLIColor.h"
++    typedef CLIColor DDColor;
++    static inline DDColor* DDMakeColor(CGFloat r, CGFloat g, CGFloat b) {return [DDColor colorWithCalibratedRed:(r/255.0f) green:(g/255.0f) blue:(b/255.0f) alpha:1.0f];}
++#else
++    // OS X with AppKit
++    #import <AppKit/NSColor.h>
++    typedef NSColor DDColor;
++    static inline DDColor* DDMakeColor(CGFloat r, CGFloat g, CGFloat b) {return [DDColor colorWithCalibratedRed:(r/255.0f) green:(g/255.0f) blue:(b/255.0f) alpha:1.0f];}
++#endif
++#pragma clang diagnostic pop
++
++
++/**
++ * This class provides a logger for Terminal output or Xcode console output,
++ * depending on where you are running your code.
++ *
++ * As described in the "Getting Started" page,
++ * the traditional NSLog() function directs it's output to two places:
++ *
++ * - Apple System Log (so it shows up in Console.app)
++ * - StdErr (if stderr is a TTY, so log statements show up in Xcode console)
++ *
++ * To duplicate NSLog() functionality you can simply add this logger and an asl logger.
++ * However, if you instead choose to use file logging (for faster performance),
++ * you may choose to use only a file logger and a tty logger.
++ **/
++@interface DDTTYLogger : DDAbstractLogger <DDLogger>
++
++/**
++ *  Singleton method
++ */
+++ (instancetype)sharedInstance;
++
++/* Inherited from the DDLogger protocol:
++ *
++ * Formatters may optionally be added to any logger.
++ *
++ * If no formatter is set, the logger simply logs the message as it is given in logMessage,
++ * or it may use its own built in formatting style.
++ *
++ * More information about formatters can be found here:
++ * Documentation/CustomFormatters.md
++ *
++ * The actual implementation of these methods is inherited from DDAbstractLogger.
++
++   - (id <DDLogFormatter>)logFormatter;
++   - (void)setLogFormatter:(id <DDLogFormatter>)formatter;
++
++ */
++
++/**
++ * Want to use different colors for different log levels?
++ * Enable this property.
++ *
++ * If you run the application via the Terminal (not Xcode),
++ * the logger will map colors to xterm-256color or xterm-color (if available).
++ *
++ * Xcode does NOT natively support colors in the Xcode debugging console.
++ * You'll need to install the XcodeColors plugin to see colors in the Xcode console.
++ * https://github.com/robbiehanson/XcodeColors
++ *
++ * The default value is NO.
++ **/
++@property (readwrite, assign) BOOL colorsEnabled;
++
++/**
++ * When using a custom formatter you can set the `logMessage` method not to append
++ * `\n` character after each output. This allows for some greater flexibility with
++ * custom formatters. Default value is YES.
++ **/
++@property (nonatomic, readwrite, assign) BOOL automaticallyAppendNewlineForCustomFormatters;
++
++/**
++ * The default color set (foregroundColor, backgroundColor) is:
++ *
++ * - DDLogFlagError   = (red, nil)
++ * - DDLogFlagWarning = (orange, nil)
++ *
++ * You can customize the colors however you see fit.
++ * Please note that you are passing a flag, NOT a level.
++ *
++ * GOOD : [ttyLogger setForegroundColor:pink backgroundColor:nil forFlag:DDLogFlagInfo];  // <- Good :)
++ *  BAD : [ttyLogger setForegroundColor:pink backgroundColor:nil forFlag:DDLogLevelInfo]; // <- BAD! :(
++ *
++ * DDLogFlagInfo  = 0...00100
++ * DDLogLevelInfo = 0...00111 <- Would match DDLogFlagInfo and DDLogFlagWarning and DDLogFlagError
++ *
++ * If you run the application within Xcode, then the XcodeColors plugin is required.
++ *
++ * If you run the application from a shell, then DDTTYLogger will automatically map the given color to
++ * the closest available color. (xterm-256color or xterm-color which have 256 and 16 supported colors respectively.)
++ *
++ * This method invokes setForegroundColor:backgroundColor:forFlag:context: and applies it to `LOG_CONTEXT_ALL`.
++ **/
++- (void)setForegroundColor:(DDColor *)txtColor backgroundColor:(DDColor *)bgColor forFlag:(DDLogFlag)mask;
++
++/**
++ * Just like setForegroundColor:backgroundColor:flag, but allows you to specify a particular logging context.
++ *
++ * A logging context is often used to identify log messages coming from a 3rd party framework,
++ * although logging context's can be used for many different functions.
++ *
++ * Use LOG_CONTEXT_ALL to set the deafult color for all contexts that have no specific color set defined.
++ *
++ * Logging context's are explained in further detail here:
++ * Documentation/CustomContext.md
++ **/
++- (void)setForegroundColor:(DDColor *)txtColor backgroundColor:(DDColor *)bgColor forFlag:(DDLogFlag)mask context:(NSInteger)ctxt;
++
++/**
++ * Similar to the methods above, but allows you to map DDLogMessage->tag to a particular color profile.
++ * For example, you could do something like this:
++ *
++ * static NSString *const PurpleTag = @"PurpleTag";
++ *
++ * #define DDLogPurple(frmt, ...) LOG_OBJC_TAG_MACRO(NO, 0, 0, 0, PurpleTag, frmt, ##__VA_ARGS__)
++ * 
++ * And then where you configure CocoaLumberjack:
++ *
++ * purple = DDMakeColor((64/255.0), (0/255.0), (128/255.0));
++ *
++ * or any UIColor/NSColor constructor.
++ *
++ * Note: For CLI OS X projects that don't link with AppKit use CLIColor objects instead
++ *
++ * [[DDTTYLogger sharedInstance] setForegroundColor:purple backgroundColor:nil forTag:PurpleTag];
++ * [DDLog addLogger:[DDTTYLogger sharedInstance]];
++ *
++ * This would essentially give you a straight NSLog replacement that prints in purple:
++ *
++ * DDLogPurple(@"I'm a purple log message!");
++ **/
++- (void)setForegroundColor:(DDColor *)txtColor backgroundColor:(DDColor *)bgColor forTag:(id <NSCopying>)tag;
++
++/**
++ * Clearing color profiles.
++ **/
++- (void)clearColorsForFlag:(DDLogFlag)mask;
++- (void)clearColorsForFlag:(DDLogFlag)mask context:(NSInteger)context;
++- (void)clearColorsForTag:(id <NSCopying>)tag;
++- (void)clearColorsForAllFlags;
++- (void)clearColorsForAllTags;
++- (void)clearAllColors;
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/DDTTYLogger.m b/Pods/CocoaLumberjack/Classes/DDTTYLogger.m
+new file mode 100644
+index 0000000..41592ca
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/DDTTYLogger.m
+@@ -0,0 +1,1481 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++#import "DDTTYLogger.h"
++
++#import <unistd.h>
++#import <sys/uio.h>
++
++#if !__has_feature(objc_arc)
++#error This file must be compiled with ARC. Use -fobjc-arc flag (or convert project to ARC).
++#endif
++
++// We probably shouldn't be using DDLog() statements within the DDLog implementation.
++// But we still want to leave our log statements for any future debugging,
++// and to allow other developers to trace the implementation (which is a great learning tool).
++//
++// So we use primitive logging macros around NSLog.
++// We maintain the NS prefix on the macros to be explicit about the fact that we're using NSLog.
++
++#ifndef DD_NSLOG_LEVEL
++    #define DD_NSLOG_LEVEL 2
++#endif
++
++#define NSLogError(frmt, ...)    do{ if(DD_NSLOG_LEVEL >= 1) NSLog((frmt), ##__VA_ARGS__); } while(0)
++#define NSLogWarn(frmt, ...)     do{ if(DD_NSLOG_LEVEL >= 2) NSLog((frmt), ##__VA_ARGS__); } while(0)
++#define NSLogInfo(frmt, ...)     do{ if(DD_NSLOG_LEVEL >= 3) NSLog((frmt), ##__VA_ARGS__); } while(0)
++#define NSLogDebug(frmt, ...)    do{ if(DD_NSLOG_LEVEL >= 4) NSLog((frmt), ##__VA_ARGS__); } while(0)
++#define NSLogVerbose(frmt, ...)  do{ if(DD_NSLOG_LEVEL >= 5) NSLog((frmt), ##__VA_ARGS__); } while(0)
++
++// Xcode does NOT natively support colors in the Xcode debugging console.
++// You'll need to install the XcodeColors plugin to see colors in the Xcode console.
++// https://github.com/robbiehanson/XcodeColors
++//
++// The following is documentation from the XcodeColors project:
++//
++//
++// How to apply color formatting to your log statements:
++//
++// To set the foreground color:
++// Insert the ESCAPE_SEQ into your string, followed by "fg124,12,255;" where r=124, g=12, b=255.
++//
++// To set the background color:
++// Insert the ESCAPE_SEQ into your string, followed by "bg12,24,36;" where r=12, g=24, b=36.
++//
++// To reset the foreground color (to default value):
++// Insert the ESCAPE_SEQ into your string, followed by "fg;"
++//
++// To reset the background color (to default value):
++// Insert the ESCAPE_SEQ into your string, followed by "bg;"
++//
++// To reset the foreground and background color (to default values) in one operation:
++// Insert the ESCAPE_SEQ into your string, followed by ";"
++
++#define XCODE_COLORS_ESCAPE_SEQ "\033["
++
++#define XCODE_COLORS_RESET_FG   XCODE_COLORS_ESCAPE_SEQ "fg;" // Clear any foreground color
++#define XCODE_COLORS_RESET_BG   XCODE_COLORS_ESCAPE_SEQ "bg;" // Clear any background color
++#define XCODE_COLORS_RESET      XCODE_COLORS_ESCAPE_SEQ ";"  // Clear any foreground or background color
++
++// If running in a shell, not all RGB colors will be supported.
++// In this case we automatically map to the closest available color.
++// In order to provide this mapping, we have a hard-coded set of the standard RGB values available in the shell.
++// However, not every shell is the same, and Apple likes to think different even when it comes to shell colors.
++//
++// Map to standard Terminal.app colors (1), or
++// map to standard xterm colors (0).
++
++#define MAP_TO_TERMINAL_APP_COLORS 1
++
++
++@interface DDTTYLoggerColorProfile : NSObject {
++    @public
++    DDLogFlag mask;
++    NSInteger context;
++
++    uint8_t fg_r;
++    uint8_t fg_g;
++    uint8_t fg_b;
++
++    uint8_t bg_r;
++    uint8_t bg_g;
++    uint8_t bg_b;
++
++    NSUInteger fgCodeIndex;
++    NSString *fgCodeRaw;
++
++    NSUInteger bgCodeIndex;
++    NSString *bgCodeRaw;
++
++    char fgCode[24];
++    size_t fgCodeLen;
++
++    char bgCode[24];
++    size_t bgCodeLen;
++
++    char resetCode[8];
++    size_t resetCodeLen;
++}
++
++- (instancetype)initWithForegroundColor:(DDColor *)fgColor backgroundColor:(DDColor *)bgColor flag:(DDLogFlag)mask context:(NSInteger)ctxt;
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++@interface DDTTYLogger () {
++    NSUInteger _calendarUnitFlags;
++    
++    NSString *_appName;
++    char *_app;
++    size_t _appLen;
++    
++    NSString *_processID;
++    char *_pid;
++    size_t _pidLen;
++    
++    BOOL _colorsEnabled;
++    NSMutableArray *_colorProfilesArray;
++    NSMutableDictionary *_colorProfilesDict;
++}
++
++@end
++
++
++@implementation DDTTYLogger
++
++static BOOL isaColorTTY;
++static BOOL isaColor256TTY;
++static BOOL isaXcodeColorTTY;
++
++static NSArray *codes_fg = nil;
++static NSArray *codes_bg = nil;
++static NSArray *colors   = nil;
++
++static DDTTYLogger *sharedInstance;
++
++/**
++ * Initializes the colors array, as well as the codes_fg and codes_bg arrays, for 16 color mode.
++ *
++ * This method is used when the application is running from within a shell that only supports 16 color mode.
++ * This method is not invoked if the application is running within Xcode, or via normal UI app launch.
++ **/
+++ (void)initialize_colors_16 {
++    if (codes_fg || codes_bg || colors) {
++        return;
++    }
++
++    NSMutableArray *m_codes_fg = [NSMutableArray arrayWithCapacity:16];
++    NSMutableArray *m_codes_bg = [NSMutableArray arrayWithCapacity:16];
++    NSMutableArray *m_colors   = [NSMutableArray arrayWithCapacity:16];
++
++    // In a standard shell only 16 colors are supported.
++    //
++    // More information about ansi escape codes can be found online.
++    // http://en.wikipedia.org/wiki/ANSI_escape_code
++
++    [m_codes_fg addObject:@"30m"];   // normal - black
++    [m_codes_fg addObject:@"31m"];   // normal - red
++    [m_codes_fg addObject:@"32m"];   // normal - green
++    [m_codes_fg addObject:@"33m"];   // normal - yellow
++    [m_codes_fg addObject:@"34m"];   // normal - blue
++    [m_codes_fg addObject:@"35m"];   // normal - magenta
++    [m_codes_fg addObject:@"36m"];   // normal - cyan
++    [m_codes_fg addObject:@"37m"];   // normal - gray
++    [m_codes_fg addObject:@"1;30m"]; // bright - darkgray
++    [m_codes_fg addObject:@"1;31m"]; // bright - red
++    [m_codes_fg addObject:@"1;32m"]; // bright - green
++    [m_codes_fg addObject:@"1;33m"]; // bright - yellow
++    [m_codes_fg addObject:@"1;34m"]; // bright - blue
++    [m_codes_fg addObject:@"1;35m"]; // bright - magenta
++    [m_codes_fg addObject:@"1;36m"]; // bright - cyan
++    [m_codes_fg addObject:@"1;37m"]; // bright - white
++
++    [m_codes_bg addObject:@"40m"];   // normal - black
++    [m_codes_bg addObject:@"41m"];   // normal - red
++    [m_codes_bg addObject:@"42m"];   // normal - green
++    [m_codes_bg addObject:@"43m"];   // normal - yellow
++    [m_codes_bg addObject:@"44m"];   // normal - blue
++    [m_codes_bg addObject:@"45m"];   // normal - magenta
++    [m_codes_bg addObject:@"46m"];   // normal - cyan
++    [m_codes_bg addObject:@"47m"];   // normal - gray
++    [m_codes_bg addObject:@"1;40m"]; // bright - darkgray
++    [m_codes_bg addObject:@"1;41m"]; // bright - red
++    [m_codes_bg addObject:@"1;42m"]; // bright - green
++    [m_codes_bg addObject:@"1;43m"]; // bright - yellow
++    [m_codes_bg addObject:@"1;44m"]; // bright - blue
++    [m_codes_bg addObject:@"1;45m"]; // bright - magenta
++    [m_codes_bg addObject:@"1;46m"]; // bright - cyan
++    [m_codes_bg addObject:@"1;47m"]; // bright - white
++
++#if MAP_TO_TERMINAL_APP_COLORS
++
++    // Standard Terminal.app colors:
++    //
++    // These are the default colors used by Apple's Terminal.app.
++
++    [m_colors addObject:DDMakeColor(  0,   0,   0)]; // normal - black
++    [m_colors addObject:DDMakeColor(194,  54,  33)]; // normal - red
++    [m_colors addObject:DDMakeColor( 37, 188,  36)]; // normal - green
++    [m_colors addObject:DDMakeColor(173, 173,  39)]; // normal - yellow
++    [m_colors addObject:DDMakeColor( 73,  46, 225)]; // normal - blue
++    [m_colors addObject:DDMakeColor(211,  56, 211)]; // normal - magenta
++    [m_colors addObject:DDMakeColor( 51, 187, 200)]; // normal - cyan
++    [m_colors addObject:DDMakeColor(203, 204, 205)]; // normal - gray
++    [m_colors addObject:DDMakeColor(129, 131, 131)]; // bright - darkgray
++    [m_colors addObject:DDMakeColor(252,  57,  31)]; // bright - red
++    [m_colors addObject:DDMakeColor( 49, 231,  34)]; // bright - green
++    [m_colors addObject:DDMakeColor(234, 236,  35)]; // bright - yellow
++    [m_colors addObject:DDMakeColor( 88,  51, 255)]; // bright - blue
++    [m_colors addObject:DDMakeColor(249,  53, 248)]; // bright - magenta
++    [m_colors addObject:DDMakeColor( 20, 240, 240)]; // bright - cyan
++    [m_colors addObject:DDMakeColor(233, 235, 235)]; // bright - white
++
++#else /* if MAP_TO_TERMINAL_APP_COLORS */
++
++    // Standard xterm colors:
++    //
++    // These are the default colors used by most xterm shells.
++
++    [m_colors addObject:DDMakeColor(  0,   0,   0)]; // normal - black
++    [m_colors addObject:DDMakeColor(205,   0,   0)]; // normal - red
++    [m_colors addObject:DDMakeColor(  0, 205,   0)]; // normal - green
++    [m_colors addObject:DDMakeColor(205, 205,   0)]; // normal - yellow
++    [m_colors addObject:DDMakeColor(  0,   0, 238)]; // normal - blue
++    [m_colors addObject:DDMakeColor(205,   0, 205)]; // normal - magenta
++    [m_colors addObject:DDMakeColor(  0, 205, 205)]; // normal - cyan
++    [m_colors addObject:DDMakeColor(229, 229, 229)]; // normal - gray
++    [m_colors addObject:DDMakeColor(127, 127, 127)]; // bright - darkgray
++    [m_colors addObject:DDMakeColor(255,   0,   0)]; // bright - red
++    [m_colors addObject:DDMakeColor(  0, 255,   0)]; // bright - green
++    [m_colors addObject:DDMakeColor(255, 255,   0)]; // bright - yellow
++    [m_colors addObject:DDMakeColor( 92,  92, 255)]; // bright - blue
++    [m_colors addObject:DDMakeColor(255,   0, 255)]; // bright - magenta
++    [m_colors addObject:DDMakeColor(  0, 255, 255)]; // bright - cyan
++    [m_colors addObject:DDMakeColor(255, 255, 255)]; // bright - white
++
++#endif /* if MAP_TO_TERMINAL_APP_COLORS */
++
++    codes_fg = [m_codes_fg copy];
++    codes_bg = [m_codes_bg copy];
++    colors   = [m_colors   copy];
++
++    NSAssert([codes_fg count] == [codes_bg count], @"Invalid colors/codes array(s)");
++    NSAssert([codes_fg count] == [colors count],   @"Invalid colors/codes array(s)");
++}
++
++/**
++ * Initializes the colors array, as well as the codes_fg and codes_bg arrays, for 256 color mode.
++ *
++ * This method is used when the application is running from within a shell that supports 256 color mode.
++ * This method is not invoked if the application is running within Xcode, or via normal UI app launch.
++ **/
+++ (void)initialize_colors_256 {
++    if (codes_fg || codes_bg || colors) {
++        return;
++    }
++
++    NSMutableArray *m_codes_fg = [NSMutableArray arrayWithCapacity:(256 - 16)];
++    NSMutableArray *m_codes_bg = [NSMutableArray arrayWithCapacity:(256 - 16)];
++    NSMutableArray *m_colors   = [NSMutableArray arrayWithCapacity:(256 - 16)];
++
++    #if MAP_TO_TERMINAL_APP_COLORS
++
++    // Standard Terminal.app colors:
++    //
++    // These are the colors the Terminal.app uses in xterm-256color mode.
++    // In this mode, the terminal supports 256 different colors, specified by 256 color codes.
++    //
++    // The first 16 color codes map to the original 16 color codes supported by the earlier xterm-color mode.
++    // These are actually configurable, and thus we ignore them for the purposes of mapping,
++    // as we can't rely on them being constant. They are largely duplicated anyway.
++    //
++    // The next 216 color codes are designed to run the spectrum, with several shades of every color.
++    // While the color codes are standardized, the actual RGB values for each color code is not.
++    // Apple's Terminal.app uses different RGB values from that of a standard xterm.
++    // Apple's choices in colors are designed to be a little nicer on the eyes.
++    //
++    // The last 24 color codes represent a grayscale.
++    //
++    // Unfortunately, unlike the standard xterm color chart,
++    // Apple's RGB values cannot be calculated using a simple formula (at least not that I know of).
++    // Also, I don't know of any ways to programmatically query the shell for the RGB values.
++    // So this big giant color chart had to be made by hand.
++    //
++    // More information about ansi escape codes can be found online.
++    // http://en.wikipedia.org/wiki/ANSI_escape_code
++
++    // Colors
++
++    [m_colors addObject:DDMakeColor( 47,  49,  49)];
++    [m_colors addObject:DDMakeColor( 60,  42, 144)];
++    [m_colors addObject:DDMakeColor( 66,  44, 183)];
++    [m_colors addObject:DDMakeColor( 73,  46, 222)];
++    [m_colors addObject:DDMakeColor( 81,  50, 253)];
++    [m_colors addObject:DDMakeColor( 88,  51, 255)];
++    
++    [m_colors addObject:DDMakeColor( 42, 128,  37)];
++    [m_colors addObject:DDMakeColor( 42, 127, 128)];
++    [m_colors addObject:DDMakeColor( 44, 126, 169)];
++    [m_colors addObject:DDMakeColor( 56, 125, 209)];
++    [m_colors addObject:DDMakeColor( 59, 124, 245)];
++    [m_colors addObject:DDMakeColor( 66, 123, 255)];
++    
++    [m_colors addObject:DDMakeColor( 51, 163,  41)];
++    [m_colors addObject:DDMakeColor( 39, 162, 121)];
++    [m_colors addObject:DDMakeColor( 42, 161, 162)];
++    [m_colors addObject:DDMakeColor( 53, 160, 202)];
++    [m_colors addObject:DDMakeColor( 45, 159, 240)];
++    [m_colors addObject:DDMakeColor( 58, 158, 255)];
++    
++    [m_colors addObject:DDMakeColor( 31, 196,  37)];
++    [m_colors addObject:DDMakeColor( 48, 196, 115)];
++    [m_colors addObject:DDMakeColor( 39, 195, 155)];
++    [m_colors addObject:DDMakeColor( 49, 195, 195)];
++    [m_colors addObject:DDMakeColor( 32, 194, 235)];
++    [m_colors addObject:DDMakeColor( 53, 193, 255)];
++    
++    [m_colors addObject:DDMakeColor( 50, 229,  35)];
++    [m_colors addObject:DDMakeColor( 40, 229, 109)];
++    [m_colors addObject:DDMakeColor( 27, 229, 149)];
++    [m_colors addObject:DDMakeColor( 49, 228, 189)];
++    [m_colors addObject:DDMakeColor( 33, 228, 228)];
++    [m_colors addObject:DDMakeColor( 53, 227, 255)];
++    
++    [m_colors addObject:DDMakeColor( 27, 254,  30)];
++    [m_colors addObject:DDMakeColor( 30, 254, 103)];
++    [m_colors addObject:DDMakeColor( 45, 254, 143)];
++    [m_colors addObject:DDMakeColor( 38, 253, 182)];
++    [m_colors addObject:DDMakeColor( 38, 253, 222)];
++    [m_colors addObject:DDMakeColor( 42, 253, 252)];
++    
++    [m_colors addObject:DDMakeColor(140,  48,  40)];
++    [m_colors addObject:DDMakeColor(136,  51, 136)];
++    [m_colors addObject:DDMakeColor(135,  52, 177)];
++    [m_colors addObject:DDMakeColor(134,  52, 217)];
++    [m_colors addObject:DDMakeColor(135,  56, 248)];
++    [m_colors addObject:DDMakeColor(134,  53, 255)];
++    
++    [m_colors addObject:DDMakeColor(125, 125,  38)];
++    [m_colors addObject:DDMakeColor(124, 125, 125)];
++    [m_colors addObject:DDMakeColor(122, 124, 166)];
++    [m_colors addObject:DDMakeColor(123, 124, 207)];
++    [m_colors addObject:DDMakeColor(123, 122, 247)];
++    [m_colors addObject:DDMakeColor(124, 121, 255)];
++    
++    [m_colors addObject:DDMakeColor(119, 160,  35)];
++    [m_colors addObject:DDMakeColor(117, 160, 120)];
++    [m_colors addObject:DDMakeColor(117, 160, 160)];
++    [m_colors addObject:DDMakeColor(115, 159, 201)];
++    [m_colors addObject:DDMakeColor(116, 158, 240)];
++    [m_colors addObject:DDMakeColor(117, 157, 255)];
++    
++    [m_colors addObject:DDMakeColor(113, 195,  39)];
++    [m_colors addObject:DDMakeColor(110, 194, 114)];
++    [m_colors addObject:DDMakeColor(111, 194, 154)];
++    [m_colors addObject:DDMakeColor(108, 194, 194)];
++    [m_colors addObject:DDMakeColor(109, 193, 234)];
++    [m_colors addObject:DDMakeColor(108, 192, 255)];
++    
++    [m_colors addObject:DDMakeColor(105, 228,  30)];
++    [m_colors addObject:DDMakeColor(103, 228, 109)];
++    [m_colors addObject:DDMakeColor(105, 228, 148)];
++    [m_colors addObject:DDMakeColor(100, 227, 188)];
++    [m_colors addObject:DDMakeColor( 99, 227, 227)];
++    [m_colors addObject:DDMakeColor( 99, 226, 253)];
++    
++    [m_colors addObject:DDMakeColor( 92, 253,  34)];
++    [m_colors addObject:DDMakeColor( 96, 253, 103)];
++    [m_colors addObject:DDMakeColor( 97, 253, 142)];
++    [m_colors addObject:DDMakeColor( 88, 253, 182)];
++    [m_colors addObject:DDMakeColor( 93, 253, 221)];
++    [m_colors addObject:DDMakeColor( 88, 254, 251)];
++    
++    [m_colors addObject:DDMakeColor(177,  53,  34)];
++    [m_colors addObject:DDMakeColor(174,  54, 131)];
++    [m_colors addObject:DDMakeColor(172,  55, 172)];
++    [m_colors addObject:DDMakeColor(171,  57, 213)];
++    [m_colors addObject:DDMakeColor(170,  55, 249)];
++    [m_colors addObject:DDMakeColor(170,  57, 255)];
++    
++    [m_colors addObject:DDMakeColor(165, 123,  37)];
++    [m_colors addObject:DDMakeColor(163, 123, 123)];
++    [m_colors addObject:DDMakeColor(162, 123, 164)];
++    [m_colors addObject:DDMakeColor(161, 122, 205)];
++    [m_colors addObject:DDMakeColor(161, 121, 241)];
++    [m_colors addObject:DDMakeColor(161, 121, 255)];
++    
++    [m_colors addObject:DDMakeColor(158, 159,  33)];
++    [m_colors addObject:DDMakeColor(157, 158, 118)];
++    [m_colors addObject:DDMakeColor(157, 158, 159)];
++    [m_colors addObject:DDMakeColor(155, 157, 199)];
++    [m_colors addObject:DDMakeColor(155, 157, 239)];
++    [m_colors addObject:DDMakeColor(154, 156, 255)];
++    
++    [m_colors addObject:DDMakeColor(152, 193,  40)];
++    [m_colors addObject:DDMakeColor(151, 193, 113)];
++    [m_colors addObject:DDMakeColor(150, 193, 153)];
++    [m_colors addObject:DDMakeColor(150, 192, 193)];
++    [m_colors addObject:DDMakeColor(148, 192, 232)];
++    [m_colors addObject:DDMakeColor(149, 191, 253)];
++    
++    [m_colors addObject:DDMakeColor(146, 227,  28)];
++    [m_colors addObject:DDMakeColor(144, 227, 108)];
++    [m_colors addObject:DDMakeColor(144, 227, 147)];
++    [m_colors addObject:DDMakeColor(144, 227, 187)];
++    [m_colors addObject:DDMakeColor(142, 226, 227)];
++    [m_colors addObject:DDMakeColor(142, 225, 252)];
++    
++    [m_colors addObject:DDMakeColor(138, 253,  36)];
++    [m_colors addObject:DDMakeColor(137, 253, 102)];
++    [m_colors addObject:DDMakeColor(136, 253, 141)];
++    [m_colors addObject:DDMakeColor(138, 254, 181)];
++    [m_colors addObject:DDMakeColor(135, 255, 220)];
++    [m_colors addObject:DDMakeColor(133, 255, 250)];
++    
++    [m_colors addObject:DDMakeColor(214,  57,  30)];
++    [m_colors addObject:DDMakeColor(211,  59, 126)];
++    [m_colors addObject:DDMakeColor(209,  57, 168)];
++    [m_colors addObject:DDMakeColor(208,  55, 208)];
++    [m_colors addObject:DDMakeColor(207,  58, 247)];
++    [m_colors addObject:DDMakeColor(206,  61, 255)];
++    
++    [m_colors addObject:DDMakeColor(204, 121,  32)];
++    [m_colors addObject:DDMakeColor(202, 121, 121)];
++    [m_colors addObject:DDMakeColor(201, 121, 161)];
++    [m_colors addObject:DDMakeColor(200, 120, 202)];
++    [m_colors addObject:DDMakeColor(200, 120, 241)];
++    [m_colors addObject:DDMakeColor(198, 119, 255)];
++    
++    [m_colors addObject:DDMakeColor(198, 157,  37)];
++    [m_colors addObject:DDMakeColor(196, 157, 116)];
++    [m_colors addObject:DDMakeColor(195, 156, 157)];
++    [m_colors addObject:DDMakeColor(195, 156, 197)];
++    [m_colors addObject:DDMakeColor(194, 155, 236)];
++    [m_colors addObject:DDMakeColor(193, 155, 255)];
++    
++    [m_colors addObject:DDMakeColor(191, 192,  36)];
++    [m_colors addObject:DDMakeColor(190, 191, 112)];
++    [m_colors addObject:DDMakeColor(189, 191, 152)];
++    [m_colors addObject:DDMakeColor(189, 191, 191)];
++    [m_colors addObject:DDMakeColor(188, 190, 230)];
++    [m_colors addObject:DDMakeColor(187, 190, 253)];
++    
++    [m_colors addObject:DDMakeColor(185, 226,  28)];
++    [m_colors addObject:DDMakeColor(184, 226, 106)];
++    [m_colors addObject:DDMakeColor(183, 225, 146)];
++    [m_colors addObject:DDMakeColor(183, 225, 186)];
++    [m_colors addObject:DDMakeColor(182, 225, 225)];
++    [m_colors addObject:DDMakeColor(181, 224, 252)];
++    
++    [m_colors addObject:DDMakeColor(178, 255,  35)];
++    [m_colors addObject:DDMakeColor(178, 255, 101)];
++    [m_colors addObject:DDMakeColor(177, 254, 141)];
++    [m_colors addObject:DDMakeColor(176, 254, 180)];
++    [m_colors addObject:DDMakeColor(176, 254, 220)];
++    [m_colors addObject:DDMakeColor(175, 253, 249)];
++    
++    [m_colors addObject:DDMakeColor(247,  56,  30)];
++    [m_colors addObject:DDMakeColor(245,  57, 122)];
++    [m_colors addObject:DDMakeColor(243,  59, 163)];
++    [m_colors addObject:DDMakeColor(244,  60, 204)];
++    [m_colors addObject:DDMakeColor(242,  59, 241)];
++    [m_colors addObject:DDMakeColor(240,  55, 255)];
++    
++    [m_colors addObject:DDMakeColor(241, 119,  36)];
++    [m_colors addObject:DDMakeColor(240, 120, 118)];
++    [m_colors addObject:DDMakeColor(238, 119, 158)];
++    [m_colors addObject:DDMakeColor(237, 119, 199)];
++    [m_colors addObject:DDMakeColor(237, 118, 238)];
++    [m_colors addObject:DDMakeColor(236, 118, 255)];
++    
++    [m_colors addObject:DDMakeColor(235, 154,  36)];
++    [m_colors addObject:DDMakeColor(235, 154, 114)];
++    [m_colors addObject:DDMakeColor(234, 154, 154)];
++    [m_colors addObject:DDMakeColor(232, 154, 194)];
++    [m_colors addObject:DDMakeColor(232, 153, 234)];
++    [m_colors addObject:DDMakeColor(232, 153, 255)];
++    
++    [m_colors addObject:DDMakeColor(230, 190,  30)];
++    [m_colors addObject:DDMakeColor(229, 189, 110)];
++    [m_colors addObject:DDMakeColor(228, 189, 150)];
++    [m_colors addObject:DDMakeColor(227, 189, 190)];
++    [m_colors addObject:DDMakeColor(227, 189, 229)];
++    [m_colors addObject:DDMakeColor(226, 188, 255)];
++    
++    [m_colors addObject:DDMakeColor(224, 224,  35)];
++    [m_colors addObject:DDMakeColor(223, 224, 105)];
++    [m_colors addObject:DDMakeColor(222, 224, 144)];
++    [m_colors addObject:DDMakeColor(222, 223, 184)];
++    [m_colors addObject:DDMakeColor(222, 223, 224)];
++    [m_colors addObject:DDMakeColor(220, 223, 253)];
++    
++    [m_colors addObject:DDMakeColor(217, 253,  28)];
++    [m_colors addObject:DDMakeColor(217, 253,  99)];
++    [m_colors addObject:DDMakeColor(216, 252, 139)];
++    [m_colors addObject:DDMakeColor(216, 252, 179)];
++    [m_colors addObject:DDMakeColor(215, 252, 218)];
++    [m_colors addObject:DDMakeColor(215, 251, 250)];
++    
++    [m_colors addObject:DDMakeColor(255,  61,  30)];
++    [m_colors addObject:DDMakeColor(255,  60, 118)];
++    [m_colors addObject:DDMakeColor(255,  58, 159)];
++    [m_colors addObject:DDMakeColor(255,  56, 199)];
++    [m_colors addObject:DDMakeColor(255,  55, 238)];
++    [m_colors addObject:DDMakeColor(255,  59, 255)];
++    
++    [m_colors addObject:DDMakeColor(255, 117,  29)];
++    [m_colors addObject:DDMakeColor(255, 117, 115)];
++    [m_colors addObject:DDMakeColor(255, 117, 155)];
++    [m_colors addObject:DDMakeColor(255, 117, 195)];
++    [m_colors addObject:DDMakeColor(255, 116, 235)];
++    [m_colors addObject:DDMakeColor(254, 116, 255)];
++    
++    [m_colors addObject:DDMakeColor(255, 152,  27)];
++    [m_colors addObject:DDMakeColor(255, 152, 111)];
++    [m_colors addObject:DDMakeColor(254, 152, 152)];
++    [m_colors addObject:DDMakeColor(255, 152, 192)];
++    [m_colors addObject:DDMakeColor(254, 151, 231)];
++    [m_colors addObject:DDMakeColor(253, 151, 253)];
++    
++    [m_colors addObject:DDMakeColor(255, 187,  33)];
++    [m_colors addObject:DDMakeColor(253, 187, 107)];
++    [m_colors addObject:DDMakeColor(252, 187, 148)];
++    [m_colors addObject:DDMakeColor(253, 187, 187)];
++    [m_colors addObject:DDMakeColor(254, 187, 227)];
++    [m_colors addObject:DDMakeColor(252, 186, 252)];
++    
++    [m_colors addObject:DDMakeColor(252, 222,  34)];
++    [m_colors addObject:DDMakeColor(251, 222, 103)];
++    [m_colors addObject:DDMakeColor(251, 222, 143)];
++    [m_colors addObject:DDMakeColor(250, 222, 182)];
++    [m_colors addObject:DDMakeColor(251, 221, 222)];
++    [m_colors addObject:DDMakeColor(252, 221, 252)];
++    
++    [m_colors addObject:DDMakeColor(251, 252,  15)];
++    [m_colors addObject:DDMakeColor(251, 252,  97)];
++    [m_colors addObject:DDMakeColor(249, 252, 137)];
++    [m_colors addObject:DDMakeColor(247, 252, 177)];
++    [m_colors addObject:DDMakeColor(247, 253, 217)];
++    [m_colors addObject:DDMakeColor(254, 255, 255)];
++    
++    // Grayscale
++    
++    [m_colors addObject:DDMakeColor( 52,  53,  53)];
++    [m_colors addObject:DDMakeColor( 57,  58,  59)];
++    [m_colors addObject:DDMakeColor( 66,  67,  67)];
++    [m_colors addObject:DDMakeColor( 75,  76,  76)];
++    [m_colors addObject:DDMakeColor( 83,  85,  85)];
++    [m_colors addObject:DDMakeColor( 92,  93,  94)];
++    
++    [m_colors addObject:DDMakeColor(101, 102, 102)];
++    [m_colors addObject:DDMakeColor(109, 111, 111)];
++    [m_colors addObject:DDMakeColor(118, 119, 119)];
++    [m_colors addObject:DDMakeColor(126, 127, 128)];
++    [m_colors addObject:DDMakeColor(134, 136, 136)];
++    [m_colors addObject:DDMakeColor(143, 144, 145)];
++    
++    [m_colors addObject:DDMakeColor(151, 152, 153)];
++    [m_colors addObject:DDMakeColor(159, 161, 161)];
++    [m_colors addObject:DDMakeColor(167, 169, 169)];
++    [m_colors addObject:DDMakeColor(176, 177, 177)];
++    [m_colors addObject:DDMakeColor(184, 185, 186)];
++    [m_colors addObject:DDMakeColor(192, 193, 194)];
++    
++    [m_colors addObject:DDMakeColor(200, 201, 202)];
++    [m_colors addObject:DDMakeColor(208, 209, 210)];
++    [m_colors addObject:DDMakeColor(216, 218, 218)];
++    [m_colors addObject:DDMakeColor(224, 226, 226)];
++    [m_colors addObject:DDMakeColor(232, 234, 234)];
++    [m_colors addObject:DDMakeColor(240, 242, 242)];
++    
++    // Color codes
++
++    int index = 16;
++
++    while (index < 256) {
++        [m_codes_fg addObject:[NSString stringWithFormat:@"38;5;%dm", index]];
++        [m_codes_bg addObject:[NSString stringWithFormat:@"48;5;%dm", index]];
++
++        index++;
++    }
++
++    #else /* if MAP_TO_TERMINAL_APP_COLORS */
++
++    // Standard xterm colors:
++    //
++    // These are the colors xterm shells use in xterm-256color mode.
++    // In this mode, the shell supports 256 different colors, specified by 256 color codes.
++    //
++    // The first 16 color codes map to the original 16 color codes supported by the earlier xterm-color mode.
++    // These are generally configurable, and thus we ignore them for the purposes of mapping,
++    // as we can't rely on them being constant. They are largely duplicated anyway.
++    //
++    // The next 216 color codes are designed to run the spectrum, with several shades of every color.
++    // The last 24 color codes represent a grayscale.
++    //
++    // While the color codes are standardized, the actual RGB values for each color code is not.
++    // However most standard xterms follow a well known color chart,
++    // which can easily be calculated using the simple formula below.
++    //
++    // More information about ansi escape codes can be found online.
++    // http://en.wikipedia.org/wiki/ANSI_escape_code
++
++    int index = 16;
++
++    int r; // red
++    int g; // green
++    int b; // blue
++
++    int ri; // r increment
++    int gi; // g increment
++    int bi; // b increment
++
++    // Calculate xterm colors (using standard algorithm)
++
++    int r = 0;
++    int g = 0;
++    int b = 0;
++
++    for (ri = 0; ri < 6; ri++) {
++        r = (ri == 0) ? 0 : 95 + (40 * (ri - 1));
++
++        for (gi = 0; gi < 6; gi++) {
++            g = (gi == 0) ? 0 : 95 + (40 * (gi - 1));
++
++            for (bi = 0; bi < 6; bi++) {
++                b = (bi == 0) ? 0 : 95 + (40 * (bi - 1));
++
++                [m_codes_fg addObject:[NSString stringWithFormat:@"38;5;%dm", index]];
++                [m_codes_bg addObject:[NSString stringWithFormat:@"48;5;%dm", index]];
++                [m_colors addObject:DDMakeColor(r, g, b)];
++
++                index++;
++            }
++        }
++    }
++
++    // Calculate xterm grayscale (using standard algorithm)
++
++    r = 8;
++    g = 8;
++    b = 8;
++
++    while (index < 256) {
++        [m_codes_fg addObject:[NSString stringWithFormat:@"38;5;%dm", index]];
++        [m_codes_bg addObject:[NSString stringWithFormat:@"48;5;%dm", index]];
++        [m_colors addObject:DDMakeColor(r, g, b)];
++
++        r += 10;
++        g += 10;
++        b += 10;
++
++        index++;
++    }
++
++    #endif /* if MAP_TO_TERMINAL_APP_COLORS */
++
++    codes_fg = [m_codes_fg copy];
++    codes_bg = [m_codes_bg copy];
++    colors   = [m_colors   copy];
++
++    NSAssert([codes_fg count] == [codes_bg count], @"Invalid colors/codes array(s)");
++    NSAssert([codes_fg count] == [colors count],   @"Invalid colors/codes array(s)");
++}
++
+++ (void)getRed:(CGFloat *)rPtr green:(CGFloat *)gPtr blue:(CGFloat *)bPtr fromColor:(DDColor *)color {
++    #if TARGET_OS_IPHONE
++
++    // iOS
++
++    BOOL done = NO;
++
++    if ([color respondsToSelector:@selector(getRed:green:blue:alpha:)]) {
++        done = [color getRed:rPtr green:gPtr blue:bPtr alpha:NULL];
++    }
++
++    if (!done) {
++        // The method getRed:green:blue:alpha: was only available starting iOS 5.
++        // So in iOS 4 and earlier, we have to jump through hoops.
++
++        CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceRGB();
++
++        unsigned char pixel[4];
++        CGContextRef context = CGBitmapContextCreate(&pixel, 1, 1, 8, 4, rgbColorSpace, (CGBitmapInfo)(kCGBitmapAlphaInfoMask & kCGImageAlphaNoneSkipLast));
++
++        CGContextSetFillColorWithColor(context, [color CGColor]);
++        CGContextFillRect(context, CGRectMake(0, 0, 1, 1));
++
++        if (rPtr) {
++            *rPtr = pixel[0] / 255.0f;
++        }
++
++        if (gPtr) {
++            *gPtr = pixel[1] / 255.0f;
++        }
++
++        if (bPtr) {
++            *bPtr = pixel[2] / 255.0f;
++        }
++
++        CGContextRelease(context);
++        CGColorSpaceRelease(rgbColorSpace);
++    }
++
++    #elif defined(DD_CLI) || !__has_include(<AppKit/NSColor.h>)
++
++    // OS X without AppKit
++
++    [color getRed:rPtr green:gPtr blue:bPtr alpha:NULL];
++
++    #else /* if TARGET_OS_IPHONE */
++
++    // OS X with AppKit
++
++    NSColor *safeColor = [color colorUsingColorSpaceName:NSCalibratedRGBColorSpace];
++
++    [safeColor getRed:rPtr green:gPtr blue:bPtr alpha:NULL];
++    #endif /* if TARGET_OS_IPHONE */
++}
++
++/**
++ * Maps the given color to the closest available color supported by the shell.
++ * The shell may support 256 colors, or only 16.
++ *
++ * This method loops through the known supported color set, and calculates the closest color.
++ * The array index of that color, within the colors array, is then returned.
++ * This array index may also be used as the index within the codes_fg and codes_bg arrays.
++ **/
+++ (NSUInteger)codeIndexForColor:(DDColor *)inColor {
++    CGFloat inR, inG, inB;
++
++    [self getRed:&inR green:&inG blue:&inB fromColor:inColor];
++
++    NSUInteger bestIndex = 0;
++    CGFloat lowestDistance = 100.0f;
++
++    NSUInteger i = 0;
++
++    for (DDColor *color in colors) {
++        // Calculate Euclidean distance (lower value means closer to given color)
++
++        CGFloat r, g, b;
++        [self getRed:&r green:&g blue:&b fromColor:color];
++
++    #if CGFLOAT_IS_DOUBLE
++        CGFloat distance = sqrt(pow(r - inR, 2.0) + pow(g - inG, 2.0) + pow(b - inB, 2.0));
++    #else
++        CGFloat distance = sqrtf(powf(r - inR, 2.0f) + powf(g - inG, 2.0f) + powf(b - inB, 2.0f));
++    #endif
++
++        NSLogVerbose(@"DDTTYLogger: %3lu : %.3f,%.3f,%.3f & %.3f,%.3f,%.3f = %.6f",
++                     (unsigned long)i, inR, inG, inB, r, g, b, distance);
++
++        if (distance < lowestDistance) {
++            bestIndex = i;
++            lowestDistance = distance;
++
++            NSLogVerbose(@"DDTTYLogger: New best index = %lu", (unsigned long)bestIndex);
++        }
++
++        i++;
++    }
++
++    return bestIndex;
++}
++
+++ (instancetype)sharedInstance {
++    static dispatch_once_t DDTTYLoggerOnceToken;
++
++    dispatch_once(&DDTTYLoggerOnceToken, ^{
++        // Xcode does NOT natively support colors in the Xcode debugging console.
++        // You'll need to install the XcodeColors plugin to see colors in the Xcode console.
++        //
++        // PS - Please read the header file before diving into the source code.
++
++        char *xcode_colors = getenv("XcodeColors");
++        char *term = getenv("TERM");
++
++        if (xcode_colors && (strcmp(xcode_colors, "YES") == 0)) {
++            isaXcodeColorTTY = YES;
++        } else if (term) {
++            if (strcasestr(term, "color") != NULL) {
++                isaColorTTY = YES;
++                isaColor256TTY = (strcasestr(term, "256") != NULL);
++
++                if (isaColor256TTY) {
++                    [self initialize_colors_256];
++                } else {
++                    [self initialize_colors_16];
++                }
++            }
++        }
++
++        NSLogInfo(@"DDTTYLogger: isaColorTTY = %@", (isaColorTTY ? @"YES" : @"NO"));
++        NSLogInfo(@"DDTTYLogger: isaColor256TTY: %@", (isaColor256TTY ? @"YES" : @"NO"));
++        NSLogInfo(@"DDTTYLogger: isaXcodeColorTTY: %@", (isaXcodeColorTTY ? @"YES" : @"NO"));
++
++        sharedInstance = [[[self class] alloc] init];
++    });
++
++    return sharedInstance;
++}
++
++- (instancetype)init {
++    if (sharedInstance != nil) {
++        return nil;
++    }
++
++    if ((self = [super init])) {
++        _calendarUnitFlags = (NSCalendarUnitYear     |
++                             NSCalendarUnitMonth    |
++                             NSCalendarUnitDay      |
++                             NSCalendarUnitHour     |
++                             NSCalendarUnitMinute   |
++                             NSCalendarUnitSecond);
++
++        // Initialze 'app' variable (char *)
++
++        _appName = [[NSProcessInfo processInfo] processName];
++
++        _appLen = [_appName lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
++
++        if (_appLen == 0) {
++            _appName = @"<UnnamedApp>";
++            _appLen = [_appName lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
++        }
++
++        _app = (char *)malloc(_appLen + 1);
++
++        if (_app == NULL) {
++            return nil;
++        }
++
++        BOOL processedAppName = [_appName getCString:_app maxLength:(_appLen + 1) encoding:NSUTF8StringEncoding];
++
++        if (NO == processedAppName) {
++            free(_app);
++            return nil;
++        }
++
++        // Initialize 'pid' variable (char *)
++
++        _processID = [NSString stringWithFormat:@"%i", (int)getpid()];
++
++        _pidLen = [_processID lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
++        _pid = (char *)malloc(_pidLen + 1);
++
++        if (_pid == NULL) {
++            free(_app);
++            return nil;
++        }
++
++        BOOL processedID = [_processID getCString:_pid maxLength:(_pidLen + 1) encoding:NSUTF8StringEncoding];
++
++        if (NO == processedID) {
++            free(_app);
++            free(_pid);
++            return nil;
++        }
++
++        // Initialize color stuff
++
++        _colorsEnabled = NO;
++        _colorProfilesArray = [[NSMutableArray alloc] initWithCapacity:8];
++        _colorProfilesDict = [[NSMutableDictionary alloc] initWithCapacity:8];
++
++        _automaticallyAppendNewlineForCustomFormatters = YES;
++    }
++
++    return self;
++}
++
++- (void)loadDefaultColorProfiles {
++    [self setForegroundColor:DDMakeColor(214,  57,  30) backgroundColor:nil forFlag:DDLogFlagError];
++    [self setForegroundColor:DDMakeColor(204, 121,  32) backgroundColor:nil forFlag:DDLogFlagWarning];
++}
++
++- (BOOL)colorsEnabled {
++    // The design of this method is taken from the DDAbstractLogger implementation.
++    // For extensive documentation please refer to the DDAbstractLogger implementation.
++
++    // Note: The internal implementation MUST access the colorsEnabled variable directly,
++    // This method is designed explicitly for external access.
++    //
++    // Using "self." syntax to go through this method will cause immediate deadlock.
++    // This is the intended result. Fix it by accessing the ivar directly.
++    // Great strides have been take to ensure this is safe to do. Plus it's MUCH faster.
++
++    NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++    NSAssert(![self isOnInternalLoggerQueue], @"MUST access ivar directly, NOT via self.* syntax.");
++
++    dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++
++    __block BOOL result;
++
++    dispatch_sync(globalLoggingQueue, ^{
++        dispatch_sync(self.loggerQueue, ^{
++            result = _colorsEnabled;
++        });
++    });
++
++    return result;
++}
++
++- (void)setColorsEnabled:(BOOL)newColorsEnabled {
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            _colorsEnabled = newColorsEnabled;
++
++            if ([_colorProfilesArray count] == 0) {
++                [self loadDefaultColorProfiles];
++            }
++        }
++    };
++
++    // The design of this method is taken from the DDAbstractLogger implementation.
++    // For extensive documentation please refer to the DDAbstractLogger implementation.
++
++    // Note: The internal implementation MUST access the colorsEnabled variable directly,
++    // This method is designed explicitly for external access.
++    //
++    // Using "self." syntax to go through this method will cause immediate deadlock.
++    // This is the intended result. Fix it by accessing the ivar directly.
++    // Great strides have been take to ensure this is safe to do. Plus it's MUCH faster.
++
++    NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++    NSAssert(![self isOnInternalLoggerQueue], @"MUST access ivar directly, NOT via self.* syntax.");
++
++    dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++
++    dispatch_async(globalLoggingQueue, ^{
++        dispatch_async(self.loggerQueue, block);
++    });
++}
++
++- (void)setForegroundColor:(DDColor *)txtColor backgroundColor:(DDColor *)bgColor forFlag:(DDLogFlag)mask {
++    [self setForegroundColor:txtColor backgroundColor:bgColor forFlag:mask context:LOG_CONTEXT_ALL];
++}
++
++- (void)setForegroundColor:(DDColor *)txtColor backgroundColor:(DDColor *)bgColor forFlag:(DDLogFlag)mask context:(NSInteger)ctxt {
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            DDTTYLoggerColorProfile *newColorProfile =
++                [[DDTTYLoggerColorProfile alloc] initWithForegroundColor:txtColor
++                                                         backgroundColor:bgColor
++                                                                    flag:mask
++                                                                 context:ctxt];
++
++            NSLogInfo(@"DDTTYLogger: newColorProfile: %@", newColorProfile);
++
++            NSUInteger i = 0;
++
++            for (DDTTYLoggerColorProfile *colorProfile in _colorProfilesArray) {
++                if ((colorProfile->mask == mask) && (colorProfile->context == ctxt)) {
++                    break;
++                }
++
++                i++;
++            }
++
++            if (i < [_colorProfilesArray count]) {
++                _colorProfilesArray[i] = newColorProfile;
++            } else {
++                [_colorProfilesArray addObject:newColorProfile];
++            }
++        }
++    };
++
++    // The design of the setter logic below is taken from the DDAbstractLogger implementation.
++    // For documentation please refer to the DDAbstractLogger implementation.
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++        NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++
++        dispatch_async(globalLoggingQueue, ^{
++            dispatch_async(self.loggerQueue, block);
++        });
++    }
++}
++
++- (void)setForegroundColor:(DDColor *)txtColor backgroundColor:(DDColor *)bgColor forTag:(id <NSCopying>)tag {
++    NSAssert([(id < NSObject >) tag conformsToProtocol: @protocol(NSCopying)], @"Invalid tag");
++
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            DDTTYLoggerColorProfile *newColorProfile =
++                [[DDTTYLoggerColorProfile alloc] initWithForegroundColor:txtColor
++                                                         backgroundColor:bgColor
++                                                                    flag:(DDLogFlag)0
++                                                                 context:0];
++
++            NSLogInfo(@"DDTTYLogger: newColorProfile: %@", newColorProfile);
++
++            _colorProfilesDict[tag] = newColorProfile;
++        }
++    };
++
++    // The design of the setter logic below is taken from the DDAbstractLogger implementation.
++    // For documentation please refer to the DDAbstractLogger implementation.
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++        NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++
++        dispatch_async(globalLoggingQueue, ^{
++            dispatch_async(self.loggerQueue, block);
++        });
++    }
++}
++
++- (void)clearColorsForFlag:(DDLogFlag)mask {
++    [self clearColorsForFlag:mask context:0];
++}
++
++- (void)clearColorsForFlag:(DDLogFlag)mask context:(NSInteger)context {
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            NSUInteger i = 0;
++
++            for (DDTTYLoggerColorProfile *colorProfile in _colorProfilesArray) {
++                if ((colorProfile->mask == mask) && (colorProfile->context == context)) {
++                    break;
++                }
++
++                i++;
++            }
++
++            if (i < [_colorProfilesArray count]) {
++                [_colorProfilesArray removeObjectAtIndex:i];
++            }
++        }
++    };
++
++    // The design of the setter logic below is taken from the DDAbstractLogger implementation.
++    // For documentation please refer to the DDAbstractLogger implementation.
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++        NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++
++        dispatch_async(globalLoggingQueue, ^{
++            dispatch_async(self.loggerQueue, block);
++        });
++    }
++}
++
++- (void)clearColorsForTag:(id <NSCopying>)tag {
++    NSAssert([(id < NSObject >) tag conformsToProtocol: @protocol(NSCopying)], @"Invalid tag");
++
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            [_colorProfilesDict removeObjectForKey:tag];
++        }
++    };
++
++    // The design of the setter logic below is taken from the DDAbstractLogger implementation.
++    // For documentation please refer to the DDAbstractLogger implementation.
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++        NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++
++        dispatch_async(globalLoggingQueue, ^{
++            dispatch_async(self.loggerQueue, block);
++        });
++    }
++}
++
++- (void)clearColorsForAllFlags {
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            [_colorProfilesArray removeAllObjects];
++        }
++    };
++
++    // The design of the setter logic below is taken from the DDAbstractLogger implementation.
++    // For documentation please refer to the DDAbstractLogger implementation.
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++        NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++
++        dispatch_async(globalLoggingQueue, ^{
++            dispatch_async(self.loggerQueue, block);
++        });
++    }
++}
++
++- (void)clearColorsForAllTags {
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            [_colorProfilesDict removeAllObjects];
++        }
++    };
++
++    // The design of the setter logic below is taken from the DDAbstractLogger implementation.
++    // For documentation please refer to the DDAbstractLogger implementation.
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++        NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++
++        dispatch_async(globalLoggingQueue, ^{
++            dispatch_async(self.loggerQueue, block);
++        });
++    }
++}
++
++- (void)clearAllColors {
++    dispatch_block_t block = ^{
++        @autoreleasepool {
++            [_colorProfilesArray removeAllObjects];
++            [_colorProfilesDict removeAllObjects];
++        }
++    };
++
++    // The design of the setter logic below is taken from the DDAbstractLogger implementation.
++    // For documentation please refer to the DDAbstractLogger implementation.
++
++    if ([self isOnInternalLoggerQueue]) {
++        block();
++    } else {
++        dispatch_queue_t globalLoggingQueue = [DDLog loggingQueue];
++        NSAssert(![self isOnGlobalLoggingQueue], @"Core architecture requirement failure");
++
++        dispatch_async(globalLoggingQueue, ^{
++            dispatch_async(self.loggerQueue, block);
++        });
++    }
++}
++
++- (void)logMessage:(DDLogMessage *)logMessage {
++    NSString *logMsg = logMessage->_message;
++    BOOL isFormatted = NO;
++
++    if (_logFormatter) {
++        logMsg = [_logFormatter formatLogMessage:logMessage];
++        isFormatted = logMsg != logMessage->_message;
++    }
++
++    if (logMsg) {
++        // Search for a color profile associated with the log message
++
++        DDTTYLoggerColorProfile *colorProfile = nil;
++
++        if (_colorsEnabled) {
++            if (logMessage->_tag) {
++                colorProfile = _colorProfilesDict[logMessage->_tag];
++            }
++
++            if (colorProfile == nil) {
++                for (DDTTYLoggerColorProfile *cp in _colorProfilesArray) {
++                    if (logMessage->_flag & cp->mask) {
++                        // Color profile set for this context?
++                        if (logMessage->_context == cp->context) {
++                            colorProfile = cp;
++
++                            // Stop searching
++                            break;
++                        }
++
++                        // Check if LOG_CONTEXT_ALL was specified as a default color for this flag
++                        if (cp->context == LOG_CONTEXT_ALL) {
++                            colorProfile = cp;
++
++                            // We don't break to keep searching for more specific color profiles for the context
++                        }
++                    }
++                }
++            }
++        }
++
++        // Convert log message to C string.
++        //
++        // We use the stack instead of the heap for speed if possible.
++        // But we're extra cautious to avoid a stack overflow.
++
++        NSUInteger msgLen = [logMsg lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
++        const BOOL useStack = msgLen < (1024 * 4);
++
++        char msgStack[useStack ? (msgLen + 1) : 1]; // Analyzer doesn't like zero-size array, hence the 1
++        char *msg = useStack ? msgStack : (char *)malloc(msgLen + 1);
++
++        if (msg == NULL) {
++            return;
++        }
++
++        BOOL logMsgEnc = [logMsg getCString:msg maxLength:(msgLen + 1) encoding:NSUTF8StringEncoding];
++
++        if (!logMsgEnc) {
++            if (!useStack && msg != NULL) {
++                free(msg);
++            }
++
++            return;
++        }
++
++        // Write the log message to STDERR
++
++        if (isFormatted) {
++            // The log message has already been formatted.
++            int iovec_len = (_automaticallyAppendNewlineForCustomFormatters) ? 5 : 4;
++            struct iovec v[iovec_len];
++
++            if (colorProfile) {
++                v[0].iov_base = colorProfile->fgCode;
++                v[0].iov_len = colorProfile->fgCodeLen;
++
++                v[1].iov_base = colorProfile->bgCode;
++                v[1].iov_len = colorProfile->bgCodeLen;
++
++                v[iovec_len - 1].iov_base = colorProfile->resetCode;
++                v[iovec_len - 1].iov_len = colorProfile->resetCodeLen;
++            } else {
++                v[0].iov_base = "";
++                v[0].iov_len = 0;
++
++                v[1].iov_base = "";
++                v[1].iov_len = 0;
++
++                v[iovec_len - 1].iov_base = "";
++                v[iovec_len - 1].iov_len = 0;
++            }
++
++            v[2].iov_base = (char *)msg;
++            v[2].iov_len = msgLen;
++
++            if (iovec_len == 5) {
++                v[3].iov_base = "\n";
++                v[3].iov_len = (msg[msgLen] == '\n') ? 0 : 1;
++            }
++
++            writev(STDERR_FILENO, v, iovec_len);
++        } else {
++            // The log message is unformatted, so apply standard NSLog style formatting.
++
++            int len;
++            char ts[24] = "";
++            size_t tsLen = 0;
++
++            // Calculate timestamp.
++            // The technique below is faster than using NSDateFormatter.
++            if (logMessage->_timestamp) {
++                NSDateComponents *components = [[NSCalendar autoupdatingCurrentCalendar] components:_calendarUnitFlags fromDate:logMessage->_timestamp];
++
++                NSTimeInterval epoch = [logMessage->_timestamp timeIntervalSinceReferenceDate];
++                int milliseconds = (int)((epoch - floor(epoch)) * 1000);
++
++                len = snprintf(ts, 24, "%04ld-%02ld-%02ld %02ld:%02ld:%02ld:%03d", // yyyy-MM-dd HH:mm:ss:SSS
++                               (long)components.year,
++                               (long)components.month,
++                               (long)components.day,
++                               (long)components.hour,
++                               (long)components.minute,
++                               (long)components.second, milliseconds);
++
++                tsLen = (NSUInteger)MAX(MIN(24 - 1, len), 0);
++            }
++
++            // Calculate thread ID
++            //
++            // How many characters do we need for the thread id?
++            // logMessage->machThreadID is of type mach_port_t, which is an unsigned int.
++            //
++            // 1 hex char = 4 bits
++            // 8 hex chars for 32 bit, plus ending '\0' = 9
++
++            char tid[9];
++            len = snprintf(tid, 9, "%s", [logMessage->_threadID cStringUsingEncoding:NSUTF8StringEncoding]);
++
++            size_t tidLen = (NSUInteger)MAX(MIN(9 - 1, len), 0);
++
++            // Here is our format: "%s %s[%i:%s] %s", timestamp, appName, processID, threadID, logMsg
++
++            struct iovec v[13];
++
++            if (colorProfile) {
++                v[0].iov_base = colorProfile->fgCode;
++                v[0].iov_len = colorProfile->fgCodeLen;
++
++                v[1].iov_base = colorProfile->bgCode;
++                v[1].iov_len = colorProfile->bgCodeLen;
++
++                v[12].iov_base = colorProfile->resetCode;
++                v[12].iov_len = colorProfile->resetCodeLen;
++            } else {
++                v[0].iov_base = "";
++                v[0].iov_len = 0;
++
++                v[1].iov_base = "";
++                v[1].iov_len = 0;
++
++                v[12].iov_base = "";
++                v[12].iov_len = 0;
++            }
++
++            v[2].iov_base = ts;
++            v[2].iov_len = tsLen;
++
++            v[3].iov_base = " ";
++            v[3].iov_len = 1;
++
++            v[4].iov_base = _app;
++            v[4].iov_len = _appLen;
++
++            v[5].iov_base = "[";
++            v[5].iov_len = 1;
++
++            v[6].iov_base = _pid;
++            v[6].iov_len = _pidLen;
++
++            v[7].iov_base = ":";
++            v[7].iov_len = 1;
++
++            v[8].iov_base = tid;
++            v[8].iov_len = MIN((size_t)8, tidLen); // snprintf doesn't return what you might think
++
++            v[9].iov_base = "] ";
++            v[9].iov_len = 2;
++
++            v[10].iov_base = (char *)msg;
++            v[10].iov_len = msgLen;
++
++            v[11].iov_base = "\n";
++            v[11].iov_len = (msg[msgLen] == '\n') ? 0 : 1;
++
++            writev(STDERR_FILENO, v, 13);
++        }
++
++        if (!useStack) {
++            free(msg);
++        }
++    }
++}
++
++- (NSString *)loggerName {
++    return @"cocoa.lumberjack.ttyLogger";
++}
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++@implementation DDTTYLoggerColorProfile
++
++- (instancetype)initWithForegroundColor:(DDColor *)fgColor backgroundColor:(DDColor *)bgColor flag:(DDLogFlag)aMask context:(NSInteger)ctxt {
++    if ((self = [super init])) {
++        mask = aMask;
++        context = ctxt;
++
++        CGFloat r, g, b;
++
++        if (fgColor) {
++            [DDTTYLogger getRed:&r green:&g blue:&b fromColor:fgColor];
++
++            fg_r = (uint8_t)(r * 255.0f);
++            fg_g = (uint8_t)(g * 255.0f);
++            fg_b = (uint8_t)(b * 255.0f);
++        }
++
++        if (bgColor) {
++            [DDTTYLogger getRed:&r green:&g blue:&b fromColor:bgColor];
++
++            bg_r = (uint8_t)(r * 255.0f);
++            bg_g = (uint8_t)(g * 255.0f);
++            bg_b = (uint8_t)(b * 255.0f);
++        }
++
++        if (fgColor && isaColorTTY) {
++            // Map foreground color to closest available shell color
++
++            fgCodeIndex = [DDTTYLogger codeIndexForColor:fgColor];
++            fgCodeRaw   = codes_fg[fgCodeIndex];
++
++            NSString *escapeSeq = @"\033[";
++
++            NSUInteger len1 = [escapeSeq lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
++            NSUInteger len2 = [fgCodeRaw lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
++
++            BOOL escapeSeqEnc = [escapeSeq getCString:(fgCode)      maxLength:(len1 + 1) encoding:NSUTF8StringEncoding];
++            BOOL fgCodeRawEsc = [fgCodeRaw getCString:(fgCode + len1) maxLength:(len2 + 1) encoding:NSUTF8StringEncoding];
++
++            if (!escapeSeqEnc || !fgCodeRawEsc) {
++                return nil;
++            }
++
++            fgCodeLen = len1 + len2;
++        } else if (fgColor && isaXcodeColorTTY) {
++            // Convert foreground color to color code sequence
++
++            const char *escapeSeq = XCODE_COLORS_ESCAPE_SEQ;
++
++            int result = snprintf(fgCode, 24, "%sfg%u,%u,%u;", escapeSeq, fg_r, fg_g, fg_b);
++            fgCodeLen = (NSUInteger)MAX(MIN(result, (24 - 1)), 0);
++        } else {
++            // No foreground color or no color support
++
++            fgCode[0] = '\0';
++            fgCodeLen = 0;
++        }
++
++        if (bgColor && isaColorTTY) {
++            // Map background color to closest available shell color
++
++            bgCodeIndex = [DDTTYLogger codeIndexForColor:bgColor];
++            bgCodeRaw   = codes_bg[bgCodeIndex];
++
++            NSString *escapeSeq = @"\033[";
++
++            NSUInteger len1 = [escapeSeq lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
++            NSUInteger len2 = [bgCodeRaw lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
++
++            BOOL escapeSeqEnc = [escapeSeq getCString:(bgCode)      maxLength:(len1 + 1) encoding:NSUTF8StringEncoding];
++            BOOL bgCodeRawEsc = [bgCodeRaw getCString:(bgCode + len1) maxLength:(len2 + 1) encoding:NSUTF8StringEncoding];
++
++            if (!escapeSeqEnc || !bgCodeRawEsc) {
++                return nil;
++            }
++
++            bgCodeLen = len1 + len2;
++        } else if (bgColor && isaXcodeColorTTY) {
++            // Convert background color to color code sequence
++
++            const char *escapeSeq = XCODE_COLORS_ESCAPE_SEQ;
++
++            int result = snprintf(bgCode, 24, "%sbg%u,%u,%u;", escapeSeq, bg_r, bg_g, bg_b);
++            bgCodeLen = (NSUInteger)MAX(MIN(result, (24 - 1)), 0);
++        } else {
++            // No background color or no color support
++
++            bgCode[0] = '\0';
++            bgCodeLen = 0;
++        }
++
++        if (isaColorTTY) {
++            resetCodeLen = (NSUInteger)MAX(snprintf(resetCode, 8, "\033[0m"), 0);
++        } else if (isaXcodeColorTTY) {
++            resetCodeLen = (NSUInteger)MAX(snprintf(resetCode, 8, XCODE_COLORS_RESET), 0);
++        } else {
++            resetCode[0] = '\0';
++            resetCodeLen = 0;
++        }
++    }
++
++    return self;
++}
++
++- (NSString *)description {
++    return [NSString stringWithFormat:
++            @"<DDTTYLoggerColorProfile: %p mask:%i ctxt:%ld fg:%u,%u,%u bg:%u,%u,%u fgCode:%@ bgCode:%@>",
++            self, (int)mask, (long)context, fg_r, fg_g, fg_b, bg_r, bg_g, bg_b, fgCodeRaw, bgCodeRaw];
++}
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/Extensions/DDContextFilterLogFormatter.h b/Pods/CocoaLumberjack/Classes/Extensions/DDContextFilterLogFormatter.h
+new file mode 100644
+index 0000000..1657f1f
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/Extensions/DDContextFilterLogFormatter.h
+@@ -0,0 +1,117 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++#import <Foundation/Foundation.h>
++
++// Disable legacy macros
++#ifndef DD_LEGACY_MACROS
++    #define DD_LEGACY_MACROS 0
++#endif
++
++#import "DDLog.h"
++
++/**
++ * This class provides a log formatter that filters log statements from a logging context not on the whitelist.
++ *
++ * A log formatter can be added to any logger to format and/or filter its output.
++ * You can learn more about log formatters here:
++ * Documentation/CustomFormatters.md
++ *
++ * You can learn more about logging context's here:
++ * Documentation/CustomContext.md
++ *
++ * But here's a quick overview / refresher:
++ *
++ * Every log statement has a logging context.
++ * These come from the underlying logging macros defined in DDLog.h.
++ * The default logging context is zero.
++ * You can define multiple logging context's for use in your application.
++ * For example, logically separate parts of your app each have a different logging context.
++ * Also 3rd party frameworks that make use of Lumberjack generally use their own dedicated logging context.
++ **/
++@interface DDContextWhitelistFilterLogFormatter : NSObject <DDLogFormatter>
++
++/**
++ *  Designated default initializer
++ */
++- (instancetype)init NS_DESIGNATED_INITIALIZER;
++
++/**
++ *  Add a context to the whitelist
++ *
++ *  @param loggingContext the context
++ */
++- (void)addToWhitelist:(NSUInteger)loggingContext;
++
++/**
++ *  Remove context from whitelist
++ *
++ *  @param loggingContext the context
++ */
++- (void)removeFromWhitelist:(NSUInteger)loggingContext;
++
++/**
++ *  Return the whitelist
++ */
++@property (readonly, copy) NSArray *whitelist;
++
++/**
++ *  Check if a context is on the whitelist
++ *
++ *  @param loggingContext the context
++ */
++- (BOOL)isOnWhitelist:(NSUInteger)loggingContext;
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++/**
++ * This class provides a log formatter that filters log statements from a logging context on the blacklist.
++ **/
++@interface DDContextBlacklistFilterLogFormatter : NSObject <DDLogFormatter>
++
++- (instancetype)init NS_DESIGNATED_INITIALIZER;
++
++/**
++ *  Add a context to the blacklist
++ *
++ *  @param loggingContext the context
++ */
++- (void)addToBlacklist:(NSUInteger)loggingContext;
++
++/**
++ *  Remove context from blacklist
++ *
++ *  @param loggingContext the context
++ */
++- (void)removeFromBlacklist:(NSUInteger)loggingContext;
++
++/**
++ *  Return the blacklist
++ */
++@property (readonly, copy) NSArray *blacklist;
++
++
++/**
++ *  Check if a context is on the blacklist
++ *
++ *  @param loggingContext the context
++ */
++- (BOOL)isOnBlacklist:(NSUInteger)loggingContext;
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/Extensions/DDContextFilterLogFormatter.m b/Pods/CocoaLumberjack/Classes/Extensions/DDContextFilterLogFormatter.m
+new file mode 100644
+index 0000000..14a6ae9
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/Extensions/DDContextFilterLogFormatter.m
+@@ -0,0 +1,191 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++#import "DDContextFilterLogFormatter.h"
++#import <libkern/OSAtomic.h>
++
++#if !__has_feature(objc_arc)
++#error This file must be compiled with ARC. Use -fobjc-arc flag (or convert project to ARC).
++#endif
++
++@interface DDLoggingContextSet : NSObject
++
++- (void)addToSet:(NSUInteger)loggingContext;
++- (void)removeFromSet:(NSUInteger)loggingContext;
++
++@property (readonly, copy) NSArray *currentSet;
++
++- (BOOL)isInSet:(NSUInteger)loggingContext;
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++@interface DDContextWhitelistFilterLogFormatter () {
++    DDLoggingContextSet *_contextSet;
++}
++
++@end
++
++
++@implementation DDContextWhitelistFilterLogFormatter
++
++- (instancetype)init {
++    if ((self = [super init])) {
++        _contextSet = [[DDLoggingContextSet alloc] init];
++    }
++
++    return self;
++}
++
++- (void)addToWhitelist:(NSUInteger)loggingContext {
++    [_contextSet addToSet:loggingContext];
++}
++
++- (void)removeFromWhitelist:(NSUInteger)loggingContext {
++    [_contextSet removeFromSet:loggingContext];
++}
++
++- (NSArray *)whitelist {
++    return [_contextSet currentSet];
++}
++
++- (BOOL)isOnWhitelist:(NSUInteger)loggingContext {
++    return [_contextSet isInSet:loggingContext];
++}
++
++- (NSString *)formatLogMessage:(DDLogMessage *)logMessage {
++    if ([self isOnWhitelist:logMessage->_context]) {
++        return logMessage->_message;
++    } else {
++        return nil;
++    }
++}
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++@interface DDContextBlacklistFilterLogFormatter () {
++    DDLoggingContextSet *_contextSet;
++}
++
++@end
++
++
++@implementation DDContextBlacklistFilterLogFormatter
++
++- (instancetype)init {
++    if ((self = [super init])) {
++        _contextSet = [[DDLoggingContextSet alloc] init];
++    }
++
++    return self;
++}
++
++- (void)addToBlacklist:(NSUInteger)loggingContext {
++    [_contextSet addToSet:loggingContext];
++}
++
++- (void)removeFromBlacklist:(NSUInteger)loggingContext {
++    [_contextSet removeFromSet:loggingContext];
++}
++
++- (NSArray *)blacklist {
++    return [_contextSet currentSet];
++}
++
++- (BOOL)isOnBlacklist:(NSUInteger)loggingContext {
++    return [_contextSet isInSet:loggingContext];
++}
++
++- (NSString *)formatLogMessage:(DDLogMessage *)logMessage {
++    if ([self isOnBlacklist:logMessage->_context]) {
++        return nil;
++    } else {
++        return logMessage->_message;
++    }
++}
++
++@end
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark -
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++
++@interface DDLoggingContextSet () {
++    OSSpinLock _lock;
++    NSMutableSet *_set;
++}
++
++@end
++
++
++@implementation DDLoggingContextSet
++
++- (instancetype)init {
++    if ((self = [super init])) {
++        _set = [[NSMutableSet alloc] init];
++    }
++
++    return self;
++}
++
++- (void)addToSet:(NSUInteger)loggingContext {
++    OSSpinLockLock(&_lock);
++    {
++        [_set addObject:@(loggingContext)];
++    }
++    OSSpinLockUnlock(&_lock);
++}
++
++- (void)removeFromSet:(NSUInteger)loggingContext {
++    OSSpinLockLock(&_lock);
++    {
++        [_set removeObject:@(loggingContext)];
++    }
++    OSSpinLockUnlock(&_lock);
++}
++
++- (NSArray *)currentSet {
++    NSArray *result = nil;
++
++    OSSpinLockLock(&_lock);
++    {
++        result = [_set allObjects];
++    }
++    OSSpinLockUnlock(&_lock);
++
++    return result;
++}
++
++- (BOOL)isInSet:(NSUInteger)loggingContext {
++    BOOL result = NO;
++
++    OSSpinLockLock(&_lock);
++    {
++        result = [_set containsObject:@(loggingContext)];
++    }
++    OSSpinLockUnlock(&_lock);
++
++    return result;
++}
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/Extensions/DDDispatchQueueLogFormatter.h b/Pods/CocoaLumberjack/Classes/Extensions/DDDispatchQueueLogFormatter.h
+new file mode 100644
+index 0000000..129f6e1
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/Extensions/DDDispatchQueueLogFormatter.h
+@@ -0,0 +1,178 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++#import <Foundation/Foundation.h>
++#import <libkern/OSAtomic.h>
++
++// Disable legacy macros
++#ifndef DD_LEGACY_MACROS
++    #define DD_LEGACY_MACROS 0
++#endif
++
++#import "DDLog.h"
++
++/**
++ *  Log formatter mode
++ */
++typedef NS_ENUM(NSUInteger, DDDispatchQueueLogFormatterMode){
++    /**
++     *  This is the default option, means the formatter can be reused between multiple loggers and therefore is thread-safe.
++     *  There is, of course, a performance cost for the thread-safety
++     */
++    DDDispatchQueueLogFormatterModeShareble = 0,
++    /**
++     *  If the formatter will only be used by a single logger, then the thread-safety can be removed
++     *  @note: there is an assert checking if the formatter is added to multiple loggers and the mode is non-shareble
++     */
++    DDDispatchQueueLogFormatterModeNonShareble,
++};
++
++
++/**
++ * This class provides a log formatter that prints the dispatch_queue label instead of the mach_thread_id.
++ *
++ * A log formatter can be added to any logger to format and/or filter its output.
++ * You can learn more about log formatters here:
++ * Documentation/CustomFormatters.md
++ *
++ * A typical `NSLog` (or `DDTTYLogger`) prints detailed info as `[<process_id>:<thread_id>]`.
++ * For example:
++ *
++ * `2011-10-17 20:21:45.435 AppName[19928:5207] Your log message here`
++ *
++ * Where:
++ * `- 19928 = process id`
++ * `-  5207 = thread id (mach_thread_id printed in hex)`
++ *
++ * When using grand central dispatch (GCD), this information is less useful.
++ * This is because a single serial dispatch queue may be run on any thread from an internally managed thread pool.
++ * For example:
++ *
++ * `2011-10-17 20:32:31.111 AppName[19954:4d07] Message from my_serial_dispatch_queue`
++ * `2011-10-17 20:32:31.112 AppName[19954:5207] Message from my_serial_dispatch_queue`
++ * `2011-10-17 20:32:31.113 AppName[19954:2c55] Message from my_serial_dispatch_queue`
++ *
++ * This formatter allows you to replace the standard `[box:info]` with the dispatch_queue name.
++ * For example:
++ *
++ * `2011-10-17 20:32:31.111 AppName[img-scaling] Message from my_serial_dispatch_queue`
++ * `2011-10-17 20:32:31.112 AppName[img-scaling] Message from my_serial_dispatch_queue`
++ * `2011-10-17 20:32:31.113 AppName[img-scaling] Message from my_serial_dispatch_queue`
++ *
++ * If the dispatch_queue doesn't have a set name, then it falls back to the thread name.
++ * If the current thread doesn't have a set name, then it falls back to the mach_thread_id in hex (like normal).
++ *
++ * Note: If manually creating your own background threads (via `NSThread/alloc/init` or `NSThread/detachNeThread`),
++ * you can use `[[NSThread currentThread] setName:(NSString *)]`.
++ **/
++@interface DDDispatchQueueLogFormatter : NSObject <DDLogFormatter>
++
++/**
++ * Standard init method.
++ * Configure using properties as desired.
++ **/
++- (instancetype)init NS_DESIGNATED_INITIALIZER;
++
++/**
++ *  Initializer with ability to set the queue mode
++ *
++ *  @param mode choose between DDDispatchQueueLogFormatterModeShareble and DDDispatchQueueLogFormatterModeNonShareble, depending if the formatter is shared between several loggers or not
++ */
++- (instancetype)initWithMode:(DDDispatchQueueLogFormatterMode)mode;
++
++/**
++ * The minQueueLength restricts the minimum size of the [detail box].
++ * If the minQueueLength is set to 0, there is no restriction.
++ *
++ * For example, say a dispatch_queue has a label of "diskIO":
++ *
++ * If the minQueueLength is 0: [diskIO]
++ * If the minQueueLength is 4: [diskIO]
++ * If the minQueueLength is 5: [diskIO]
++ * If the minQueueLength is 6: [diskIO]
++ * If the minQueueLength is 7: [diskIO ]
++ * If the minQueueLength is 8: [diskIO  ]
++ *
++ * The default minQueueLength is 0 (no minimum, so [detail box] won't be padded).
++ *
++ * If you want every [detail box] to have the exact same width,
++ * set both minQueueLength and maxQueueLength to the same value.
++ **/
++@property (assign, atomic) NSUInteger minQueueLength;
++
++/**
++ * The maxQueueLength restricts the number of characters that will be inside the [detail box].
++ * If the maxQueueLength is 0, there is no restriction.
++ *
++ * For example, say a dispatch_queue has a label of "diskIO":
++ *
++ * If the maxQueueLength is 0: [diskIO]
++ * If the maxQueueLength is 4: [disk]
++ * If the maxQueueLength is 5: [diskI]
++ * If the maxQueueLength is 6: [diskIO]
++ * If the maxQueueLength is 7: [diskIO]
++ * If the maxQueueLength is 8: [diskIO]
++ *
++ * The default maxQueueLength is 0 (no maximum, so [detail box] won't be truncated).
++ *
++ * If you want every [detail box] to have the exact same width,
++ * set both minQueueLength and maxQueueLength to the same value.
++ **/
++@property (assign, atomic) NSUInteger maxQueueLength;
++
++/**
++ * Sometimes queue labels have long names like "com.apple.main-queue",
++ * but you'd prefer something shorter like simply "main".
++ *
++ * This method allows you to set such preferred replacements.
++ * The above example is set by default.
++ *
++ * To remove/undo a previous replacement, invoke this method with nil for the 'shortLabel' parameter.
++ **/
++- (NSString *)replacementStringForQueueLabel:(NSString *)longLabel;
++
++/**
++ *  See the `replacementStringForQueueLabel:` description
++ */
++- (void)setReplacementString:(NSString *)shortLabel forQueueLabel:(NSString *)longLabel;
++
++@end
++
++/**
++ *  Category on `DDDispatchQueueLogFormatter` to make method declarations easier to extend/modify
++ **/
++@interface DDDispatchQueueLogFormatter (OverridableMethods)
++
++/**
++ *  Date formatter default configuration
++ */
++- (void)configureDateFormatter:(NSDateFormatter *)dateFormatter;
++
++/**
++ *  Formatter method to transfrom from date to string
++ */
++- (NSString *)stringFromDate:(NSDate *)date;
++
++/**
++ *  Method to compute the queue thread label
++ */
++- (NSString *)queueThreadLabelForLogMessage:(DDLogMessage *)logMessage;
++
++/**
++ *  The actual method that formats a message (transforms a `DDLogMessage` model into a printable string)
++ */
++- (NSString *)formatLogMessage:(DDLogMessage *)logMessage;
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/Extensions/DDDispatchQueueLogFormatter.m b/Pods/CocoaLumberjack/Classes/Extensions/DDDispatchQueueLogFormatter.m
+new file mode 100644
+index 0000000..fdcc87b
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/Extensions/DDDispatchQueueLogFormatter.m
+@@ -0,0 +1,277 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++#import "DDDispatchQueueLogFormatter.h"
++#import <libkern/OSAtomic.h>
++#import <objc/runtime.h>
++
++
++#if !__has_feature(objc_arc)
++#error This file must be compiled with ARC. Use -fobjc-arc flag (or convert project to ARC).
++#endif
++
++@interface DDDispatchQueueLogFormatter () {
++    DDDispatchQueueLogFormatterMode _mode;
++    NSString *_dateFormatterKey;
++    
++    int32_t _atomicLoggerCount;
++    NSDateFormatter *_threadUnsafeDateFormatter; // Use [self stringFromDate]
++    
++    OSSpinLock _lock;
++    
++    NSUInteger _minQueueLength;           // _prefix == Only access via atomic property
++    NSUInteger _maxQueueLength;           // _prefix == Only access via atomic property
++    NSMutableDictionary *_replacements;   // _prefix == Only access from within spinlock
++}
++
++@end
++
++
++@implementation DDDispatchQueueLogFormatter
++
++- (instancetype)init {
++    if ((self = [super init])) {
++        _mode = DDDispatchQueueLogFormatterModeShareble;
++
++        // We need to carefully pick the name for storing in thread dictionary to not
++        // use a formatter configured by subclass and avoid surprises.
++        Class cls = [self class];
++        Class superClass = class_getSuperclass(cls);
++        SEL configMethodName = @selector(configureDateFormatter:);
++        Method configMethod = class_getInstanceMethod(cls, configMethodName);
++        while (class_getInstanceMethod(superClass, configMethodName) == configMethod) {
++            cls = superClass;
++            superClass = class_getSuperclass(cls);
++        }
++        // now `cls` is the class that provides implementation for `configureDateFormatter:`
++        _dateFormatterKey = [NSString stringWithFormat:@"%s_NSDateFormatter", class_getName(cls)];
++
++        _atomicLoggerCount = 0;
++        _threadUnsafeDateFormatter = nil;
++
++        _minQueueLength = 0;
++        _maxQueueLength = 0;
++        _replacements = [[NSMutableDictionary alloc] init];
++
++        // Set default replacements:
++
++        _replacements[@"com.apple.main-thread"] = @"main";
++    }
++
++    return self;
++}
++
++- (instancetype)initWithMode:(DDDispatchQueueLogFormatterMode)mode {
++    if ((self = [self init])) {
++        _mode = mode;
++    }
++    return self;
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark Configuration
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++@synthesize minQueueLength = _minQueueLength;
++@synthesize maxQueueLength = _maxQueueLength;
++
++- (NSString *)replacementStringForQueueLabel:(NSString *)longLabel {
++    NSString *result = nil;
++
++    OSSpinLockLock(&_lock);
++    {
++        result = _replacements[longLabel];
++    }
++    OSSpinLockUnlock(&_lock);
++
++    return result;
++}
++
++- (void)setReplacementString:(NSString *)shortLabel forQueueLabel:(NSString *)longLabel {
++    OSSpinLockLock(&_lock);
++    {
++        if (shortLabel) {
++            _replacements[longLabel] = shortLabel;
++        } else {
++            [_replacements removeObjectForKey:longLabel];
++        }
++    }
++    OSSpinLockUnlock(&_lock);
++}
++
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++#pragma mark DDLogFormatter
++////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
++
++- (NSDateFormatter *)createDateFormatter {
++    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
++    [self configureDateFormatter:formatter];
++    return formatter;
++}
++
++- (void)configureDateFormatter:(NSDateFormatter *)dateFormatter {
++    [dateFormatter setFormatterBehavior:NSDateFormatterBehavior10_4];
++    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss:SSS"];
++    [dateFormatter setLocale:[NSLocale localeWithLocaleIdentifier:@"en_US_POSIX"]];
++
++    NSString *calendarIdentifier = nil;
++#if defined(__IPHONE_8_0) || defined(__MAC_10_10)
++    calendarIdentifier = NSCalendarIdentifierGregorian;
++#else
++    calendarIdentifier = NSGregorianCalendar;
++#endif
++
++    [dateFormatter setCalendar:[[NSCalendar alloc] initWithCalendarIdentifier:calendarIdentifier]];
++}
++
++- (NSString *)stringFromDate:(NSDate *)date {
++
++    NSDateFormatter *dateFormatter = nil;
++    if (_mode == DDDispatchQueueLogFormatterModeNonShareble) {
++        // Single-threaded mode.
++
++        dateFormatter = _threadUnsafeDateFormatter;
++        if (dateFormatter == nil) {
++            dateFormatter = [self createDateFormatter];
++            _threadUnsafeDateFormatter = dateFormatter;
++        }
++    } else {
++        // Multi-threaded mode.
++        // NSDateFormatter is NOT thread-safe.
++
++        NSString *key = _dateFormatterKey;
++
++        NSMutableDictionary *threadDictionary = [[NSThread currentThread] threadDictionary];
++        dateFormatter = threadDictionary[key];
++
++        if (dateFormatter == nil) {
++            dateFormatter = [self createDateFormatter];
++            threadDictionary[key] = dateFormatter;
++        }
++    }
++
++    return [dateFormatter stringFromDate:date];
++}
++
++- (NSString *)queueThreadLabelForLogMessage:(DDLogMessage *)logMessage {
++    // As per the DDLogFormatter contract, this method is always invoked on the same thread/dispatch_queue
++
++    NSUInteger minQueueLength = self.minQueueLength;
++    NSUInteger maxQueueLength = self.maxQueueLength;
++
++    // Get the name of the queue, thread, or machID (whichever we are to use).
++
++    NSString *queueThreadLabel = nil;
++
++    BOOL useQueueLabel = YES;
++    BOOL useThreadName = NO;
++
++    if (logMessage->_queueLabel) {
++        // If you manually create a thread, it's dispatch_queue will have one of the thread names below.
++        // Since all such threads have the same name, we'd prefer to use the threadName or the machThreadID.
++
++        NSArray *names = @[
++            @"com.apple.root.low-priority",
++            @"com.apple.root.default-priority",
++            @"com.apple.root.high-priority",
++            @"com.apple.root.low-overcommit-priority",
++            @"com.apple.root.default-overcommit-priority",
++            @"com.apple.root.high-overcommit-priority"
++        ];
++
++        for (NSString * name in names) {
++            if ([logMessage->_queueLabel isEqualToString:name]) {
++                useQueueLabel = NO;
++                useThreadName = [logMessage->_threadName length] > 0;
++                break;
++            }
++        }
++    } else {
++        useQueueLabel = NO;
++        useThreadName = [logMessage->_threadName length] > 0;
++    }
++
++    if (useQueueLabel || useThreadName) {
++        NSString *fullLabel;
++        NSString *abrvLabel;
++
++        if (useQueueLabel) {
++            fullLabel = logMessage->_queueLabel;
++        } else {
++            fullLabel = logMessage->_threadName;
++        }
++
++        OSSpinLockLock(&_lock);
++        {
++            abrvLabel = _replacements[fullLabel];
++        }
++        OSSpinLockUnlock(&_lock);
++
++        if (abrvLabel) {
++            queueThreadLabel = abrvLabel;
++        } else {
++            queueThreadLabel = fullLabel;
++        }
++    } else {
++        queueThreadLabel = logMessage->_threadID;
++    }
++
++    // Now use the thread label in the output
++
++    NSUInteger labelLength = [queueThreadLabel length];
++
++    // labelLength > maxQueueLength : truncate
++    // labelLength < minQueueLength : padding
++    //                              : exact
++
++    if ((maxQueueLength > 0) && (labelLength > maxQueueLength)) {
++        // Truncate
++
++        return [queueThreadLabel substringToIndex:maxQueueLength];
++    } else if (labelLength < minQueueLength) {
++        // Padding
++
++        NSUInteger numSpaces = minQueueLength - labelLength;
++
++        char spaces[numSpaces + 1];
++        memset(spaces, ' ', numSpaces);
++        spaces[numSpaces] = '\0';
++
++        return [NSString stringWithFormat:@"%@%s", queueThreadLabel, spaces];
++    } else {
++        // Exact
++
++        return queueThreadLabel;
++    }
++}
++
++- (NSString *)formatLogMessage:(DDLogMessage *)logMessage {
++    NSString *timestamp = [self stringFromDate:(logMessage->_timestamp)];
++    NSString *queueThreadLabel = [self queueThreadLabelForLogMessage:logMessage];
++
++    return [NSString stringWithFormat:@"%@ [%@] %@", timestamp, queueThreadLabel, logMessage->_message];
++}
++
++- (void)didAddToLogger:(id <DDLogger>  __attribute__((unused)))logger {
++    int32_t count = 0;
++    count = OSAtomicIncrement32(&_atomicLoggerCount);
++    NSAssert(count <= 1 || _mode == DDDispatchQueueLogFormatterModeShareble, @"Can't reuse formatter with multiple loggers in non-shareable mode.");
++}
++
++- (void)willRemoveFromLogger:(id <DDLogger> __attribute__((unused)))logger {
++    OSAtomicDecrement32(&_atomicLoggerCount);
++}
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/Extensions/DDMultiFormatter.h b/Pods/CocoaLumberjack/Classes/Extensions/DDMultiFormatter.h
+new file mode 100644
+index 0000000..1d6ceea
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/Extensions/DDMultiFormatter.h
+@@ -0,0 +1,56 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++#import <Foundation/Foundation.h>
++
++// Disable legacy macros
++#ifndef DD_LEGACY_MACROS
++    #define DD_LEGACY_MACROS 0
++#endif
++
++#import "DDLog.h"
++
++/**
++ * This formatter can be used to chain different formatters together.
++ * The log message will processed in the order of the formatters added.
++ **/
++@interface DDMultiFormatter : NSObject <DDLogFormatter>
++
++/**
++ *  Array of chained formatters
++ */
++@property (readonly) NSArray *formatters;
++
++/**
++ *  Add a new formatter
++ */
++- (void)addFormatter:(id<DDLogFormatter>)formatter;
++
++/**
++ *  Remove a formatter
++ */
++- (void)removeFormatter:(id<DDLogFormatter>)formatter;
++
++/**
++ *  Remove all existing formatters
++ */
++- (void)removeAllFormatters;
++
++/**
++ *  Check if a certain formatter is used
++ */
++- (BOOL)isFormattingWithFormatter:(id<DDLogFormatter>)formatter;
++
++@end
+diff --git a/Pods/CocoaLumberjack/Classes/Extensions/DDMultiFormatter.m b/Pods/CocoaLumberjack/Classes/Extensions/DDMultiFormatter.m
+new file mode 100644
+index 0000000..c647da3
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Classes/Extensions/DDMultiFormatter.m
+@@ -0,0 +1,144 @@
++// Software License Agreement (BSD License)
++//
++// Copyright (c) 2010-2015, Deusty, LLC
++// All rights reserved.
++//
++// Redistribution and use of this software in source and binary forms,
++// with or without modification, are permitted provided that the following conditions are met:
++//
++// * Redistributions of source code must retain the above copyright notice,
++//   this list of conditions and the following disclaimer.
++//
++// * Neither the name of Deusty nor the names of its contributors may be used
++//   to endorse or promote products derived from this software without specific
++//   prior written permission of Deusty, LLC.
++
++#import "DDMultiFormatter.h"
++
++
++#if TARGET_OS_IOS
++// Compiling for iOS
++#if __IPHONE_OS_VERSION_MIN_REQUIRED >= 60000 // iOS 6.0 or later
++#define NEEDS_DISPATCH_RETAIN_RELEASE 0
++#else                                         // iOS 5.X or earlier
++#define NEEDS_DISPATCH_RETAIN_RELEASE 1
++#endif
++#elif TARGET_OS_WATCH || TARGET_OS_TV
++// Compiling for watchOS, tvOS
++#define NEEDS_DISPATCH_RETAIN_RELEASE 0
++#else
++// Compiling for Mac OS X
++#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1080     // Mac OS X 10.8 or later
++#define NEEDS_DISPATCH_RETAIN_RELEASE 0
++#else                                         // Mac OS X 10.7 or earlier
++#define NEEDS_DISPATCH_RETAIN_RELEASE 1
++#endif
++#endif
++
++
++#if !__has_feature(objc_arc)
++#error This file must be compiled with ARC. Use -fobjc-arc flag (or convert project to ARC).
++#endif
++
++
++@interface DDMultiFormatter () {
++    dispatch_queue_t _queue;
++    NSMutableArray *_formatters;
++}
++
++- (DDLogMessage *)logMessageForLine:(NSString *)line originalMessage:(DDLogMessage *)message;
++
++@end
++
++
++@implementation DDMultiFormatter
++
++- (instancetype)init {
++    self = [super init];
++
++    if (self) {
++#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
++        _queue = dispatch_queue_create("cocoa.lumberjack.multiformatter", DISPATCH_QUEUE_CONCURRENT);
++#else
++        _queue = dispatch_queue_create("cocoa.lumberjack.multiformatter", NULL);
++#endif
++        _formatters = [NSMutableArray new];
++    }
++
++    return self;
++}
++
++#if NEEDS_DISPATCH_RETAIN_RELEASE
++- (void)dealloc {
++    dispatch_release(_queue);
++}
++
++#endif
++
++#pragma mark Processing
++
++- (NSString *)formatLogMessage:(DDLogMessage *)logMessage {
++    __block NSString *line = logMessage->_message;
++
++    dispatch_sync(_queue, ^{
++        for (id<DDLogFormatter> formatter in _formatters) {
++            DDLogMessage *message = [self logMessageForLine:line originalMessage:logMessage];
++            line = [formatter formatLogMessage:message];
++
++            if (!line) {
++                break;
++            }
++        }
++    });
++
++    return line;
++}
++
++- (DDLogMessage *)logMessageForLine:(NSString *)line originalMessage:(DDLogMessage *)message {
++    DDLogMessage *newMessage = [message copy];
++
++    newMessage->_message = line;
++    return newMessage;
++}
++
++#pragma mark Formatters
++
++- (NSArray *)formatters {
++    __block NSArray *formatters;
++
++    dispatch_sync(_queue, ^{
++        formatters = [_formatters copy];
++    });
++
++    return formatters;
++}
++
++- (void)addFormatter:(id<DDLogFormatter>)formatter {
++    dispatch_barrier_async(_queue, ^{
++        [_formatters addObject:formatter];
++    });
++}
++
++- (void)removeFormatter:(id<DDLogFormatter>)formatter {
++    dispatch_barrier_async(_queue, ^{
++        [_formatters removeObject:formatter];
++    });
++}
++
++- (void)removeAllFormatters {
++    dispatch_barrier_async(_queue, ^{
++        [_formatters removeAllObjects];
++    });
++}
++
++- (BOOL)isFormattingWithFormatter:(id<DDLogFormatter>)formatter {
++    __block BOOL hasFormatter;
++
++    dispatch_sync(_queue, ^{
++        hasFormatter = [_formatters containsObject:formatter];
++    });
++
++    return hasFormatter;
++}
++
++@end
+diff --git a/Pods/CocoaLumberjack/Framework/Lumberjack/CocoaLumberjack.modulemap b/Pods/CocoaLumberjack/Framework/Lumberjack/CocoaLumberjack.modulemap
+new file mode 100644
+index 0000000..032ae65
+--- /dev/null
++++ b/Pods/CocoaLumberjack/Framework/Lumberjack/CocoaLumberjack.modulemap
+@@ -0,0 +1,36 @@
++framework module CocoaLumberjack {
++	umbrella header "CocoaLumberjack.h"
++	
++	export *
++	module * { export * }
++	
++	textual header "DDLogMacros.h"
++	
++	exclude header "DDLog+LOGV.h"
++	exclude header "DDLegacyMacros.h"
++	
++	explicit module DDContextFilterLogFormatter {
++		header "DDContextFilterLogFormatter.h"
++		export *
++	}
++	
++	explicit module DDDispatchQueueLogFormatter {
++		header "DDDispatchQueueLogFormatter.h"
++		export *
++	}
++	
++	explicit module DDMultiFormatter {
++		header "DDMultiFormatter.h"
++		export *
++	}
++	
++	explicit module DDASLLogCapture {
++		header "DDASLLogCapture.h"
++		export *
++	}
++	
++	explicit module DDAbstractDatabaseLogger {
++		header "DDAbstractDatabaseLogger.h"
++		export *
++	}
++}
+diff --git a/Pods/CocoaLumberjack/LICENSE.txt b/Pods/CocoaLumberjack/LICENSE.txt
+new file mode 100644
+index 0000000..9c29fac
+--- /dev/null
++++ b/Pods/CocoaLumberjack/LICENSE.txt
+@@ -0,0 +1,18 @@
++Software License Agreement (BSD License)
++
++Copyright (c) 2010-2015, Deusty, LLC
++All rights reserved.
++
++Redistribution and use of this software in source and binary forms,
++with or without modification, are permitted provided that the following conditions are met:
++
++* Redistributions of source code must retain the above
++  copyright notice, this list of conditions and the
++  following disclaimer.
++
++* Neither the name of Deusty nor the names of its
++  contributors may be used to endorse or promote products
++  derived from this software without specific prior
++  written permission of Deusty, LLC.
++
++THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+\ No newline at end of file
+diff --git a/Pods/CocoaLumberjack/README.md b/Pods/CocoaLumberjack/README.md
+new file mode 100644
+index 0000000..893fa53
+--- /dev/null
++++ b/Pods/CocoaLumberjack/README.md
+@@ -0,0 +1,197 @@
++<p align="center" >
++  <img src="LumberjackLogo.png" title="Lumberjack logo" float=left>
++</p>
++
++CocoaLumberjack
++===============
++[![Build Status](https://travis-ci.org/CocoaLumberjack/CocoaLumberjack.svg?branch=master)](https://travis-ci.org/CocoaLumberjack/CocoaLumberjack)
++[![Pod Version](http://img.shields.io/cocoapods/v/CocoaLumberjack.svg?style=flat)](http://cocoadocs.org/docsets/CocoaLumberjack/)
++[![Carthage compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)
++[![Pod Platform](http://img.shields.io/cocoapods/p/CocoaLumberjack.svg?style=flat)](http://cocoadocs.org/docsets/CocoaLumberjack/)
++[![Pod License](http://img.shields.io/cocoapods/l/CocoaLumberjack.svg?style=flat)](http://opensource.org/licenses/BSD-3-Clause)
++[![Reference Status](https://www.versioneye.com/objective-c/cocoalumberjack/reference_badge.svg?style=flat)](https://www.versioneye.com/objective-c/cocoalumberjack/references)
++
++**CocoaLumberjack** is a fast & simple, yet powerful & flexible logging framework for Mac and iOS.
++
++### How to get started
++- install via [CocoaPods](http://cocoapods.org)
++
++##### Swift version via CocoaPods
++```ruby
++platform :ios, '8.0'
++pod 'CocoaLumberjack/Swift'
++use_frameworks!
++```
++Note: `Swift` is a subspec which will include all the Obj-C code plus the Swift one, so this is sufficient. 
++For more details about how to use Swift with Lumberjack, see [this converation](https://github.com/CocoaLumberjack/CocoaLumberjack/issues/405).
++
++##### Swift Usage
++
++If you installed using CocoaPods or manually:
++```swift
++import CocoaLumberjack
++```
++
++```swift
++DDLog.addLogger(DDTTYLogger.sharedInstance()) // TTY = Xcode console
++DDLog.addLogger(DDASLLogger.sharedInstance()) // ASL = Apple System Logs
++
++let fileLogger: DDFileLogger = DDFileLogger() // File Logger
++fileLogger.rollingFrequency = 60*60*24  // 24 hours
++fileLogger.logFileManager.maximumNumberOfLogFiles = 7
++DDLog.addLogger(fileLogger)
++
++...
++
++DDLogVerbose("Verbose");
++DDLogDebug("Debug");
++DDLogInfo("Info");
++DDLogWarn("Warn");
++DDLogError("Error");
++```
++
++##### Obj-C version via CocoaPods
++
++```ruby
++platform :ios, '7.0'
++pod 'CocoaLumberjack'
++```
++
++##### Objc-C usage
++If you're using Lumberjack as a framework, you can `@import CocoaLumberjack`.
++
++Otherwise, `#import <CocoaLumberjack/CocoaLumberjack.h>`
++
++```objc
++[DDLog addLogger:[DDTTYLogger sharedInstance]]; // TTY = Xcode console
++[DDLog addLogger:[DDASLLogger sharedInstance]]; // ASL = Apple System Logs
++
++DDFileLogger *fileLogger = [[DDFileLogger alloc] init]; // File Logger
++fileLogger.rollingFrequency = 60 * 60 * 24; // 24 hour rolling
++fileLogger.logFileManager.maximumNumberOfLogFiles = 7;
++[DDLog addLogger:fileLogger];
++
++...
++
++DDLogVerbose(@"Verbose");
++DDLogDebug(@"Debug");
++DDLogInfo(@"Info");
++DDLogWarn(@"Warn");
++DDLogError(@"Error");
++```
++
++##### Installation with Carthage (iOS 8+)
++
++[Carthage](https://github.com/Carthage/Carthage) is a lightweight dependency manager for Swift and Objective-C. It leverages CocoaTouch modules and is less invasive than CocoaPods.
++
++To install with Carthage, follow the instruction on [Carthage](https://github.com/Carthage/Carthage)
++
++Cartfile
++```
++github "CocoaLumberjack/CocoaLumberjack"
++```
++
++- or [install manually](Documentation/GettingStarted.md#manual-installation)
++- read the [Getting started](Documentation/GettingStarted.md) guide, check out the [FAQ](Documentation/FAQ.md) section or the other [docs](Documentation/)
++- if you find issues or want to suggest improvements, create an issue or a pull request
++- for all kinds of questions involving CocoaLumberjack, use the [Google group](http://groups.google.com/group/cocoalumberjack) or StackOverflow (use [#lumberjack](http://stackoverflow.com/questions/tagged/lumberjack)).
++
++### CocoaLumberjack 2
++
++#### Migrating to 2.x
++
++* Replace `DDLog.h` imports by `#import <CocoaLumberjack/CocoaLumberjack.h>`.
++
++Advanced users, third party libraries:
++
++* Replace all `DDLogC` macros for regular `DDLog` macros.
++* Replace log level (`LOG_LEVEL_*`) macros with `DDLogLevel` enum values
++* Replace log flag (`LOG_FLAG_*`) macros with `DDLogFlag` enum values
++* Replace `DDLogMessage` ivars and method calls to the new ivars and methods
++  * `logMsg` with `_message`
++  * `logLevel` with `_level`
++  * `logFlag` with `_flag`
++  * `logContext` with `_context`
++  * `lineNumber` with `_line` (type changed from `int` to `NSUInteger`)
++  * `file` with `_file` (`filename` contains just the file name, without the extension and the full path)
++  * `timestamp` with `_timestamp`
++  * `methodName` with `function`
++* Replace `DDAbstractLogger` `formatter` to `logFormatter`
++* `YSSingleFileLogger` ivars are no longer accesible, use the methods instead
++* Replace `[DDLog addLogger:withLogLevel:]` with `[DDLog addLogger:withLevel:]`
++
++#### Forcing 1.x
++
++If an included library requires it, you can force CocoaLumberjack 1.x by setting the version before the conflicting library:
++
++```ruby
++pod 'CocoaLumberjack', '~> 1.9'
++pod 'ConflictingLibrary'
++```
++
++### Features
++
++#### Lumberjack is Fast & Simple, yet Powerful & Flexible.
++
++It is similar in concept to other popular logging frameworks such as log4j, yet is designed specifically for Objective-C, and takes advantage of features such as multi-threading, grand central dispatch (if available), lockless atomic operations, and the dynamic nature of the Objective-C runtime.
++
++#### Lumberjack is Fast
++
++In most cases it is an order of magnitude faster than NSLog.
++
++#### Lumberjack is Simple
++
++It takes as little as a single line of code to configure lumberjack when your application launches. Then simply replace your NSLog statements with DDLog statements and that's about it. (And the DDLog macros have the exact same format and syntax as NSLog, so it's super easy.)
++
++#### Lumberjack is Powerful:
++
++One log statement can be sent to multiple loggers, meaning you can log to a file and the console simultaneously. Want more? Create your own loggers (it's easy) and send your log statements over the network. Or to a database or distributed file system. The sky is the limit.
++
++#### Lumberjack is Flexible:
++
++Configure your logging however you want. Change log levels per file (perfect for debugging). Change log levels per logger (verbose console, but concise log file). Change log levels per xcode configuration (verbose debug, but concise release). Have your log statements compiled out of the release build. Customize the number of log levels for your application. Add your own fine-grained logging. Dynamically change log levels during runtime. Choose how & when you want your log files to be rolled. Upload your log files to a central server. Compress archived log files to save disk space...
++
++### This framework is for you if:
++
++-   You're looking for a way to track down that impossible-to-reproduce bug that keeps popping up in the field.
++-   You're frustrated with the super short console log on the iPhone.
++-   You're looking to take your application to the next level in terms of support and stability.
++-   You're looking for an enterprise level logging solution for your application (Mac or iPhone).
++
++### Documentation
++
++- **[Get started using Lumberjack](Documentation/GettingStarted.md)**<br/>
++- [Different log levels for Debug and Release builds](Documentation/XcodeTricks.md)<br/>
++- [Different log levels for each logger](Documentation/PerLoggerLogLevels.md)<br/>
++- [Use colors in the Xcode debugging console](Documentation/XcodeColors.md)<br/>
++- [Write your own custom formatters](Documentation/CustomFormatters.md)<br/>
++- [FAQ](Documentation/FAQ.md)<br/>
++- [Analysis of performance with benchmarks](Documentation/Performance.md)<br/>
++- [Common issues you may encounter and their solutions](Documentation/ProblemSolution.md)<br/>
++- [AppCode support](Documentation/AppCode-support.md)
++- **[Full Lumberjack documentation](Documentation/)**<br/>
++
++### Requirements 
++The current version of Lumberjack requires:
++- Xcode 7.1 or later
++- iOS 5 or later
++- OS X 10.7 or later
++- WatchOS 2 or later
++- TVOS 9 or later
++
++#### Backwards compability
++- for Xcode 7.0 or earlier, use the 2.1.0 version
++- for Xcode 6 or earlier, use the 2.0.x version
++- for OS X < 10.7 support, use the 1.6.0 version
++
++### Author
++- [Robbie Hanson](https://github.com/robbiehanson)
++- Love the project? Wanna buy me a coffee? (or a beer :D) [![donation](http://www.paypal.com/en_US/i/btn/btn_donate_SM.gif)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=UZRA26JPJB3DA)
++
++### Collaborators
++- [Ernesto Rivera](https://github.com/rivera-ernesto)
++- [Dmitry Vorobyov](https://github.com/dvor)
++- [Bogdan Poplauschi](https://github.com/bpoplauschi)
++
++### License
++- CocoaLumberjack is available under the BSD license. See the [LICENSE file](https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/LICENSE.txt).
+diff --git a/Pods/Headers/Private/CocoaLumberjack/CocoaLumberjack.h b/Pods/Headers/Private/CocoaLumberjack/CocoaLumberjack.h
+new file mode 120000
+index 0000000..45cddcf
+--- /dev/null
++++ b/Pods/Headers/Private/CocoaLumberjack/CocoaLumberjack.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/CocoaLumberjack.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Private/CocoaLumberjack/DDASLLogCapture.h b/Pods/Headers/Private/CocoaLumberjack/DDASLLogCapture.h
+new file mode 120000
+index 0000000..daa6c74
+--- /dev/null
++++ b/Pods/Headers/Private/CocoaLumberjack/DDASLLogCapture.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDASLLogCapture.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Private/CocoaLumberjack/DDASLLogger.h b/Pods/Headers/Private/CocoaLumberjack/DDASLLogger.h
+new file mode 120000
+index 0000000..e833dde
+--- /dev/null
++++ b/Pods/Headers/Private/CocoaLumberjack/DDASLLogger.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDASLLogger.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Private/CocoaLumberjack/DDAbstractDatabaseLogger.h b/Pods/Headers/Private/CocoaLumberjack/DDAbstractDatabaseLogger.h
+new file mode 120000
+index 0000000..84139e5
+--- /dev/null
++++ b/Pods/Headers/Private/CocoaLumberjack/DDAbstractDatabaseLogger.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDAbstractDatabaseLogger.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Private/CocoaLumberjack/DDAssertMacros.h b/Pods/Headers/Private/CocoaLumberjack/DDAssertMacros.h
+new file mode 120000
+index 0000000..756b2c0
+--- /dev/null
++++ b/Pods/Headers/Private/CocoaLumberjack/DDAssertMacros.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDAssertMacros.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Private/CocoaLumberjack/DDContextFilterLogFormatter.h b/Pods/Headers/Private/CocoaLumberjack/DDContextFilterLogFormatter.h
+new file mode 120000
+index 0000000..f88cca8
+--- /dev/null
++++ b/Pods/Headers/Private/CocoaLumberjack/DDContextFilterLogFormatter.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/Extensions/DDContextFilterLogFormatter.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Private/CocoaLumberjack/DDDispatchQueueLogFormatter.h b/Pods/Headers/Private/CocoaLumberjack/DDDispatchQueueLogFormatter.h
+new file mode 120000
+index 0000000..88ed39e
+--- /dev/null
++++ b/Pods/Headers/Private/CocoaLumberjack/DDDispatchQueueLogFormatter.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/Extensions/DDDispatchQueueLogFormatter.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Private/CocoaLumberjack/DDFileLogger.h b/Pods/Headers/Private/CocoaLumberjack/DDFileLogger.h
+new file mode 120000
+index 0000000..271368e
+--- /dev/null
++++ b/Pods/Headers/Private/CocoaLumberjack/DDFileLogger.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDFileLogger.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Private/CocoaLumberjack/DDLegacyMacros.h b/Pods/Headers/Private/CocoaLumberjack/DDLegacyMacros.h
+new file mode 120000
+index 0000000..d6df36a
+--- /dev/null
++++ b/Pods/Headers/Private/CocoaLumberjack/DDLegacyMacros.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDLegacyMacros.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Private/CocoaLumberjack/DDLog+LOGV.h b/Pods/Headers/Private/CocoaLumberjack/DDLog+LOGV.h
+new file mode 120000
+index 0000000..20cbcaa
+--- /dev/null
++++ b/Pods/Headers/Private/CocoaLumberjack/DDLog+LOGV.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDLog+LOGV.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Private/CocoaLumberjack/DDLog.h b/Pods/Headers/Private/CocoaLumberjack/DDLog.h
+new file mode 120000
+index 0000000..ddeb654
+--- /dev/null
++++ b/Pods/Headers/Private/CocoaLumberjack/DDLog.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDLog.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Private/CocoaLumberjack/DDLogMacros.h b/Pods/Headers/Private/CocoaLumberjack/DDLogMacros.h
+new file mode 120000
+index 0000000..33b944d
+--- /dev/null
++++ b/Pods/Headers/Private/CocoaLumberjack/DDLogMacros.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDLogMacros.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Private/CocoaLumberjack/DDMultiFormatter.h b/Pods/Headers/Private/CocoaLumberjack/DDMultiFormatter.h
+new file mode 120000
+index 0000000..0caeafa
+--- /dev/null
++++ b/Pods/Headers/Private/CocoaLumberjack/DDMultiFormatter.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/Extensions/DDMultiFormatter.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Private/CocoaLumberjack/DDTTYLogger.h b/Pods/Headers/Private/CocoaLumberjack/DDTTYLogger.h
+new file mode 120000
+index 0000000..e5fcddc
+--- /dev/null
++++ b/Pods/Headers/Private/CocoaLumberjack/DDTTYLogger.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDTTYLogger.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Public/CocoaLumberjack/CocoaLumberjack.h b/Pods/Headers/Public/CocoaLumberjack/CocoaLumberjack.h
+new file mode 120000
+index 0000000..45cddcf
+--- /dev/null
++++ b/Pods/Headers/Public/CocoaLumberjack/CocoaLumberjack.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/CocoaLumberjack.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Public/CocoaLumberjack/DDASLLogCapture.h b/Pods/Headers/Public/CocoaLumberjack/DDASLLogCapture.h
+new file mode 120000
+index 0000000..daa6c74
+--- /dev/null
++++ b/Pods/Headers/Public/CocoaLumberjack/DDASLLogCapture.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDASLLogCapture.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Public/CocoaLumberjack/DDASLLogger.h b/Pods/Headers/Public/CocoaLumberjack/DDASLLogger.h
+new file mode 120000
+index 0000000..e833dde
+--- /dev/null
++++ b/Pods/Headers/Public/CocoaLumberjack/DDASLLogger.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDASLLogger.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Public/CocoaLumberjack/DDAbstractDatabaseLogger.h b/Pods/Headers/Public/CocoaLumberjack/DDAbstractDatabaseLogger.h
+new file mode 120000
+index 0000000..84139e5
+--- /dev/null
++++ b/Pods/Headers/Public/CocoaLumberjack/DDAbstractDatabaseLogger.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDAbstractDatabaseLogger.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Public/CocoaLumberjack/DDAssertMacros.h b/Pods/Headers/Public/CocoaLumberjack/DDAssertMacros.h
+new file mode 120000
+index 0000000..756b2c0
+--- /dev/null
++++ b/Pods/Headers/Public/CocoaLumberjack/DDAssertMacros.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDAssertMacros.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Public/CocoaLumberjack/DDContextFilterLogFormatter.h b/Pods/Headers/Public/CocoaLumberjack/DDContextFilterLogFormatter.h
+new file mode 120000
+index 0000000..f88cca8
+--- /dev/null
++++ b/Pods/Headers/Public/CocoaLumberjack/DDContextFilterLogFormatter.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/Extensions/DDContextFilterLogFormatter.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Public/CocoaLumberjack/DDDispatchQueueLogFormatter.h b/Pods/Headers/Public/CocoaLumberjack/DDDispatchQueueLogFormatter.h
+new file mode 120000
+index 0000000..88ed39e
+--- /dev/null
++++ b/Pods/Headers/Public/CocoaLumberjack/DDDispatchQueueLogFormatter.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/Extensions/DDDispatchQueueLogFormatter.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Public/CocoaLumberjack/DDFileLogger.h b/Pods/Headers/Public/CocoaLumberjack/DDFileLogger.h
+new file mode 120000
+index 0000000..271368e
+--- /dev/null
++++ b/Pods/Headers/Public/CocoaLumberjack/DDFileLogger.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDFileLogger.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Public/CocoaLumberjack/DDLegacyMacros.h b/Pods/Headers/Public/CocoaLumberjack/DDLegacyMacros.h
+new file mode 120000
+index 0000000..d6df36a
+--- /dev/null
++++ b/Pods/Headers/Public/CocoaLumberjack/DDLegacyMacros.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDLegacyMacros.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Public/CocoaLumberjack/DDLog+LOGV.h b/Pods/Headers/Public/CocoaLumberjack/DDLog+LOGV.h
+new file mode 120000
+index 0000000..20cbcaa
+--- /dev/null
++++ b/Pods/Headers/Public/CocoaLumberjack/DDLog+LOGV.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDLog+LOGV.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Public/CocoaLumberjack/DDLog.h b/Pods/Headers/Public/CocoaLumberjack/DDLog.h
+new file mode 120000
+index 0000000..ddeb654
+--- /dev/null
++++ b/Pods/Headers/Public/CocoaLumberjack/DDLog.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDLog.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Public/CocoaLumberjack/DDLogMacros.h b/Pods/Headers/Public/CocoaLumberjack/DDLogMacros.h
+new file mode 120000
+index 0000000..33b944d
+--- /dev/null
++++ b/Pods/Headers/Public/CocoaLumberjack/DDLogMacros.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDLogMacros.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Public/CocoaLumberjack/DDMultiFormatter.h b/Pods/Headers/Public/CocoaLumberjack/DDMultiFormatter.h
+new file mode 120000
+index 0000000..0caeafa
+--- /dev/null
++++ b/Pods/Headers/Public/CocoaLumberjack/DDMultiFormatter.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/Extensions/DDMultiFormatter.h
+\ No newline at end of file
+diff --git a/Pods/Headers/Public/CocoaLumberjack/DDTTYLogger.h b/Pods/Headers/Public/CocoaLumberjack/DDTTYLogger.h
+new file mode 120000
+index 0000000..e5fcddc
+--- /dev/null
++++ b/Pods/Headers/Public/CocoaLumberjack/DDTTYLogger.h
+@@ -0,0 +1 @@
++../../../CocoaLumberjack/Classes/DDTTYLogger.h
+\ No newline at end of file
+diff --git a/Pods/Manifest.lock b/Pods/Manifest.lock
+new file mode 100644
+index 0000000..b8c2f04
+--- /dev/null
++++ b/Pods/Manifest.lock
+@@ -0,0 +1,17 @@
++PODS:
++  - CocoaLumberjack (2.2.0):
++    - CocoaLumberjack/Default (= 2.2.0)
++    - CocoaLumberjack/Extensions (= 2.2.0)
++  - CocoaLumberjack/Core (2.2.0)
++  - CocoaLumberjack/Default (2.2.0):
++    - CocoaLumberjack/Core
++  - CocoaLumberjack/Extensions (2.2.0):
++    - CocoaLumberjack/Default
++
++DEPENDENCIES:
++  - CocoaLumberjack
++
++SPEC CHECKSUMS:
++  CocoaLumberjack: 17fe8581f84914d5d7e6360f7c70022b173c3ae0
++
++COCOAPODS: 0.39.0
+diff --git a/Pods/Pods.xcodeproj/project.pbxproj b/Pods/Pods.xcodeproj/project.pbxproj
+new file mode 100644
+index 0000000..4762ef5
+--- /dev/null
++++ b/Pods/Pods.xcodeproj/project.pbxproj
+@@ -0,0 +1,544 @@
++// !$*UTF8*$!
++{
++	archiveVersion = 1;
++	classes = {
++	};
++	objectVersion = 46;
++	objects = {
++
++/* Begin PBXBuildFile section */
++		1E6A591B3DEE6317BB014BD71A50B689 /* DDASLLogCapture.h in Headers */ = {isa = PBXBuildFile; fileRef = F9A095E75CC15921913AEFF327CA2D51 /* DDASLLogCapture.h */; settings = {ATTRIBUTES = (Public, ); }; };
++		3DDD0FB94D61AB71C8F5C727EC7A0BD9 /* DDLogMacros.h in Headers */ = {isa = PBXBuildFile; fileRef = A5E4B18696A542D02367C1B04D654FE7 /* DDLogMacros.h */; settings = {ATTRIBUTES = (Public, ); }; };
++		41F221F9E8FDE456D3E9EB34B4C5EBF1 /* DDFileLogger.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C70497B4B7900D0D0AC99FE8AB395C6 /* DDFileLogger.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
++		456BEEAD8F6C8D0B35D5A12E72068119 /* DDLog.h in Headers */ = {isa = PBXBuildFile; fileRef = A169AE9A71FE7D86D03E35AEE1FAC6F8 /* DDLog.h */; settings = {ATTRIBUTES = (Public, ); }; };
++		4CAAFD85FC04FBFFB61A22F14C8D4684 /* DDContextFilterLogFormatter.h in Headers */ = {isa = PBXBuildFile; fileRef = 08D1257418C387D9D20F89315328D5EC /* DDContextFilterLogFormatter.h */; settings = {ATTRIBUTES = (Public, ); }; };
++		5539A292EFC958D90F290DBA5FF86220 /* DDDispatchQueueLogFormatter.h in Headers */ = {isa = PBXBuildFile; fileRef = B2D8F80CB641FA7E4A87ABBB3B571EC7 /* DDDispatchQueueLogFormatter.h */; settings = {ATTRIBUTES = (Public, ); }; };
++		5DCBA219BC81D9190F11EE56F93BB908 /* DDTTYLogger.h in Headers */ = {isa = PBXBuildFile; fileRef = 98D52DFC863E4F234815A48FB6BCDBD3 /* DDTTYLogger.h */; settings = {ATTRIBUTES = (Public, ); }; };
++		6077EFC05DC2551A7F5A1CFAC0B90187 /* DDAbstractDatabaseLogger.m in Sources */ = {isa = PBXBuildFile; fileRef = EDC1117352B86A27F1B34547BDE01BC6 /* DDAbstractDatabaseLogger.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
++		6475050C8BA464772209BD6AF03F1EB1 /* DDMultiFormatter.h in Headers */ = {isa = PBXBuildFile; fileRef = A28679B79F48C675D2A6BF74EF1BB967 /* DDMultiFormatter.h */; settings = {ATTRIBUTES = (Public, ); }; };
++		656479029A5A15463E080FD25F8903B2 /* DDASLLogger.m in Sources */ = {isa = PBXBuildFile; fileRef = DA4AD99FCDF845B442B1B3F570D940FE /* DDASLLogger.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
++		67E741D303696F9A1E863BC42E6A9C79 /* DDASLLogger.h in Headers */ = {isa = PBXBuildFile; fileRef = 788BB22E7DBA508D141D8CDEE188080F /* DDASLLogger.h */; settings = {ATTRIBUTES = (Public, ); }; };
++		6DAEF151B35D00265D60C4AD34431DD9 /* DDContextFilterLogFormatter.m in Sources */ = {isa = PBXBuildFile; fileRef = FC5551224D2BB2FCC7ECB3BC95508A98 /* DDContextFilterLogFormatter.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
++		800E4A92EA6927C595BBCA37F8EF94F6 /* Pods-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 272643F56613CA0D336AE3DBF19DC404 /* Pods-dummy.m */; };
++		906BA39B4449184A264475B0AAA9CD7B /* DDAssertMacros.h in Headers */ = {isa = PBXBuildFile; fileRef = 1ECA9AE91B3BD36523C5A7E8398E2B1D /* DDAssertMacros.h */; settings = {ATTRIBUTES = (Public, ); }; };
++		9258A7B71D4C13DBFC66C4B8BE43B79A /* DDAbstractDatabaseLogger.h in Headers */ = {isa = PBXBuildFile; fileRef = 94A49738BC61B921C3DC5971268AE019 /* DDAbstractDatabaseLogger.h */; settings = {ATTRIBUTES = (Public, ); }; };
++		9DFB1378A337698012F7CE5D593DC04F /* DDASLLogCapture.m in Sources */ = {isa = PBXBuildFile; fileRef = CCC9F995E016B3507790BD9090DC7D3A /* DDASLLogCapture.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
++		A2D0EE5602557677B5D9AB8D46F2F1AF /* DDLog+LOGV.h in Headers */ = {isa = PBXBuildFile; fileRef = 892DC79F537D840BFDC4C18A3E3FA05E /* DDLog+LOGV.h */; settings = {ATTRIBUTES = (Public, ); }; };
++		A34EF7C35E4E0657AFC8B4BA0B343867 /* CocoaLumberjack-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 903B95EE0B69E01EBE26C7A903313D10 /* CocoaLumberjack-dummy.m */; };
++		BBCA69A708A7B3DD861FB839B3A251B3 /* DDLegacyMacros.h in Headers */ = {isa = PBXBuildFile; fileRef = 07D14B15A24A77A47840C41A54B498AE /* DDLegacyMacros.h */; settings = {ATTRIBUTES = (Public, ); }; };
++		BF525D162B9ABC5DFA69FB7A8779F76E /* DDTTYLogger.m in Sources */ = {isa = PBXBuildFile; fileRef = 6A48E2707F82BB1204E9FE86C722BC38 /* DDTTYLogger.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
++		C515A390D549AF8A16A76DD72388BD2C /* DDFileLogger.h in Headers */ = {isa = PBXBuildFile; fileRef = 4ECBC81DB84A5A4288984BC5417A1458 /* DDFileLogger.h */; settings = {ATTRIBUTES = (Public, ); }; };
++		CBB6BB497EC1A4C36506AD74ECDCD99F /* CocoaLumberjack.h in Headers */ = {isa = PBXBuildFile; fileRef = BC4FEEADE0984F8E5187E582BA6E6D0B /* CocoaLumberjack.h */; settings = {ATTRIBUTES = (Public, ); }; };
++		D70BDFA09F4803DCFEAD7AF5DFE21C6A /* DDLog.m in Sources */ = {isa = PBXBuildFile; fileRef = C2D749143D5F49E3C9BD48FA7BB7165C /* DDLog.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
++		D86F62CA5DFEB5481E009AF3C783B179 /* Foundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 3E4E89230EF59BC255123B67864ACF77 /* Foundation.framework */; };
++		E0BA617FE1EF9C500AC8568F3B767D37 /* Foundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 3E4E89230EF59BC255123B67864ACF77 /* Foundation.framework */; };
++		E1ED34DB49C6A05D740B8425F88CEC20 /* DDMultiFormatter.m in Sources */ = {isa = PBXBuildFile; fileRef = E0B6669DD9DFCA4DA310C01E3382CC12 /* DDMultiFormatter.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
++		FE6239BDE2049B920243DC0F907F57B9 /* DDDispatchQueueLogFormatter.m in Sources */ = {isa = PBXBuildFile; fileRef = 3674FFD7C40D6DC34AC17AB452D2D62A /* DDDispatchQueueLogFormatter.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
++/* End PBXBuildFile section */
++
++/* Begin PBXContainerItemProxy section */
++		6A1C9345EE00EEC3F58CB3F47970D802 /* PBXContainerItemProxy */ = {
++			isa = PBXContainerItemProxy;
++			containerPortal = D41D8CD98F00B204E9800998ECF8427E /* Project object */;
++			proxyType = 1;
++			remoteGlobalIDString = 12E2BC28C62976C425F4B71C2723F0B1;
++			remoteInfo = CocoaLumberjack;
++		};
++/* End PBXContainerItemProxy section */
++
++/* Begin PBXFileReference section */
++		029E81A6EC8EE63AF432E16C802E014D /* libPods.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libPods.a; sourceTree = BUILT_PRODUCTS_DIR; };
++		07D14B15A24A77A47840C41A54B498AE /* DDLegacyMacros.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = DDLegacyMacros.h; path = Classes/DDLegacyMacros.h; sourceTree = "<group>"; };
++		08D1257418C387D9D20F89315328D5EC /* DDContextFilterLogFormatter.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = DDContextFilterLogFormatter.h; path = Classes/Extensions/DDContextFilterLogFormatter.h; sourceTree = "<group>"; };
++		10834806BD7B412BC24F347361FA2C8E /* Pods-acknowledgements.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = "Pods-acknowledgements.plist"; sourceTree = "<group>"; };
++		1ECA9AE91B3BD36523C5A7E8398E2B1D /* DDAssertMacros.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = DDAssertMacros.h; path = Classes/DDAssertMacros.h; sourceTree = "<group>"; };
++		272643F56613CA0D336AE3DBF19DC404 /* Pods-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "Pods-dummy.m"; sourceTree = "<group>"; };
++		3674FFD7C40D6DC34AC17AB452D2D62A /* DDDispatchQueueLogFormatter.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = DDDispatchQueueLogFormatter.m; path = Classes/Extensions/DDDispatchQueueLogFormatter.m; sourceTree = "<group>"; };
++		37DB56D75062CC75FCB0966E1C6E8A8E /* Pods-acknowledgements.markdown */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text; path = "Pods-acknowledgements.markdown"; sourceTree = "<group>"; };
++		3E4E89230EF59BC255123B67864ACF77 /* Foundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Foundation.framework; path = Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.0.sdk/System/Library/Frameworks/Foundation.framework; sourceTree = DEVELOPER_DIR; };
++		4E762F23EC34ED4A6FF3312D84E33A40 /* Pods.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = Pods.debug.xcconfig; sourceTree = "<group>"; };
++		4ECBC81DB84A5A4288984BC5417A1458 /* DDFileLogger.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = DDFileLogger.h; path = Classes/DDFileLogger.h; sourceTree = "<group>"; };
++		5D595B86B34FF5E69E7436ECF8656359 /* libCocoaLumberjack.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libCocoaLumberjack.a; sourceTree = BUILT_PRODUCTS_DIR; };
++		6911BECA35E7518D864239B7E898EEF3 /* Pods-frameworks.sh */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.script.sh; path = "Pods-frameworks.sh"; sourceTree = "<group>"; };
++		6A48E2707F82BB1204E9FE86C722BC38 /* DDTTYLogger.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = DDTTYLogger.m; path = Classes/DDTTYLogger.m; sourceTree = "<group>"; };
++		6A94949FDBA8DDEDE26D368F6681F14C /* CocoaLumberjack-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "CocoaLumberjack-prefix.pch"; sourceTree = "<group>"; };
++		788BB22E7DBA508D141D8CDEE188080F /* DDASLLogger.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = DDASLLogger.h; path = Classes/DDASLLogger.h; sourceTree = "<group>"; };
++		892DC79F537D840BFDC4C18A3E3FA05E /* DDLog+LOGV.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = "DDLog+LOGV.h"; path = "Classes/DDLog+LOGV.h"; sourceTree = "<group>"; };
++		8C70497B4B7900D0D0AC99FE8AB395C6 /* DDFileLogger.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = DDFileLogger.m; path = Classes/DDFileLogger.m; sourceTree = "<group>"; };
++		903B95EE0B69E01EBE26C7A903313D10 /* CocoaLumberjack-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "CocoaLumberjack-dummy.m"; sourceTree = "<group>"; };
++		94A49738BC61B921C3DC5971268AE019 /* DDAbstractDatabaseLogger.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = DDAbstractDatabaseLogger.h; path = Classes/DDAbstractDatabaseLogger.h; sourceTree = "<group>"; };
++		98C98CDFB3F20F2925F6CD1F141BB14F /* Pods.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = Pods.release.xcconfig; sourceTree = "<group>"; };
++		98D52DFC863E4F234815A48FB6BCDBD3 /* DDTTYLogger.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = DDTTYLogger.h; path = Classes/DDTTYLogger.h; sourceTree = "<group>"; };
++		9A545ADDA42B9C577F26075E5A0246AC /* CocoaLumberjack.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = CocoaLumberjack.xcconfig; sourceTree = "<group>"; };
++		A169AE9A71FE7D86D03E35AEE1FAC6F8 /* DDLog.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = DDLog.h; path = Classes/DDLog.h; sourceTree = "<group>"; };
++		A1A36D34413696BE466E2CA0AFF194DA /* Pods-resources.sh */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.script.sh; path = "Pods-resources.sh"; sourceTree = "<group>"; };
++		A28679B79F48C675D2A6BF74EF1BB967 /* DDMultiFormatter.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = DDMultiFormatter.h; path = Classes/Extensions/DDMultiFormatter.h; sourceTree = "<group>"; };
++		A5E4B18696A542D02367C1B04D654FE7 /* DDLogMacros.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = DDLogMacros.h; path = Classes/DDLogMacros.h; sourceTree = "<group>"; };
++		B2D8F80CB641FA7E4A87ABBB3B571EC7 /* DDDispatchQueueLogFormatter.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = DDDispatchQueueLogFormatter.h; path = Classes/Extensions/DDDispatchQueueLogFormatter.h; sourceTree = "<group>"; };
++		BA6428E9F66FD5A23C0A2E06ED26CD2F /* Podfile */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text; name = Podfile; path = ../Podfile; sourceTree = SOURCE_ROOT; xcLanguageSpecificationIdentifier = xcode.lang.ruby; };
++		BC4FEEADE0984F8E5187E582BA6E6D0B /* CocoaLumberjack.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = CocoaLumberjack.h; path = Classes/CocoaLumberjack.h; sourceTree = "<group>"; };
++		C2D749143D5F49E3C9BD48FA7BB7165C /* DDLog.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = DDLog.m; path = Classes/DDLog.m; sourceTree = "<group>"; };
++		CCC9F995E016B3507790BD9090DC7D3A /* DDASLLogCapture.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = DDASLLogCapture.m; path = Classes/DDASLLogCapture.m; sourceTree = "<group>"; };
++		DA4AD99FCDF845B442B1B3F570D940FE /* DDASLLogger.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = DDASLLogger.m; path = Classes/DDASLLogger.m; sourceTree = "<group>"; };
++		E0B6669DD9DFCA4DA310C01E3382CC12 /* DDMultiFormatter.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = DDMultiFormatter.m; path = Classes/Extensions/DDMultiFormatter.m; sourceTree = "<group>"; };
++		EDC1117352B86A27F1B34547BDE01BC6 /* DDAbstractDatabaseLogger.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = DDAbstractDatabaseLogger.m; path = Classes/DDAbstractDatabaseLogger.m; sourceTree = "<group>"; };
++		F9A095E75CC15921913AEFF327CA2D51 /* DDASLLogCapture.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = DDASLLogCapture.h; path = Classes/DDASLLogCapture.h; sourceTree = "<group>"; };
++		FC5551224D2BB2FCC7ECB3BC95508A98 /* DDContextFilterLogFormatter.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = DDContextFilterLogFormatter.m; path = Classes/Extensions/DDContextFilterLogFormatter.m; sourceTree = "<group>"; };
++/* End PBXFileReference section */
++
++/* Begin PBXFrameworksBuildPhase section */
++		05BCD33A93C626516F479F56D2116E49 /* Frameworks */ = {
++			isa = PBXFrameworksBuildPhase;
++			buildActionMask = 2147483647;
++			files = (
++				D86F62CA5DFEB5481E009AF3C783B179 /* Foundation.framework in Frameworks */,
++			);
++			runOnlyForDeploymentPostprocessing = 0;
++		};
++		7A57C9EB0677D4F03EF225837F802614 /* Frameworks */ = {
++			isa = PBXFrameworksBuildPhase;
++			buildActionMask = 2147483647;
++			files = (
++				E0BA617FE1EF9C500AC8568F3B767D37 /* Foundation.framework in Frameworks */,
++			);
++			runOnlyForDeploymentPostprocessing = 0;
++		};
++/* End PBXFrameworksBuildPhase section */
++
++/* Begin PBXGroup section */
++		037C0CA694176A3C0915F62C9D20B3E6 /* Targets Support Files */ = {
++			isa = PBXGroup;
++			children = (
++				B3D1D13E0C6553800746CB8FD61CF946 /* Pods */,
++			);
++			name = "Targets Support Files";
++			sourceTree = "<group>";
++		};
++		5929AF996E94DECB6A3E059E72243262 /* Products */ = {
++			isa = PBXGroup;
++			children = (
++				5D595B86B34FF5E69E7436ECF8656359 /* libCocoaLumberjack.a */,
++				029E81A6EC8EE63AF432E16C802E014D /* libPods.a */,
++			);
++			name = Products;
++			sourceTree = "<group>";
++		};
++		5C5ADCACB7CD40E797DC397E0D5FF1B4 /* Extensions */ = {
++			isa = PBXGroup;
++			children = (
++				08D1257418C387D9D20F89315328D5EC /* DDContextFilterLogFormatter.h */,
++				FC5551224D2BB2FCC7ECB3BC95508A98 /* DDContextFilterLogFormatter.m */,
++				B2D8F80CB641FA7E4A87ABBB3B571EC7 /* DDDispatchQueueLogFormatter.h */,
++				3674FFD7C40D6DC34AC17AB452D2D62A /* DDDispatchQueueLogFormatter.m */,
++				A28679B79F48C675D2A6BF74EF1BB967 /* DDMultiFormatter.h */,
++				E0B6669DD9DFCA4DA310C01E3382CC12 /* DDMultiFormatter.m */,
++			);
++			name = Extensions;
++			sourceTree = "<group>";
++		};
++		5D1F3F5C10FDF538279E6565F620E76A /* Core */ = {
++			isa = PBXGroup;
++			children = (
++				94A49738BC61B921C3DC5971268AE019 /* DDAbstractDatabaseLogger.h */,
++				EDC1117352B86A27F1B34547BDE01BC6 /* DDAbstractDatabaseLogger.m */,
++				F9A095E75CC15921913AEFF327CA2D51 /* DDASLLogCapture.h */,
++				CCC9F995E016B3507790BD9090DC7D3A /* DDASLLogCapture.m */,
++				788BB22E7DBA508D141D8CDEE188080F /* DDASLLogger.h */,
++				DA4AD99FCDF845B442B1B3F570D940FE /* DDASLLogger.m */,
++				1ECA9AE91B3BD36523C5A7E8398E2B1D /* DDAssertMacros.h */,
++				4ECBC81DB84A5A4288984BC5417A1458 /* DDFileLogger.h */,
++				8C70497B4B7900D0D0AC99FE8AB395C6 /* DDFileLogger.m */,
++				07D14B15A24A77A47840C41A54B498AE /* DDLegacyMacros.h */,
++				A169AE9A71FE7D86D03E35AEE1FAC6F8 /* DDLog.h */,
++				C2D749143D5F49E3C9BD48FA7BB7165C /* DDLog.m */,
++				892DC79F537D840BFDC4C18A3E3FA05E /* DDLog+LOGV.h */,
++				A5E4B18696A542D02367C1B04D654FE7 /* DDLogMacros.h */,
++				98D52DFC863E4F234815A48FB6BCDBD3 /* DDTTYLogger.h */,
++				6A48E2707F82BB1204E9FE86C722BC38 /* DDTTYLogger.m */,
++			);
++			name = Core;
++			sourceTree = "<group>";
++		};
++		5DF74588DF80EB07A1AC927BBEA2E67E /* Support Files */ = {
++			isa = PBXGroup;
++			children = (
++				9A545ADDA42B9C577F26075E5A0246AC /* CocoaLumberjack.xcconfig */,
++				903B95EE0B69E01EBE26C7A903313D10 /* CocoaLumberjack-dummy.m */,
++				6A94949FDBA8DDEDE26D368F6681F14C /* CocoaLumberjack-prefix.pch */,
++			);
++			name = "Support Files";
++			path = "../Target Support Files/CocoaLumberjack";
++			sourceTree = "<group>";
++		};
++		7DB346D0F39D3F0E887471402A8071AB = {
++			isa = PBXGroup;
++			children = (
++				BA6428E9F66FD5A23C0A2E06ED26CD2F /* Podfile */,
++				BC3CA7F9E30CC8F7E2DD044DD34432FC /* Frameworks */,
++				E973B0FBD48111F2CBE01BB9EAD1976C /* Pods */,
++				5929AF996E94DECB6A3E059E72243262 /* Products */,
++				037C0CA694176A3C0915F62C9D20B3E6 /* Targets Support Files */,
++			);
++			sourceTree = "<group>";
++		};
++		B3D1D13E0C6553800746CB8FD61CF946 /* Pods */ = {
++			isa = PBXGroup;
++			children = (
++				37DB56D75062CC75FCB0966E1C6E8A8E /* Pods-acknowledgements.markdown */,
++				10834806BD7B412BC24F347361FA2C8E /* Pods-acknowledgements.plist */,
++				272643F56613CA0D336AE3DBF19DC404 /* Pods-dummy.m */,
++				6911BECA35E7518D864239B7E898EEF3 /* Pods-frameworks.sh */,
++				A1A36D34413696BE466E2CA0AFF194DA /* Pods-resources.sh */,
++				4E762F23EC34ED4A6FF3312D84E33A40 /* Pods.debug.xcconfig */,
++				98C98CDFB3F20F2925F6CD1F141BB14F /* Pods.release.xcconfig */,
++			);
++			name = Pods;
++			path = "Target Support Files/Pods";
++			sourceTree = "<group>";
++		};
++		B50DAE85EC0797AF441E495CA80CB19B /* Default */ = {
++			isa = PBXGroup;
++			children = (
++				BC4FEEADE0984F8E5187E582BA6E6D0B /* CocoaLumberjack.h */,
++			);
++			name = Default;
++			sourceTree = "<group>";
++		};
++		BC3CA7F9E30CC8F7E2DD044DD34432FC /* Frameworks */ = {
++			isa = PBXGroup;
++			children = (
++				BF6342C8B29F4CEEA088EFF7AB4DE362 /* iOS */,
++			);
++			name = Frameworks;
++			sourceTree = "<group>";
++		};
++		BDDFB5D0FD80A7257AD857F554113CCF /* CocoaLumberjack */ = {
++			isa = PBXGroup;
++			children = (
++				5D1F3F5C10FDF538279E6565F620E76A /* Core */,
++				B50DAE85EC0797AF441E495CA80CB19B /* Default */,
++				5C5ADCACB7CD40E797DC397E0D5FF1B4 /* Extensions */,
++				5DF74588DF80EB07A1AC927BBEA2E67E /* Support Files */,
++			);
++			path = CocoaLumberjack;
++			sourceTree = "<group>";
++		};
++		BF6342C8B29F4CEEA088EFF7AB4DE362 /* iOS */ = {
++			isa = PBXGroup;
++			children = (
++				3E4E89230EF59BC255123B67864ACF77 /* Foundation.framework */,
++			);
++			name = iOS;
++			sourceTree = "<group>";
++		};
++		E973B0FBD48111F2CBE01BB9EAD1976C /* Pods */ = {
++			isa = PBXGroup;
++			children = (
++				BDDFB5D0FD80A7257AD857F554113CCF /* CocoaLumberjack */,
++			);
++			name = Pods;
++			sourceTree = "<group>";
++		};
++/* End PBXGroup section */
++
++/* Begin PBXHeadersBuildPhase section */
++		3D1929340700AE302905262BB6EE9651 /* Headers */ = {
++			isa = PBXHeadersBuildPhase;
++			buildActionMask = 2147483647;
++			files = (
++				CBB6BB497EC1A4C36506AD74ECDCD99F /* CocoaLumberjack.h in Headers */,
++				9258A7B71D4C13DBFC66C4B8BE43B79A /* DDAbstractDatabaseLogger.h in Headers */,
++				1E6A591B3DEE6317BB014BD71A50B689 /* DDASLLogCapture.h in Headers */,
++				67E741D303696F9A1E863BC42E6A9C79 /* DDASLLogger.h in Headers */,
++				906BA39B4449184A264475B0AAA9CD7B /* DDAssertMacros.h in Headers */,
++				4CAAFD85FC04FBFFB61A22F14C8D4684 /* DDContextFilterLogFormatter.h in Headers */,
++				5539A292EFC958D90F290DBA5FF86220 /* DDDispatchQueueLogFormatter.h in Headers */,
++				C515A390D549AF8A16A76DD72388BD2C /* DDFileLogger.h in Headers */,
++				BBCA69A708A7B3DD861FB839B3A251B3 /* DDLegacyMacros.h in Headers */,
++				A2D0EE5602557677B5D9AB8D46F2F1AF /* DDLog+LOGV.h in Headers */,
++				456BEEAD8F6C8D0B35D5A12E72068119 /* DDLog.h in Headers */,
++				3DDD0FB94D61AB71C8F5C727EC7A0BD9 /* DDLogMacros.h in Headers */,
++				6475050C8BA464772209BD6AF03F1EB1 /* DDMultiFormatter.h in Headers */,
++				5DCBA219BC81D9190F11EE56F93BB908 /* DDTTYLogger.h in Headers */,
++			);
++			runOnlyForDeploymentPostprocessing = 0;
++		};
++/* End PBXHeadersBuildPhase section */
++
++/* Begin PBXNativeTarget section */
++		12E2BC28C62976C425F4B71C2723F0B1 /* CocoaLumberjack */ = {
++			isa = PBXNativeTarget;
++			buildConfigurationList = E0C8BB684C9CCC379207FFA69ED0D571 /* Build configuration list for PBXNativeTarget "CocoaLumberjack" */;
++			buildPhases = (
++				896BFDD81CD617BCCE12E7FCD204E6D7 /* Sources */,
++				05BCD33A93C626516F479F56D2116E49 /* Frameworks */,
++				3D1929340700AE302905262BB6EE9651 /* Headers */,
++			);
++			buildRules = (
++			);
++			dependencies = (
++			);
++			name = CocoaLumberjack;
++			productName = CocoaLumberjack;
++			productReference = 5D595B86B34FF5E69E7436ECF8656359 /* libCocoaLumberjack.a */;
++			productType = "com.apple.product-type.library.static";
++		};
++		336DBF20648F51A3CCA9CD21FAC160AA /* Pods */ = {
++			isa = PBXNativeTarget;
++			buildConfigurationList = 5B218E2AB387B90F84CB25838F7FD5F0 /* Build configuration list for PBXNativeTarget "Pods" */;
++			buildPhases = (
++				0AC3F70A08D7148E7F7DA818FAAFE08F /* Sources */,
++				7A57C9EB0677D4F03EF225837F802614 /* Frameworks */,
++			);
++			buildRules = (
++			);
++			dependencies = (
++				1CD38358627A978E3B1E7C0052DA1005 /* PBXTargetDependency */,
++			);
++			name = Pods;
++			productName = Pods;
++			productReference = 029E81A6EC8EE63AF432E16C802E014D /* libPods.a */;
++			productType = "com.apple.product-type.library.static";
++		};
++/* End PBXNativeTarget section */
++
++/* Begin PBXProject section */
++		D41D8CD98F00B204E9800998ECF8427E /* Project object */ = {
++			isa = PBXProject;
++			attributes = {
++				LastSwiftUpdateCheck = 0700;
++				LastUpgradeCheck = 0700;
++			};
++			buildConfigurationList = 2D8E8EC45A3A1A1D94AE762CB5028504 /* Build configuration list for PBXProject "Pods" */;
++			compatibilityVersion = "Xcode 3.2";
++			developmentRegion = English;
++			hasScannedForEncodings = 0;
++			knownRegions = (
++				en,
++			);
++			mainGroup = 7DB346D0F39D3F0E887471402A8071AB;
++			productRefGroup = 5929AF996E94DECB6A3E059E72243262 /* Products */;
++			projectDirPath = "";
++			projectRoot = "";
++			targets = (
++				12E2BC28C62976C425F4B71C2723F0B1 /* CocoaLumberjack */,
++				336DBF20648F51A3CCA9CD21FAC160AA /* Pods */,
++			);
++		};
++/* End PBXProject section */
++
++/* Begin PBXSourcesBuildPhase section */
++		0AC3F70A08D7148E7F7DA818FAAFE08F /* Sources */ = {
++			isa = PBXSourcesBuildPhase;
++			buildActionMask = 2147483647;
++			files = (
++				800E4A92EA6927C595BBCA37F8EF94F6 /* Pods-dummy.m in Sources */,
++			);
++			runOnlyForDeploymentPostprocessing = 0;
++		};
++		896BFDD81CD617BCCE12E7FCD204E6D7 /* Sources */ = {
++			isa = PBXSourcesBuildPhase;
++			buildActionMask = 2147483647;
++			files = (
++				A34EF7C35E4E0657AFC8B4BA0B343867 /* CocoaLumberjack-dummy.m in Sources */,
++				6077EFC05DC2551A7F5A1CFAC0B90187 /* DDAbstractDatabaseLogger.m in Sources */,
++				9DFB1378A337698012F7CE5D593DC04F /* DDASLLogCapture.m in Sources */,
++				656479029A5A15463E080FD25F8903B2 /* DDASLLogger.m in Sources */,
++				6DAEF151B35D00265D60C4AD34431DD9 /* DDContextFilterLogFormatter.m in Sources */,
++				FE6239BDE2049B920243DC0F907F57B9 /* DDDispatchQueueLogFormatter.m in Sources */,
++				41F221F9E8FDE456D3E9EB34B4C5EBF1 /* DDFileLogger.m in Sources */,
++				D70BDFA09F4803DCFEAD7AF5DFE21C6A /* DDLog.m in Sources */,
++				E1ED34DB49C6A05D740B8425F88CEC20 /* DDMultiFormatter.m in Sources */,
++				BF525D162B9ABC5DFA69FB7A8779F76E /* DDTTYLogger.m in Sources */,
++			);
++			runOnlyForDeploymentPostprocessing = 0;
++		};
++/* End PBXSourcesBuildPhase section */
++
++/* Begin PBXTargetDependency section */
++		1CD38358627A978E3B1E7C0052DA1005 /* PBXTargetDependency */ = {
++			isa = PBXTargetDependency;
++			name = CocoaLumberjack;
++			target = 12E2BC28C62976C425F4B71C2723F0B1 /* CocoaLumberjack */;
++			targetProxy = 6A1C9345EE00EEC3F58CB3F47970D802 /* PBXContainerItemProxy */;
++		};
++/* End PBXTargetDependency section */
++
++/* Begin XCBuildConfiguration section */
++		052A17875CB827423D627183396CEB60 /* Release */ = {
++			isa = XCBuildConfiguration;
++			buildSettings = {
++				ALWAYS_SEARCH_USER_PATHS = NO;
++				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
++				CLANG_CXX_LIBRARY = "libc++";
++				CLANG_ENABLE_MODULES = YES;
++				CLANG_ENABLE_OBJC_ARC = YES;
++				CLANG_WARN_BOOL_CONVERSION = YES;
++				CLANG_WARN_CONSTANT_CONVERSION = YES;
++				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES;
++				CLANG_WARN_EMPTY_BODY = YES;
++				CLANG_WARN_ENUM_CONVERSION = YES;
++				CLANG_WARN_INT_CONVERSION = YES;
++				CLANG_WARN_OBJC_ROOT_CLASS = YES;
++				CLANG_WARN_UNREACHABLE_CODE = YES;
++				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
++				COPY_PHASE_STRIP = YES;
++				ENABLE_NS_ASSERTIONS = NO;
++				GCC_C_LANGUAGE_STANDARD = gnu99;
++				GCC_PREPROCESSOR_DEFINITIONS = "RELEASE=1";
++				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
++				GCC_WARN_ABOUT_RETURN_TYPE = YES;
++				GCC_WARN_UNDECLARED_SELECTOR = YES;
++				GCC_WARN_UNINITIALIZED_AUTOS = YES;
++				GCC_WARN_UNUSED_FUNCTION = YES;
++				GCC_WARN_UNUSED_VARIABLE = YES;
++				IPHONEOS_DEPLOYMENT_TARGET = 7.0;
++				STRIP_INSTALLED_PRODUCT = NO;
++				SYMROOT = "${SRCROOT}/../build";
++				VALIDATE_PRODUCT = YES;
++			};
++			name = Release;
++		};
++		0F8EEE4B426FC98B444BD00E5C26875C /* Release */ = {
++			isa = XCBuildConfiguration;
++			baseConfigurationReference = 98C98CDFB3F20F2925F6CD1F141BB14F /* Pods.release.xcconfig */;
++			buildSettings = {
++				ENABLE_STRICT_OBJC_MSGSEND = YES;
++				IPHONEOS_DEPLOYMENT_TARGET = 7.0;
++				MACH_O_TYPE = staticlib;
++				MTL_ENABLE_DEBUG_INFO = NO;
++				OTHER_LDFLAGS = "";
++				OTHER_LIBTOOLFLAGS = "";
++				PODS_ROOT = "$(SRCROOT)";
++				PRODUCT_NAME = "$(TARGET_NAME)";
++				SDKROOT = iphoneos;
++				SKIP_INSTALL = YES;
++			};
++			name = Release;
++		};
++		1D170BD7E8EB420FBD5318D3D5550857 /* Release */ = {
++			isa = XCBuildConfiguration;
++			baseConfigurationReference = 9A545ADDA42B9C577F26075E5A0246AC /* CocoaLumberjack.xcconfig */;
++			buildSettings = {
++				ENABLE_STRICT_OBJC_MSGSEND = YES;
++				GCC_PREFIX_HEADER = "Target Support Files/CocoaLumberjack/CocoaLumberjack-prefix.pch";
++				IPHONEOS_DEPLOYMENT_TARGET = 7.0;
++				MTL_ENABLE_DEBUG_INFO = NO;
++				OTHER_LDFLAGS = "";
++				OTHER_LIBTOOLFLAGS = "";
++				PRIVATE_HEADERS_FOLDER_PATH = "";
++				PRODUCT_NAME = "$(TARGET_NAME)";
++				PUBLIC_HEADERS_FOLDER_PATH = "";
++				SDKROOT = iphoneos;
++				SKIP_INSTALL = YES;
++			};
++			name = Release;
++		};
++		A6C9F62F7C92008E8617ABAC38635FAA /* Debug */ = {
++			isa = XCBuildConfiguration;
++			baseConfigurationReference = 9A545ADDA42B9C577F26075E5A0246AC /* CocoaLumberjack.xcconfig */;
++			buildSettings = {
++				ENABLE_STRICT_OBJC_MSGSEND = YES;
++				GCC_PREFIX_HEADER = "Target Support Files/CocoaLumberjack/CocoaLumberjack-prefix.pch";
++				IPHONEOS_DEPLOYMENT_TARGET = 7.0;
++				MTL_ENABLE_DEBUG_INFO = YES;
++				OTHER_LDFLAGS = "";
++				OTHER_LIBTOOLFLAGS = "";
++				PRIVATE_HEADERS_FOLDER_PATH = "";
++				PRODUCT_NAME = "$(TARGET_NAME)";
++				PUBLIC_HEADERS_FOLDER_PATH = "";
++				SDKROOT = iphoneos;
++				SKIP_INSTALL = YES;
++			};
++			name = Debug;
++		};
++		AAC8209BC390113B1142A6A15F13388B /* Debug */ = {
++			isa = XCBuildConfiguration;
++			baseConfigurationReference = 4E762F23EC34ED4A6FF3312D84E33A40 /* Pods.debug.xcconfig */;
++			buildSettings = {
++				ENABLE_STRICT_OBJC_MSGSEND = YES;
++				IPHONEOS_DEPLOYMENT_TARGET = 7.0;
++				MACH_O_TYPE = staticlib;
++				MTL_ENABLE_DEBUG_INFO = YES;
++				OTHER_LDFLAGS = "";
++				OTHER_LIBTOOLFLAGS = "";
++				PODS_ROOT = "$(SRCROOT)";
++				PRODUCT_NAME = "$(TARGET_NAME)";
++				SDKROOT = iphoneos;
++				SKIP_INSTALL = YES;
++			};
++			name = Debug;
++		};
++		B37F0F91F85060E28F1DAAB522DC7EC1 /* Debug */ = {
++			isa = XCBuildConfiguration;
++			buildSettings = {
++				ALWAYS_SEARCH_USER_PATHS = NO;
++				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
++				CLANG_CXX_LIBRARY = "libc++";
++				CLANG_ENABLE_MODULES = YES;
++				CLANG_ENABLE_OBJC_ARC = YES;
++				CLANG_WARN_BOOL_CONVERSION = YES;
++				CLANG_WARN_CONSTANT_CONVERSION = YES;
++				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES;
++				CLANG_WARN_EMPTY_BODY = YES;
++				CLANG_WARN_ENUM_CONVERSION = YES;
++				CLANG_WARN_INT_CONVERSION = YES;
++				CLANG_WARN_OBJC_ROOT_CLASS = YES;
++				CLANG_WARN_UNREACHABLE_CODE = YES;
++				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
++				COPY_PHASE_STRIP = NO;
++				GCC_C_LANGUAGE_STANDARD = gnu99;
++				GCC_DYNAMIC_NO_PIC = NO;
++				GCC_OPTIMIZATION_LEVEL = 0;
++				GCC_PREPROCESSOR_DEFINITIONS = (
++					"DEBUG=1",
++					"$(inherited)",
++				);
++				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
++				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
++				GCC_WARN_ABOUT_RETURN_TYPE = YES;
++				GCC_WARN_UNDECLARED_SELECTOR = YES;
++				GCC_WARN_UNINITIALIZED_AUTOS = YES;
++				GCC_WARN_UNUSED_FUNCTION = YES;
++				GCC_WARN_UNUSED_VARIABLE = YES;
++				IPHONEOS_DEPLOYMENT_TARGET = 7.0;
++				ONLY_ACTIVE_ARCH = YES;
++				STRIP_INSTALLED_PRODUCT = NO;
++				SYMROOT = "${SRCROOT}/../build";
++			};
++			name = Debug;
++		};
++/* End XCBuildConfiguration section */
++
++/* Begin XCConfigurationList section */
++		2D8E8EC45A3A1A1D94AE762CB5028504 /* Build configuration list for PBXProject "Pods" */ = {
++			isa = XCConfigurationList;
++			buildConfigurations = (
++				B37F0F91F85060E28F1DAAB522DC7EC1 /* Debug */,
++				052A17875CB827423D627183396CEB60 /* Release */,
++			);
++			defaultConfigurationIsVisible = 0;
++			defaultConfigurationName = Release;
++		};
++		5B218E2AB387B90F84CB25838F7FD5F0 /* Build configuration list for PBXNativeTarget "Pods" */ = {
++			isa = XCConfigurationList;
++			buildConfigurations = (
++				AAC8209BC390113B1142A6A15F13388B /* Debug */,
++				0F8EEE4B426FC98B444BD00E5C26875C /* Release */,
++			);
++			defaultConfigurationIsVisible = 0;
++			defaultConfigurationName = Release;
++		};
++		E0C8BB684C9CCC379207FFA69ED0D571 /* Build configuration list for PBXNativeTarget "CocoaLumberjack" */ = {
++			isa = XCConfigurationList;
++			buildConfigurations = (
++				A6C9F62F7C92008E8617ABAC38635FAA /* Debug */,
++				1D170BD7E8EB420FBD5318D3D5550857 /* Release */,
++			);
++			defaultConfigurationIsVisible = 0;
++			defaultConfigurationName = Release;
++		};
++/* End XCConfigurationList section */
++	};
++	rootObject = D41D8CD98F00B204E9800998ECF8427E /* Project object */;
++}
+diff --git a/Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/CocoaLumberjack.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/CocoaLumberjack.xcscheme
+new file mode 100644
+index 0000000..c7522b0
+--- /dev/null
++++ b/Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/CocoaLumberjack.xcscheme
+@@ -0,0 +1,60 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<Scheme
++   LastUpgradeVersion = "0700"
++   version = "1.3">
++   <BuildAction
++      parallelizeBuildables = "YES"
++      buildImplicitDependencies = "YES">
++      <BuildActionEntries>
++         <BuildActionEntry
++            buildForAnalyzing = "YES"
++            buildForTesting = "YES"
++            buildForRunning = "YES"
++            buildForProfiling = "YES"
++            buildForArchiving = "YES">
++            <BuildableReference
++               BuildableIdentifier = 'primary'
++               BlueprintIdentifier = '8641C2738D5C124B1A6B0CC8'
++               BlueprintName = 'CocoaLumberjack'
++               ReferencedContainer = 'container:Pods.xcodeproj'
++               BuildableName = 'libCocoaLumberjack.a'>
++            </BuildableReference>
++         </BuildActionEntry>
++      </BuildActionEntries>
++   </BuildAction>
++   <TestAction
++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
++      shouldUseLaunchSchemeArgsEnv = "YES"
++      buildConfiguration = "Debug">
++      <AdditionalOptions>
++      </AdditionalOptions>
++   </TestAction>
++   <LaunchAction
++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
++      launchStyle = "0"
++      useCustomWorkingDirectory = "NO"
++      ignoresPersistentStateOnLaunch = "NO"
++      debugDocumentVersioning = "YES"
++      debugServiceExtension = "internal"
++      buildConfiguration = "Debug"
++      allowLocationSimulation = "YES">
++      <AdditionalOptions>
++      </AdditionalOptions>
++   </LaunchAction>
++   <ProfileAction
++      savedToolIdentifier = ""
++      useCustomWorkingDirectory = "NO"
++      debugDocumentVersioning = "YES"
++      buildConfiguration = "Release"
++      shouldUseLaunchSchemeArgsEnv = "YES">
++   </ProfileAction>
++   <AnalyzeAction
++      buildConfiguration = "Debug">
++   </AnalyzeAction>
++   <ArchiveAction
++      buildConfiguration = "Release"
++      revealArchiveInOrganizer = "YES">
++   </ArchiveAction>
++</Scheme>
+diff --git a/Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/Pods.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/Pods.xcscheme
+new file mode 100644
+index 0000000..a6bafa4
+--- /dev/null
++++ b/Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/Pods.xcscheme
+@@ -0,0 +1,60 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<Scheme
++   LastUpgradeVersion = "0700"
++   version = "1.3">
++   <BuildAction
++      parallelizeBuildables = "YES"
++      buildImplicitDependencies = "YES">
++      <BuildActionEntries>
++         <BuildActionEntry
++            buildForAnalyzing = "YES"
++            buildForTesting = "YES"
++            buildForRunning = "YES"
++            buildForProfiling = "YES"
++            buildForArchiving = "YES">
++            <BuildableReference
++               BuildableIdentifier = 'primary'
++               BlueprintIdentifier = '3D5421D734486E43DEFFAF68'
++               BlueprintName = 'Pods'
++               ReferencedContainer = 'container:Pods.xcodeproj'
++               BuildableName = 'libPods.a'>
++            </BuildableReference>
++         </BuildActionEntry>
++      </BuildActionEntries>
++   </BuildAction>
++   <TestAction
++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
++      shouldUseLaunchSchemeArgsEnv = "YES"
++      buildConfiguration = "Debug">
++      <AdditionalOptions>
++      </AdditionalOptions>
++   </TestAction>
++   <LaunchAction
++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
++      launchStyle = "0"
++      useCustomWorkingDirectory = "NO"
++      ignoresPersistentStateOnLaunch = "NO"
++      debugDocumentVersioning = "YES"
++      debugServiceExtension = "internal"
++      buildConfiguration = "Debug"
++      allowLocationSimulation = "YES">
++      <AdditionalOptions>
++      </AdditionalOptions>
++   </LaunchAction>
++   <ProfileAction
++      savedToolIdentifier = ""
++      useCustomWorkingDirectory = "NO"
++      debugDocumentVersioning = "YES"
++      buildConfiguration = "Release"
++      shouldUseLaunchSchemeArgsEnv = "YES">
++   </ProfileAction>
++   <AnalyzeAction
++      buildConfiguration = "Debug">
++   </AnalyzeAction>
++   <ArchiveAction
++      buildConfiguration = "Release"
++      revealArchiveInOrganizer = "YES">
++   </ArchiveAction>
++</Scheme>
+diff --git a/Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/xcschememanagement.plist b/Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/xcschememanagement.plist
+new file mode 100644
+index 0000000..cab6228
+--- /dev/null
++++ b/Pods/Pods.xcodeproj/xcuserdata/vasiliykravchuk.xcuserdatad/xcschemes/xcschememanagement.plist
+@@ -0,0 +1,32 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
++<plist version="1.0">
++<dict>
++	<key>SchemeUserState</key>
++	<dict>
++		<key>CocoaLumberjack.xcscheme</key>
++		<dict>
++			<key>isShown</key>
++			<false/>
++		</dict>
++		<key>Pods.xcscheme</key>
++		<dict>
++			<key>isShown</key>
++			<false/>
++		</dict>
++	</dict>
++	<key>SuppressBuildableAutocreation</key>
++	<dict>
++		<key>12E2BC28C62976C425F4B71C2723F0B1</key>
++		<dict>
++			<key>primary</key>
++			<true/>
++		</dict>
++		<key>336DBF20648F51A3CCA9CD21FAC160AA</key>
++		<dict>
++			<key>primary</key>
++			<true/>
++		</dict>
++	</dict>
++</dict>
++</plist>
+diff --git a/Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack-dummy.m b/Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack-dummy.m
+new file mode 100644
+index 0000000..2f75293
+--- /dev/null
++++ b/Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack-dummy.m
+@@ -0,0 +1,5 @@
++#import <Foundation/Foundation.h>
++@interface PodsDummy_CocoaLumberjack : NSObject
++@end
++@implementation PodsDummy_CocoaLumberjack
++@end
+diff --git a/Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack-prefix.pch b/Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack-prefix.pch
+new file mode 100644
+index 0000000..aa992a4
+--- /dev/null
++++ b/Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack-prefix.pch
+@@ -0,0 +1,4 @@
++#ifdef __OBJC__
++#import <UIKit/UIKit.h>
++#endif
++
+diff --git a/Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack.xcconfig b/Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack.xcconfig
+new file mode 100644
+index 0000000..4f728e4
+--- /dev/null
++++ b/Pods/Target Support Files/CocoaLumberjack/CocoaLumberjack.xcconfig
+@@ -0,0 +1,4 @@
++GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
++HEADER_SEARCH_PATHS = "${PODS_ROOT}/Headers/Private" "${PODS_ROOT}/Headers/Private/CocoaLumberjack" "${PODS_ROOT}/Headers/Public" "${PODS_ROOT}/Headers/Public/CocoaLumberjack"
++PODS_ROOT = ${SRCROOT}
++SKIP_INSTALL = YES
+\ No newline at end of file
+diff --git a/Pods/Target Support Files/Pods/Pods-acknowledgements.markdown b/Pods/Target Support Files/Pods/Pods-acknowledgements.markdown
+new file mode 100644
+index 0000000..f92f018
+--- /dev/null
++++ b/Pods/Target Support Files/Pods/Pods-acknowledgements.markdown
+@@ -0,0 +1,24 @@
++# Acknowledgements
++This application makes use of the following third party libraries:
++
++## CocoaLumberjack
++
++Software License Agreement (BSD License)
++
++Copyright (c) 2010-2015, Deusty, LLC
++All rights reserved.
++
++Redistribution and use of this software in source and binary forms,
++with or without modification, are permitted provided that the following conditions are met:
++
++* Redistributions of source code must retain the above
++  copyright notice, this list of conditions and the
++  following disclaimer.
++
++* Neither the name of Deusty nor the names of its
++  contributors may be used to endorse or promote products
++  derived from this software without specific prior
++  written permission of Deusty, LLC.
++
++THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++Generated by CocoaPods - http://cocoapods.org
+diff --git a/Pods/Target Support Files/Pods/Pods-acknowledgements.plist b/Pods/Target Support Files/Pods/Pods-acknowledgements.plist
+new file mode 100644
+index 0000000..6121dd6
+--- /dev/null
++++ b/Pods/Target Support Files/Pods/Pods-acknowledgements.plist
+@@ -0,0 +1,54 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
++<plist version="1.0">
++<dict>
++	<key>PreferenceSpecifiers</key>
++	<array>
++		<dict>
++			<key>FooterText</key>
++			<string>This application makes use of the following third party libraries:</string>
++			<key>Title</key>
++			<string>Acknowledgements</string>
++			<key>Type</key>
++			<string>PSGroupSpecifier</string>
++		</dict>
++		<dict>
++			<key>FooterText</key>
++			<string>Software License Agreement (BSD License)
++
++Copyright (c) 2010-2015, Deusty, LLC
++All rights reserved.
++
++Redistribution and use of this software in source and binary forms,
++with or without modification, are permitted provided that the following conditions are met:
++
++* Redistributions of source code must retain the above
++  copyright notice, this list of conditions and the
++  following disclaimer.
++
++* Neither the name of Deusty nor the names of its
++  contributors may be used to endorse or promote products
++  derived from this software without specific prior
++  written permission of Deusty, LLC.
++
++THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</string>
++			<key>Title</key>
++			<string>CocoaLumberjack</string>
++			<key>Type</key>
++			<string>PSGroupSpecifier</string>
++		</dict>
++		<dict>
++			<key>FooterText</key>
++			<string>Generated by CocoaPods - http://cocoapods.org</string>
++			<key>Title</key>
++			<string></string>
++			<key>Type</key>
++			<string>PSGroupSpecifier</string>
++		</dict>
++	</array>
++	<key>StringsTable</key>
++	<string>Acknowledgements</string>
++	<key>Title</key>
++	<string>Acknowledgements</string>
++</dict>
++</plist>
+diff --git a/Pods/Target Support Files/Pods/Pods-dummy.m b/Pods/Target Support Files/Pods/Pods-dummy.m
+new file mode 100644
+index 0000000..ade64bd
+--- /dev/null
++++ b/Pods/Target Support Files/Pods/Pods-dummy.m
+@@ -0,0 +1,5 @@
++#import <Foundation/Foundation.h>
++@interface PodsDummy_Pods : NSObject
++@end
++@implementation PodsDummy_Pods
++@end
+diff --git a/Pods/Target Support Files/Pods/Pods-frameworks.sh b/Pods/Target Support Files/Pods/Pods-frameworks.sh
+new file mode 100755
+index 0000000..6f76344
+--- /dev/null
++++ b/Pods/Target Support Files/Pods/Pods-frameworks.sh
+@@ -0,0 +1,84 @@
++#!/bin/sh
++set -e
++
++echo "mkdir -p ${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"
++mkdir -p "${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"
++
++SWIFT_STDLIB_PATH="${DT_TOOLCHAIN_DIR}/usr/lib/swift/${PLATFORM_NAME}"
++
++install_framework()
++{
++  if [ -r "${BUILT_PRODUCTS_DIR}/$1" ]; then
++    local source="${BUILT_PRODUCTS_DIR}/$1"
++  elif [ -r "${BUILT_PRODUCTS_DIR}/$(basename "$1")" ]; then
++    local source="${BUILT_PRODUCTS_DIR}/$(basename "$1")"
++  elif [ -r "$1" ]; then
++    local source="$1"
++  fi
++
++  local destination="${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"
++
++  if [ -L "${source}" ]; then
++      echo "Symlinked..."
++      source="$(readlink "${source}")"
++  fi
++
++  # use filter instead of exclude so missing patterns dont' throw errors
++  echo "rsync -av --filter \"- CVS/\" --filter \"- .svn/\" --filter \"- .git/\" --filter \"- .hg/\" --filter \"- Headers\" --filter \"- PrivateHeaders\" --filter \"- Modules\" \"${source}\" \"${destination}\""
++  rsync -av --filter "- CVS/" --filter "- .svn/" --filter "- .git/" --filter "- .hg/" --filter "- Headers" --filter "- PrivateHeaders" --filter "- Modules" "${source}" "${destination}"
++
++  local basename
++  basename="$(basename -s .framework "$1")"
++  binary="${destination}/${basename}.framework/${basename}"
++  if ! [ -r "$binary" ]; then
++    binary="${destination}/${basename}"
++  fi
++
++  # Strip invalid architectures so "fat" simulator / device frameworks work on device
++  if [[ "$(file "$binary")" == *"dynamically linked shared library"* ]]; then
++    strip_invalid_archs "$binary"
++  fi
++
++  # Resign the code if required by the build settings to avoid unstable apps
++  code_sign_if_enabled "${destination}/$(basename "$1")"
++
++  # Embed linked Swift runtime libraries. No longer necessary as of Xcode 7.
++  if [ "${XCODE_VERSION_MAJOR}" -lt 7 ]; then
++    local swift_runtime_libs
++    swift_runtime_libs=$(xcrun otool -LX "$binary" | grep --color=never @rpath/libswift | sed -E s/@rpath\\/\(.+dylib\).*/\\1/g | uniq -u  && exit ${PIPESTATUS[0]})
++    for lib in $swift_runtime_libs; do
++      echo "rsync -auv \"${SWIFT_STDLIB_PATH}/${lib}\" \"${destination}\""
++      rsync -auv "${SWIFT_STDLIB_PATH}/${lib}" "${destination}"
++      code_sign_if_enabled "${destination}/${lib}"
++    done
++  fi
++}
++
++# Signs a framework with the provided identity
++code_sign_if_enabled() {
++  if [ -n "${EXPANDED_CODE_SIGN_IDENTITY}" -a "${CODE_SIGNING_REQUIRED}" != "NO" -a "${CODE_SIGNING_ALLOWED}" != "NO" ]; then
++    # Use the current code_sign_identitiy
++    echo "Code Signing $1 with Identity ${EXPANDED_CODE_SIGN_IDENTITY_NAME}"
++    echo "/usr/bin/codesign --force --sign ${EXPANDED_CODE_SIGN_IDENTITY} --preserve-metadata=identifier,entitlements \"$1\""
++    /usr/bin/codesign --force --sign ${EXPANDED_CODE_SIGN_IDENTITY} --preserve-metadata=identifier,entitlements "$1"
++  fi
++}
++
++# Strip invalid architectures
++strip_invalid_archs() {
++  binary="$1"
++  # Get architectures for current file
++  archs="$(lipo -info "$binary" | rev | cut -d ':' -f1 | rev)"
++  stripped=""
++  for arch in $archs; do
++    if ! [[ "${VALID_ARCHS}" == *"$arch"* ]]; then
++      # Strip non-valid architectures in-place
++      lipo -remove "$arch" -output "$binary" "$binary" || exit 1
++      stripped="$stripped $arch"
++    fi
++  done
++  if [[ "$stripped" ]]; then
++    echo "Stripped $binary of architectures:$stripped"
++  fi
++}
++
+diff --git a/Pods/Target Support Files/Pods/Pods-resources.sh b/Pods/Target Support Files/Pods/Pods-resources.sh
+new file mode 100755
+index 0000000..16774fb
+--- /dev/null
++++ b/Pods/Target Support Files/Pods/Pods-resources.sh
+@@ -0,0 +1,95 @@
++#!/bin/sh
++set -e
++
++mkdir -p "${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"
++
++RESOURCES_TO_COPY=${PODS_ROOT}/resources-to-copy-${TARGETNAME}.txt
++> "$RESOURCES_TO_COPY"
++
++XCASSET_FILES=()
++
++realpath() {
++  DIRECTORY="$(cd "${1%/*}" && pwd)"
++  FILENAME="${1##*/}"
++  echo "$DIRECTORY/$FILENAME"
++}
++
++install_resource()
++{
++  case $1 in
++    *.storyboard)
++      echo "ibtool --reference-external-strings-file --errors --warnings --notices --output-format human-readable-text --compile ${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename \"$1\" .storyboard`.storyboardc ${PODS_ROOT}/$1 --sdk ${SDKROOT}"
++      ibtool --reference-external-strings-file --errors --warnings --notices --output-format human-readable-text --compile "${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename \"$1\" .storyboard`.storyboardc" "${PODS_ROOT}/$1" --sdk "${SDKROOT}"
++      ;;
++    *.xib)
++      echo "ibtool --reference-external-strings-file --errors --warnings --notices --output-format human-readable-text --compile ${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename \"$1\" .xib`.nib ${PODS_ROOT}/$1 --sdk ${SDKROOT}"
++      ibtool --reference-external-strings-file --errors --warnings --notices --output-format human-readable-text --compile "${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename \"$1\" .xib`.nib" "${PODS_ROOT}/$1" --sdk "${SDKROOT}"
++      ;;
++    *.framework)
++      echo "mkdir -p ${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"
++      mkdir -p "${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"
++      echo "rsync -av ${PODS_ROOT}/$1 ${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"
++      rsync -av "${PODS_ROOT}/$1" "${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"
++      ;;
++    *.xcdatamodel)
++      echo "xcrun momc \"${PODS_ROOT}/$1\" \"${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename "$1"`.mom\""
++      xcrun momc "${PODS_ROOT}/$1" "${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename "$1" .xcdatamodel`.mom"
++      ;;
++    *.xcdatamodeld)
++      echo "xcrun momc \"${PODS_ROOT}/$1\" \"${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename "$1" .xcdatamodeld`.momd\""
++      xcrun momc "${PODS_ROOT}/$1" "${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename "$1" .xcdatamodeld`.momd"
++      ;;
++    *.xcmappingmodel)
++      echo "xcrun mapc \"${PODS_ROOT}/$1\" \"${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename "$1" .xcmappingmodel`.cdm\""
++      xcrun mapc "${PODS_ROOT}/$1" "${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename "$1" .xcmappingmodel`.cdm"
++      ;;
++    *.xcassets)
++      ABSOLUTE_XCASSET_FILE=$(realpath "${PODS_ROOT}/$1")
++      XCASSET_FILES+=("$ABSOLUTE_XCASSET_FILE")
++      ;;
++    /*)
++      echo "$1"
++      echo "$1" >> "$RESOURCES_TO_COPY"
++      ;;
++    *)
++      echo "${PODS_ROOT}/$1"
++      echo "${PODS_ROOT}/$1" >> "$RESOURCES_TO_COPY"
++      ;;
++  esac
++}
++
++mkdir -p "${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"
++rsync -avr --copy-links --no-relative --exclude '*/.svn/*' --files-from="$RESOURCES_TO_COPY" / "${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"
++if [[ "${ACTION}" == "install" ]] && [[ "${SKIP_INSTALL}" == "NO" ]]; then
++  mkdir -p "${INSTALL_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"
++  rsync -avr --copy-links --no-relative --exclude '*/.svn/*' --files-from="$RESOURCES_TO_COPY" / "${INSTALL_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"
++fi
++rm -f "$RESOURCES_TO_COPY"
++
++if [[ -n "${WRAPPER_EXTENSION}" ]] && [ "`xcrun --find actool`" ] && [ -n "$XCASSET_FILES" ]
++then
++  case "${TARGETED_DEVICE_FAMILY}" in
++    1,2)
++      TARGET_DEVICE_ARGS="--target-device ipad --target-device iphone"
++      ;;
++    1)
++      TARGET_DEVICE_ARGS="--target-device iphone"
++      ;;
++    2)
++      TARGET_DEVICE_ARGS="--target-device ipad"
++      ;;
++    *)
++      TARGET_DEVICE_ARGS="--target-device mac"
++      ;;
++  esac
++
++  # Find all other xcassets (this unfortunately includes those of path pods and other targets).
++  OTHER_XCASSETS=$(find "$PWD" -iname "*.xcassets" -type d)
++  while read line; do
++    if [[ $line != "`realpath $PODS_ROOT`*" ]]; then
++      XCASSET_FILES+=("$line")
++    fi
++  done <<<"$OTHER_XCASSETS"
++
++  printf "%s\0" "${XCASSET_FILES[@]}" | xargs -0 xcrun actool --output-format human-readable-text --notices --warnings --platform "${PLATFORM_NAME}" --minimum-deployment-target "${IPHONEOS_DEPLOYMENT_TARGET}" ${TARGET_DEVICE_ARGS} --compress-pngs --compile "${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"
++fi
+diff --git a/Pods/Target Support Files/Pods/Pods.debug.xcconfig b/Pods/Target Support Files/Pods/Pods.debug.xcconfig
+new file mode 100644
+index 0000000..56ec97f
+--- /dev/null
++++ b/Pods/Target Support Files/Pods/Pods.debug.xcconfig
+@@ -0,0 +1,5 @@
++GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
++HEADER_SEARCH_PATHS = $(inherited) "${PODS_ROOT}/Headers/Public" "${PODS_ROOT}/Headers/Public/CocoaLumberjack"
++OTHER_CFLAGS = $(inherited) -isystem "${PODS_ROOT}/Headers/Public" -isystem "${PODS_ROOT}/Headers/Public/CocoaLumberjack"
++OTHER_LDFLAGS = $(inherited) -ObjC -l"CocoaLumberjack"
++PODS_ROOT = ${SRCROOT}/Pods
+\ No newline at end of file
+diff --git a/Pods/Target Support Files/Pods/Pods.release.xcconfig b/Pods/Target Support Files/Pods/Pods.release.xcconfig
+new file mode 100644
+index 0000000..56ec97f
+--- /dev/null
++++ b/Pods/Target Support Files/Pods/Pods.release.xcconfig
+@@ -0,0 +1,5 @@
++GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
++HEADER_SEARCH_PATHS = $(inherited) "${PODS_ROOT}/Headers/Public" "${PODS_ROOT}/Headers/Public/CocoaLumberjack"
++OTHER_CFLAGS = $(inherited) -isystem "${PODS_ROOT}/Headers/Public" -isystem "${PODS_ROOT}/Headers/Public/CocoaLumberjack"
++OTHER_LDFLAGS = $(inherited) -ObjC -l"CocoaLumberjack"
++PODS_ROOT = ${SRCROOT}/Pods
+\ No newline at end of file
+diff --git a/README.md b/README.md
+new file mode 100644
+index 0000000..fc82fd6
+--- /dev/null
++++ b/README.md
+@@ -0,0 +1,6 @@
++# BGModesTest
++iOS background modes test
++
++Open by BGModesTest.xcworkspace file
++
++Using cocoapods. All libs were downloaded for usability.
+--
+Working Copy 3.5.7
+
--
Working Copy 3.5.7

